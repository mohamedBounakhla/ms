=== ./Symbol.java ===
package core.ms.shared.domain;

import java.util.Objects;

public class Symbol {
    private final String code;
    private final String name;
    private final AssetType type;
    private final Currency baseCurrency;
    private final Currency quoteCurrency;

    public Symbol(String code, String name, AssetType type, Currency baseCurrency, Currency quoteCurrency) {
        if (code == null || code.trim().isEmpty()) {
            throw new IllegalArgumentException("Code cannot be null or empty");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Name cannot be null or empty");
        }
        if (type == null) {
            throw new IllegalArgumentException("AssetType cannot be null");
        }
        if (baseCurrency == null) {
            throw new IllegalArgumentException("Base currency cannot be null");
        }
        if (quoteCurrency == null) {
            throw new IllegalArgumentException("Quote currency cannot be null");
        }

        this.code = code.toUpperCase().trim();
        this.name = name.trim();
        this.type = type;
        this.baseCurrency = baseCurrency;
        this.quoteCurrency = quoteCurrency;
    }

    // ===== GETTERS =====

    public String getCode() {
        return code;
    }

    public String getName() {
        return name;
    }

    public AssetType getType() {
        return type;
    }

    public Currency getBaseCurrency() {
        return baseCurrency;
    }

    public Currency getQuoteCurrency() {
        return quoteCurrency;
    }

    // ===== BUSINESS METHODS =====

    public String getFullSymbol() {
        return code + "/" + quoteCurrency.name();
    }

    public String getDisplayName() {
        return String.format("%s (%s)", name, code);
    }

    public boolean isCrypto() {
        return type == AssetType.CRYPTO;
    }

    public boolean isStock() {
        return type == AssetType.STOCK;
    }

    public boolean isForex() {
        return type == AssetType.FOREX;
    }

    public boolean isCommodity() {
        return type == AssetType.COMMODITY;
    }

    public boolean isCrossCurrency() {
        return baseCurrency != quoteCurrency;
    }

    // ===== FACTORY METHODS =====

    public static Symbol btcUsd() {
        return new Symbol("BTC", "Bitcoin", AssetType.CRYPTO, Currency.BTC, Currency.USD);
    }

    public static Symbol btcEur() {
        return new Symbol("BTC", "Bitcoin", AssetType.CRYPTO, Currency.BTC, Currency.EUR);
    }

    public static Symbol ethUsd() {
        return new Symbol("ETH", "Ethereum", AssetType.CRYPTO, Currency.ETH, Currency.USD);
    }

    public static Symbol eurUsd() {
        return new Symbol("EURUSD", "Euro US Dollar", AssetType.FOREX, Currency.EUR, Currency.USD);
    }

    public static Symbol gbpUsd() {
        return new Symbol("GBPUSD", "British Pound US Dollar", AssetType.FOREX, Currency.GBP, Currency.USD);
    }

    // ===== OBJECT METHODS =====

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Symbol symbol = (Symbol) obj;
        return Objects.equals(code, symbol.code) &&
                Objects.equals(name, symbol.name) &&
                type == symbol.type &&
                baseCurrency == symbol.baseCurrency &&
                quoteCurrency == symbol.quoteCurrency;
    }

    @Override
    public int hashCode() {
        return Objects.hash(code, name, type, baseCurrency, quoteCurrency);
    }

    @Override
    public String toString() {
        return getFullSymbol();
    }
}=== ./ArithmeticStrategy.java ===
package core.ms.shared.domain;

import java.math.BigDecimal;
import java.math.RoundingMode;

public enum ArithmeticStrategy {
    ROUND_TO_CURRENCY_PRECISION {
        @Override
        public BigDecimal processResult(BigDecimal result, Currency currency) {
            return result.setScale(currency.getDecimalPlaces(), RoundingMode.HALF_UP);
        }
    },
    PRESERVE_FULL_PRECISION {
        @Override
        public BigDecimal processResult(BigDecimal result, Currency currency) {
            return result; // Keep all decimal places
        }
    },
    ROUND_TO_WHOLE_NUMBERS {
        @Override
        public BigDecimal processResult(BigDecimal result, Currency currency) {
            return result.setScale(0, RoundingMode.HALF_UP);
        }
    };

    public abstract BigDecimal processResult(BigDecimal result, Currency currency);
}=== ./AssetType.java ===
package core.ms.shared.domain;

public enum AssetType {
    CRYPTO("Cryptocurrency"),
    STOCK("Stock"),
    FOREX("Foreign Exchange"),
    COMMODITY("Commodity");

    private final String displayName;

    AssetType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }

    @Override
    public String toString() {
        return displayName;
    }
}=== ./Currency.java ===
package core.ms.shared.domain;

import java.math.BigDecimal;

public enum Currency {
    USD("$", 2, "US Dollar", ArithmeticStrategy.ROUND_TO_CURRENCY_PRECISION),
    EUR("€", 2, "Euro", ArithmeticStrategy.ROUND_TO_CURRENCY_PRECISION),
    GBP("£", 2, "British Pound", ArithmeticStrategy.ROUND_TO_CURRENCY_PRECISION),
    JPY("¥", 0, "Japanese Yen", ArithmeticStrategy.ROUND_TO_WHOLE_NUMBERS),
    BTC("₿", 8, "Bitcoin", ArithmeticStrategy.PRESERVE_FULL_PRECISION),
    ETH("Ξ", 18, "Ethereum", ArithmeticStrategy.PRESERVE_FULL_PRECISION);

    private final String symbol;
    private final int decimalPlaces; // For display formatting only
    private final String displayName;
    private final ArithmeticStrategy arithmeticStrategy;
    Currency(String symbol, int decimalPlaces, String displayName, ArithmeticStrategy arithmeticStrategy) {
        this.symbol = symbol;
        this.decimalPlaces = decimalPlaces;
        this.displayName = displayName;
        this.arithmeticStrategy =arithmeticStrategy;
    }
    public BigDecimal processArithmeticResult(BigDecimal result) {
        return arithmeticStrategy.processResult(result, this);
    }
    public String getSymbol() {
        return symbol;
    }

    public int getDecimalPlaces() {
        return decimalPlaces;
    }

    public String getDisplayName() {
        return displayName;
    }

    public boolean isFiat() {
        return this == USD || this == EUR || this == GBP || this == JPY;
    }

    public boolean isCrypto() {
        return this == BTC || this == ETH;
    }

    @Override
    public String toString() {
        return this.name();
    }
}=== ./Money.java ===
package core.ms.shared.domain;


import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

public class Money {
    private final BigDecimal amount;
    private final Currency currency;

    public Money(BigDecimal amount, Currency currency) {
        if (amount == null) {
            throw new IllegalArgumentException("Amount cannot be null");
        }
        if (currency == null) {
            throw new IllegalArgumentException("Currency cannot be null");
        }
        this.amount = amount; // Keep full precision - no rounding
        this.currency = currency;
    }

    public Money(String amount, Currency currency) {
        this(new BigDecimal(amount), currency);
    }

    // ===== ARITHMETIC OPERATIONS =====

    public Money add(Money other) {
        validateSameCurrency(other);
        BigDecimal result = amount.add(other.amount);
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    public Money subtract(Money other) {
        validateSameCurrency(other);
        BigDecimal result = amount.subtract(other.amount);
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    public Money multiply(BigDecimal scalar) {
        if (scalar == null) {
            throw new IllegalArgumentException("Scalar cannot be null");
        }
        BigDecimal result = amount.multiply(scalar);
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    public Money multiply(double scalar) {
        return multiply(BigDecimal.valueOf(scalar));
    }

    public Money divide(BigDecimal divisor) {
        if (divisor == null) {
            throw new IllegalArgumentException("Divisor cannot be null");
        }
        if (divisor.compareTo(BigDecimal.ZERO) == 0) {
            throw new IllegalArgumentException("Cannot divide by zero");
        }
        // First perform division with high precision
        BigDecimal result = amount.divide(divisor, 20, RoundingMode.HALF_UP);
        // Then apply currency-specific processing
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    public Money negate() {
        BigDecimal result = amount.negate();
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    // ===== COMPARISON OPERATIONS =====

    public boolean isGreaterThan(Money other) {
        validateSameCurrency(other);
        return amount.compareTo(other.amount) > 0;
    }

    public boolean isLessThan(Money other) {
        validateSameCurrency(other);
        return amount.compareTo(other.amount) < 0;
    }

    public boolean isGreaterThanOrEqual(Money other) {
        validateSameCurrency(other);
        return amount.compareTo(other.amount) >= 0;
    }

    public boolean isLessThanOrEqual(Money other) {
        validateSameCurrency(other);
        return amount.compareTo(other.amount) <= 0;
    }

    public boolean isZero() {
        return amount.compareTo(BigDecimal.ZERO) == 0;
    }

    public boolean isPositive() {
        return amount.compareTo(BigDecimal.ZERO) > 0;
    }

    public boolean isNegative() {
        return amount.compareTo(BigDecimal.ZERO) < 0;
    }

    // ===== GETTERS =====

    public BigDecimal getAmount() {
        return amount;
    }

    public Currency getCurrency() {
        return currency;
    }

    // ===== FORMATTING =====

    public String toDisplayString() {
        BigDecimal displayAmount = amount.setScale(currency.getDecimalPlaces(), RoundingMode.HALF_UP);
        return currency.getSymbol() + displayAmount.toPlainString();
    }

    public String toPlainString() {
        return amount.toPlainString() + " " + currency.name();
    }

    // ===== FACTORY METHODS =====

    public static Money zero(Currency currency) {
        return new Money(BigDecimal.ZERO, currency);
    }

    public static Money of(String amount, Currency currency) {
        return new Money(amount, currency);
    }

    public static Money of(BigDecimal amount, Currency currency) {
        return new Money(amount, currency);
    }

    public static Money usd(String amount) {
        return new Money(amount, Currency.USD);
    }

    public static Money eur(String amount) {
        return new Money(amount, Currency.EUR);
    }

    // ===== PRIVATE METHODS =====

    private void validateSameCurrency(Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException(
                    String.format("Cannot operate on different currencies: %s and %s",
                            currency, other.currency));
        }
    }


    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Money money = (Money) obj;
        return amount.compareTo(money.amount) == 0 && currency == money.currency;
    }

    @Override
    public int hashCode() {
        BigDecimal normalizedAmount = amount.stripTrailingZeros();
        return Objects.hash(normalizedAmount, currency);
    }

    @Override
    public String toString() {
        return toDisplayString();
    }

    public Money abs() {
        if (amount.compareTo(BigDecimal.ZERO) >= 0) {
            return this;
        }
        return new Money(amount.abs(), currency);
    }
}
