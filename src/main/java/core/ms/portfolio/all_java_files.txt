=== ./domain/PortfolioTransaction.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.TransactionType;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Objects;

public class PortfolioTransaction {
    private final String id;
    private final String portfolioId;
    private final TransactionType type;
    private final Symbol symbol; // Null for cash-only transactions
    private final BigDecimal quantity; // Zero for cash-only transactions
    private final Money price; // Price per unit for asset transactions
    private final Money totalAmount; // Total transaction amount
    private final LocalDateTime timestamp;
    private final String relatedOrderId; // Null if not related to an order

    public PortfolioTransaction(String id, String portfolioId, TransactionType type,
                                Symbol symbol, BigDecimal quantity, Money price,
                                Money totalAmount, String relatedOrderId) {
        this.id = Objects.requireNonNull(id, "Transaction ID cannot be null");
        this.portfolioId = Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        this.type = Objects.requireNonNull(type, "Transaction type cannot be null");
        this.symbol = symbol; // Can be null for cash transactions
        this.quantity = quantity != null ? quantity : BigDecimal.ZERO;
        this.price = price; // Can be null for cash transactions
        this.totalAmount = Objects.requireNonNull(totalAmount, "Total amount cannot be null");
        this.timestamp = LocalDateTime.now();
        this.relatedOrderId = relatedOrderId; // Can be null

        validateTransaction();
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getPortfolioId() {
        return portfolioId;
    }

    public TransactionType getType() {
        return type;
    }

    public Symbol getSymbol() {
        return symbol;
    }

    public BigDecimal getQuantity() {
        return quantity;
    }

    public Money getPrice() {
        return price;
    }

    public Money getTotalAmount() {
        return totalAmount;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public String getRelatedOrderId() {
        return relatedOrderId;
    }

    // Business methods
    public boolean isCashTransaction() {
        return type.isCashTransaction();
    }

    public boolean isAssetTransaction() {
        return type.isAssetTransaction();
    }

    public boolean affectsCashBalance() {
        return type.affectsCash();
    }

    public boolean affectsPosition() {
        return type.affectsPosition();
    }

    public String getSymbolCode() {
        return symbol != null ? symbol.getCode() : null;
    }

    // Static factory methods for creating specific transaction types
    public static PortfolioTransaction createBuyTransaction(String id, String portfolioId,
                                                            Symbol symbol, BigDecimal quantity,
                                                            Money price, String relatedOrderId) {
        Money totalAmount = price.multiply(quantity);
        return new PortfolioTransaction(id, portfolioId, TransactionType.BUY,
                symbol, quantity, price, totalAmount, relatedOrderId);
    }

    public static PortfolioTransaction createSellTransaction(String id, String portfolioId,
                                                             Symbol symbol, BigDecimal quantity,
                                                             Money price, String relatedOrderId) {
        Money totalAmount = price.multiply(quantity);
        return new PortfolioTransaction(id, portfolioId, TransactionType.SELL,
                symbol, quantity, price, totalAmount, relatedOrderId);
    }

    public static PortfolioTransaction createDepositTransaction(String id, String portfolioId,
                                                                Money amount) {
        return new PortfolioTransaction(id, portfolioId, TransactionType.DEPOSIT,
                null, BigDecimal.ZERO, null, amount, null);
    }

    public static PortfolioTransaction createWithdrawalTransaction(String id, String portfolioId,
                                                                   Money amount) {
        return new PortfolioTransaction(id, portfolioId, TransactionType.WITHDRAWAL,
                null, BigDecimal.ZERO, null, amount, null);
    }

    private void validateTransaction() {
        if (type.isAssetTransaction()) {
            if (symbol == null) {
                throw new IllegalArgumentException("Symbol is required for asset transactions");
            }
            if (price == null) {
                throw new IllegalArgumentException("Price is required for asset transactions");
            }
            if (quantity.compareTo(BigDecimal.ZERO) <= 0) {
                throw new IllegalArgumentException("Quantity must be positive for asset transactions");
            }
        }

        if (type.isCashTransaction()) {
            if (symbol != null) {
                throw new IllegalArgumentException("Symbol should be null for cash transactions");
            }
            if (price != null) {
                throw new IllegalArgumentException("Price should be null for cash transactions");
            }
        }

        if (totalAmount.isNegative()) {
            throw new IllegalArgumentException("Total amount cannot be negative");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PortfolioTransaction that = (PortfolioTransaction) obj;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        if (type.isAssetTransaction()) {
            return String.format("PortfolioTransaction[%s: %s %s %s @ %s = %s]",
                    id, type, quantity, symbol.getCode(), price, totalAmount);
        } else {
            return String.format("PortfolioTransaction[%s: %s %s]",
                    id, type, totalAmount);
        }
    }
}=== ./domain/PortfolioManager.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.PortfolioSummary;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import core.ms.utils.IdGenerator;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class PortfolioManager {
    private final Map<String, Portfolio> portfolios;
    private final Map<String, Set<String>> userPortfolios; // userId -> Set of portfolioIds
    private final IdGenerator idGenerator;

    public PortfolioManager() {
        this.portfolios = new ConcurrentHashMap<>();
        this.userPortfolios = new ConcurrentHashMap<>();
        this.idGenerator = new IdGenerator();
    }

    /**
     * Creates a new portfolio for a user.
     */
    public Portfolio createPortfolio(String name, String userId, Currency baseCurrency) {
        Objects.requireNonNull(name, "Portfolio name cannot be null");
        Objects.requireNonNull(userId, "User ID cannot be null");
        Objects.requireNonNull(baseCurrency, "Base currency cannot be null");

        if (name.trim().isEmpty()) {
            throw new IllegalArgumentException("Portfolio name cannot be empty");
        }

        String portfolioId = idGenerator.generateTransactionId(); // Reuse for portfolio IDs
        Money initialCash = Money.zero(baseCurrency);

        Portfolio portfolio = new Portfolio(portfolioId, name.trim(), userId, initialCash);

        portfolios.put(portfolioId, portfolio);
        userPortfolios.computeIfAbsent(userId, k -> ConcurrentHashMap.newKeySet()).add(portfolioId);

        return portfolio;
    }

    /**
     * Creates a new portfolio with initial cash deposit.
     */
    public Portfolio createPortfolioWithInitialDeposit(String name, String userId, Money initialCash) {
        Objects.requireNonNull(initialCash, "Initial cash cannot be null");

        if (initialCash.isNegative()) {
            throw new IllegalArgumentException("Initial cash cannot be negative");
        }

        Portfolio portfolio = createPortfolio(name, userId, initialCash.getCurrency());

        if (initialCash.isPositive()) {
            portfolio.depositCash(initialCash);
        }

        return portfolio;
    }

    /**
     * Retrieves a portfolio by ID.
     */
    public Optional<Portfolio> getPortfolio(String portfolioId) {
        Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        return Optional.ofNullable(portfolios.get(portfolioId));
    }

    /**
     * Retrieves all portfolios for a specific user.
     */
    public List<Portfolio> getUserPortfolios(String userId) {
        Objects.requireNonNull(userId, "User ID cannot be null");

        Set<String> portfolioIds = userPortfolios.getOrDefault(userId, Collections.emptySet());

        return portfolioIds.stream()
                .map(portfolios::get)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    /**
     * Deletes a portfolio (only if it belongs to the specified user and has no positions).
     */
    public boolean deletePortfolio(String portfolioId, String userId) {
        Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        Objects.requireNonNull(userId, "User ID cannot be null");

        Portfolio portfolio = portfolios.get(portfolioId);
        if (portfolio == null) {
            return false;
        }

        // Verify ownership
        if (!portfolio.getUserId().equals(userId)) {
            throw new IllegalArgumentException("Portfolio does not belong to the specified user");
        }

        // Check if portfolio can be deleted (no positions)
        if (!portfolio.getPositions().isEmpty()) {
            throw new IllegalStateException("Cannot delete portfolio with active positions");
        }

        // Remove from both maps
        portfolios.remove(portfolioId);
        Set<String> userPortfolioSet = userPortfolios.get(userId);
        if (userPortfolioSet != null) {
            userPortfolioSet.remove(portfolioId);
            if (userPortfolioSet.isEmpty()) {
                userPortfolios.remove(userId);
            }
        }

        return true;
    }

    /**
     * Calculates the total value of a portfolio using current market prices.
     */
    public Money calculateTotalValue(Portfolio portfolio, Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(portfolio, "Portfolio cannot be null");
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        return portfolio.getTotalValue(currentPrices);
    }

    /**
     * Generates a comprehensive summary of a portfolio.
     */
    public PortfolioSummary generatePortfolioSummary(Portfolio portfolio, Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(portfolio, "Portfolio cannot be null");
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        Money totalValue = portfolio.getTotalValue(currentPrices);
        Money cashBalance = portfolio.getCashBalance();
        Money totalInvested = portfolio.getTotalInvested();
        Money totalProfitLoss = portfolio.getTotalProfitLoss(currentPrices);

        BigDecimal profitLossPercentage = calculateProfitLossPercentage(totalInvested, totalProfitLoss);

        int positionCount = portfolio.getPositions().size();
        int transactionCount = portfolio.getTransactions().size();

        return new PortfolioSummary(
                portfolio.getId(),
                portfolio.getName(),
                totalValue,
                cashBalance,
                totalInvested,
                totalProfitLoss,
                profitLossPercentage,
                positionCount,
                transactionCount
        );
    }

    /**
     * Gets aggregated statistics across all portfolios for a user.
     */
    public Map<String, Object> getUserPortfolioStatistics(String userId, Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(userId, "User ID cannot be null");
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        List<Portfolio> userPortfolioList = getUserPortfolios(userId);

        if (userPortfolioList.isEmpty()) {
            return Collections.emptyMap();
        }

        Currency baseCurrency = userPortfolioList.get(0).getBaseCurrency(); // Assume same currency

        Money totalValue = Money.zero(baseCurrency);
        Money totalCash = Money.zero(baseCurrency);
        Money totalInvested = Money.zero(baseCurrency);
        Money totalProfitLoss = Money.zero(baseCurrency);
        int totalPositions = 0;
        int totalTransactions = 0;

        for (Portfolio portfolio : userPortfolioList) {
            totalValue = totalValue.add(portfolio.getTotalValue(currentPrices));
            totalCash = totalCash.add(portfolio.getCashBalance());
            totalInvested = totalInvested.add(portfolio.getTotalInvested());
            totalProfitLoss = totalProfitLoss.add(portfolio.getTotalProfitLoss(currentPrices));
            totalPositions += portfolio.getPositions().size();
            totalTransactions += portfolio.getTransactions().size();
        }

        Map<String, Object> statistics = new HashMap<>();
        statistics.put("userId", userId);
        statistics.put("portfolioCount", userPortfolioList.size());
        statistics.put("totalValue", totalValue);
        statistics.put("totalCash", totalCash);
        statistics.put("totalInvested", totalInvested);
        statistics.put("totalProfitLoss", totalProfitLoss);
        statistics.put("profitLossPercentage", calculateProfitLossPercentage(totalInvested, totalProfitLoss));
        statistics.put("totalPositions", totalPositions);
        statistics.put("totalTransactions", totalTransactions);

        return statistics;
    }

    /**
     * Finds portfolios that contain a specific symbol.
     */
    public List<Portfolio> getPortfoliosWithSymbol(String userId, Symbol symbol) {
        Objects.requireNonNull(userId, "User ID cannot be null");
        Objects.requireNonNull(symbol, "Symbol cannot be null");

        return getUserPortfolios(userId).stream()
                .filter(portfolio -> portfolio.getPosition(symbol).isPresent())
                .collect(Collectors.toList());
    }

    /**
     * Gets all portfolios (admin function).
     */
    public Collection<Portfolio> getAllPortfolios() {
        return new ArrayList<>(portfolios.values());
    }

    /**
     * Gets portfolio count statistics.
     */
    public Map<String, Integer> getPortfolioStatistics() {
        Map<String, Integer> stats = new HashMap<>();
        stats.put("totalPortfolios", portfolios.size());
        stats.put("totalUsers", userPortfolios.size());

        int totalPositions = portfolios.values().stream()
                .mapToInt(p -> p.getPositions().size())
                .sum();
        stats.put("totalPositions", totalPositions);

        int totalTransactions = portfolios.values().stream()
                .mapToInt(p -> p.getTransactions().size())
                .sum();
        stats.put("totalTransactions", totalTransactions);

        return stats;
    }

    private BigDecimal calculateProfitLossPercentage(Money totalInvested, Money totalProfitLoss) {
        if (totalInvested.isZero()) {
            return BigDecimal.ZERO;
        }

        return totalProfitLoss.getAmount()
                .divide(totalInvested.getAmount(), 4, RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
    }
}
=== ./domain/value/TransactionType.java ===
package core.ms.portfolio.domain.value;

public enum TransactionType {
    BUY("Asset Purchase"),
    SELL("Asset Sale"),
    DEPOSIT("Cash Deposit"),
    WITHDRAWAL("Cash Withdrawal");

    private final String description;

    TransactionType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Returns true if this transaction type affects the cash balance.
     */
    public boolean affectsCash() {
        return switch (this) {
            case BUY, WITHDRAWAL -> true;  // Decreases cash
            case SELL, DEPOSIT -> true;    // Increases cash
        };
    }

    /**
     * Returns true if this transaction type affects asset positions.
     */
    public boolean affectsPosition() {
        return switch (this) {
            case BUY -> true;     // Increases position
            case SELL -> true;    // Decreases position
            case DEPOSIT, WITHDRAWAL -> false; // Cash only
        };
    }

    /**
     * Returns true if this is an asset-related transaction (buy/sell).
     */
    public boolean isAssetTransaction() {
        return this == BUY || this == SELL;
    }

    /**
     * Returns true if this is a cash-only transaction (deposit/withdrawal).
     */
    public boolean isCashTransaction() {
        return this == DEPOSIT || this == WITHDRAWAL;
    }

    /**
     * Returns true if this transaction increases cash balance.
     */
    public boolean increasesCash() {
        return this == SELL || this == DEPOSIT;
    }

    /**
     * Returns true if this transaction decreases cash balance.
     */
    public boolean decreasesCash() {
        return this == BUY || this == WITHDRAWAL;
    }

    @Override
    public String toString() {
        return description;
    }
}=== ./domain/value/PortfolioSummary.java ===
package core.ms.portfolio.domain.value;

import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Objects;

public class PortfolioSummary {
    private final String portfolioId;
    private final String portfolioName;
    private final Money totalValue;
    private final Money cashBalance;
    private final Money totalInvested;
    private final Money totalProfitLoss;
    private final BigDecimal profitLossPercentage;
    private final int positionCount;
    private final int transactionCount;
    private final LocalDateTime createdAt;

    public PortfolioSummary(String portfolioId, String portfolioName, Money totalValue,
                            Money cashBalance, Money totalInvested, Money totalProfitLoss,
                            BigDecimal profitLossPercentage, int positionCount, int transactionCount) {
        this.portfolioId = Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        this.portfolioName = Objects.requireNonNull(portfolioName, "Portfolio name cannot be null");
        this.totalValue = Objects.requireNonNull(totalValue, "Total value cannot be null");
        this.cashBalance = Objects.requireNonNull(cashBalance, "Cash balance cannot be null");
        this.totalInvested = Objects.requireNonNull(totalInvested, "Total invested cannot be null");
        this.totalProfitLoss = Objects.requireNonNull(totalProfitLoss, "Total profit/loss cannot be null");
        this.profitLossPercentage = Objects.requireNonNull(profitLossPercentage, "Profit/loss percentage cannot be null");
        this.positionCount = positionCount;
        this.transactionCount = transactionCount;
        this.createdAt = LocalDateTime.now();

        validateSummary();
    }

    // Getters
    public String getPortfolioId() {
        return portfolioId;
    }

    public String getPortfolioName() {
        return portfolioName;
    }

    public Money getTotalValue() {
        return totalValue;
    }

    public Money getCashBalance() {
        return cashBalance;
    }

    public Money getTotalInvested() {
        return totalInvested;
    }

    public Money getTotalProfitLoss() {
        return totalProfitLoss;
    }

    public BigDecimal getProfitLossPercentage() {
        return profitLossPercentage;
    }

    public int getPositionCount() {
        return positionCount;
    }

    public int getTransactionCount() {
        return transactionCount;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    // Business methods
    public boolean isPositive() {
        return totalProfitLoss.isPositive();
    }

    public boolean isNegative() {
        return totalProfitLoss.isNegative();
    }

    public boolean isBreakEven() {
        return totalProfitLoss.isZero();
    }

    public Money getPortfolioValue() {
        return totalInvested.add(cashBalance);
    }

    public BigDecimal getCashPercentage() {
        if (totalValue.isZero()) {
            return BigDecimal.ZERO;
        }

        return cashBalance.getAmount()
                .divide(totalValue.getAmount(), 4, java.math.RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
    }

    public BigDecimal getInvestedPercentage() {
        if (totalValue.isZero()) {
            return BigDecimal.ZERO;
        }

        return totalInvested.getAmount()
                .divide(totalValue.getAmount(), 4, java.math.RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
    }

    public String getPerformanceStatus() {
        if (isPositive()) {
            return "PROFIT";
        } else if (isNegative()) {
            return "LOSS";
        } else {
            return "BREAK_EVEN";
        }
    }

    private void validateSummary() {
        if (positionCount < 0) {
            throw new IllegalArgumentException("Position count cannot be negative");
        }

        if (transactionCount < 0) {
            throw new IllegalArgumentException("Transaction count cannot be negative");
        }

        if (totalValue.isNegative()) {
            throw new IllegalArgumentException("Total value cannot be negative");
        }

        if (cashBalance.isNegative()) {
            throw new IllegalArgumentException("Cash balance cannot be negative");
        }

        if (totalInvested.isNegative()) {
            throw new IllegalArgumentException("Total invested cannot be negative");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PortfolioSummary that = (PortfolioSummary) obj;
        return Objects.equals(portfolioId, that.portfolioId) &&
                Objects.equals(createdAt, that.createdAt);
    }

    @Override
    public int hashCode() {
        return Objects.hash(portfolioId, createdAt);
    }

    @Override
    public String toString() {
        return String.format("PortfolioSummary[%s: '%s' - Value: %s, P&L: %s (%.2f%%), %d positions]",
                portfolioId, portfolioName, totalValue, totalProfitLoss,
                profitLossPercentage, positionCount);
    }
}=== ./domain/Position.java ===
package core.ms.portfolio.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import core.ms.utils.BigDecimalNormalizer;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.Objects;

public class Position {
    private final String id;
    private final String portfolioId;
    private final Symbol symbol;
    private BigDecimal quantity;
    private Money averagePrice;
    private final LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public Position(String id, String portfolioId, Symbol symbol, BigDecimal quantity, Money averagePrice) {
        this.id = Objects.requireNonNull(id, "Position ID cannot be null");
        this.portfolioId = Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.quantity = Objects.requireNonNull(quantity, "Quantity cannot be null");
        this.averagePrice = Objects.requireNonNull(averagePrice, "Average price cannot be null");
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();

        validatePosition();
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getPortfolioId() {
        return portfolioId;
    }

    public Symbol getSymbol() {
        return symbol;
    }

    public BigDecimal getQuantity() {
        return BigDecimalNormalizer.normalize(quantity);
    }

    public Money getAveragePrice() {
        return averagePrice;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    // Business methods
    public String getSymbolCode() {
        return symbol.getCode();
    }

    /**
     * Calculates the current market value of this position.
     */
    public Money getCurrentValue(Money currentPrice) {
        Objects.requireNonNull(currentPrice, "Current price cannot be null");
        validateCurrency(currentPrice, "Current price");
        return currentPrice.multiply(quantity);
    }

    /**
     * Calculates the total cost basis of this position.
     */
    public Money getCostBasis() {
        return averagePrice.multiply(quantity);
    }

    /**
     * Calculates the profit or loss based on current market price.
     * Positive value indicates profit, negative indicates loss.
     */
    public Money getProfitLoss(Money currentPrice) {
        Objects.requireNonNull(currentPrice, "Current price cannot be null");
        validateCurrency(currentPrice, "Current price");

        Money currentValue = getCurrentValue(currentPrice);
        Money costBasis = getCostBasis();
        return currentValue.subtract(costBasis);
    }

    /**
     * Calculates the profit or loss percentage based on current market price.
     */
    public BigDecimal getProfitLossPercentage(Money currentPrice) {
        Objects.requireNonNull(currentPrice, "Current price cannot be null");
        validateCurrency(currentPrice, "Current price");

        Money profitLoss = getProfitLoss(currentPrice);
        Money costBasis = getCostBasis();

        if (costBasis.isZero()) {
            return BigDecimal.ZERO;
        }

        // Calculate: (profitLoss / costBasis) * 100
        BigDecimal profitLossAmount = profitLoss.getAmount();
        BigDecimal costBasisAmount = costBasis.getAmount();

        return profitLossAmount
                .divide(costBasisAmount, 4, RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
    }

    /**
     * Adds quantity to this position and updates the average price.
     */
    public void addQuantity(BigDecimal additionalQuantity, Money price) {
        Objects.requireNonNull(additionalQuantity, "Additional quantity cannot be null");
        Objects.requireNonNull(price, "Price cannot be null");
        validateCurrency(price, "Price");

        if (additionalQuantity.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Additional quantity must be positive");
        }

        // Calculate new average price using weighted average
        Money newAveragePrice = calculateNewAveragePrice(additionalQuantity, price);

        this.quantity = this.quantity.add(additionalQuantity);
        this.averagePrice = newAveragePrice;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Removes quantity from this position. Does not affect average price.
     */
    public void removeQuantity(BigDecimal quantityToRemove) {
        Objects.requireNonNull(quantityToRemove, "Quantity to remove cannot be null");
        validateQuantityRemoval(quantityToRemove);

        this.quantity = this.quantity.subtract(quantityToRemove);
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Returns true if this position has no quantity (empty position).
     */
    public boolean isEmpty() {
        return quantity.compareTo(BigDecimal.ZERO) == 0;
    }

    /**
     * Returns true if this position has sufficient quantity for removal.
     */
    public boolean hasSufficientQuantity(BigDecimal quantityToCheck) {
        Objects.requireNonNull(quantityToCheck, "Quantity to check cannot be null");
        return quantity.compareTo(quantityToCheck) >= 0;
    }

    private Money calculateNewAveragePrice(BigDecimal additionalQuantity, Money price) {
        // Weighted average: ((existing_qty * avg_price) + (new_qty * new_price)) / (existing_qty + new_qty)
        Money existingCost = averagePrice.multiply(quantity);
        Money additionalCost = price.multiply(additionalQuantity);
        Money totalCost = existingCost.add(additionalCost);
        BigDecimal totalQuantity = quantity.add(additionalQuantity);

        return totalCost.divide(totalQuantity);
    }

    private void validateQuantityRemoval(BigDecimal quantityToRemove) {
        if (quantityToRemove.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Quantity to remove must be positive");
        }

        if (quantityToRemove.compareTo(quantity) > 0) {
            throw new IllegalArgumentException(
                    String.format("Cannot remove %s units. Only %s units available",
                            quantityToRemove, quantity));
        }
    }

    private void validateCurrency(Money money, String fieldName) {
        if (!money.getCurrency().equals(averagePrice.getCurrency())) {
            throw new IllegalArgumentException(
                    String.format("%s currency %s does not match position currency %s",
                            fieldName, money.getCurrency(), averagePrice.getCurrency()));
        }
    }

    private void validatePosition() {
        if (quantity.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Quantity cannot be negative");
        }

        if (averagePrice.isNegative()) {
            throw new IllegalArgumentException("Average price cannot be negative");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Position position = (Position) obj;
        return Objects.equals(id, position.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("Position[%s: %s %s @ %s avg, value: %s]",
                id, quantity, symbol.getCode(), averagePrice, getCostBasis());
    }
}=== ./domain/Portfolio.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.TransactionType;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import core.ms.utils.IdGenerator;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

public class Portfolio {
    private final String id;
    private final String name;
    private final String userId;
    private Money cashBalance;
    private final Currency baseCurrency;
    private final LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private final Map<Symbol, Position> positions;
    private final List<PortfolioTransaction> transactions;
    private final IdGenerator idGenerator;

    public Portfolio(String id, String name, String userId, Money initialCashBalance) {
        this.id = Objects.requireNonNull(id, "Portfolio ID cannot be null");
        this.name = Objects.requireNonNull(name, "Portfolio name cannot be null");
        this.userId = Objects.requireNonNull(userId, "User ID cannot be null");
        this.cashBalance = Objects.requireNonNull(initialCashBalance, "Initial cash balance cannot be null");
        this.baseCurrency = initialCashBalance.getCurrency();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.positions = new HashMap<>();
        this.transactions = new ArrayList<>();
        this.idGenerator = new IdGenerator();

        validatePortfolio();
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getUserId() {
        return userId;
    }

    public Money getCashBalance() {
        return cashBalance;
    }

    public Currency getBaseCurrency() {
        return baseCurrency;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public Collection<Position> getPositions() {
        return new ArrayList<>(positions.values());
    }

    public List<PortfolioTransaction> getTransactions() {
        return new ArrayList<>(transactions);
    }

    // Business Operations

    /**
     * Deposits cash into the portfolio.
     */
    public PortfolioTransaction depositCash(Money amount) {
        Objects.requireNonNull(amount, "Amount cannot be null");
        validateCurrency(amount, "Deposit amount");

        if (amount.isNegative() || amount.isZero()) {
            throw new IllegalArgumentException("Deposit amount must be positive");
        }

        updateCashBalance(amount);

        PortfolioTransaction transaction = PortfolioTransaction.createDepositTransaction(
                idGenerator.generateTransactionId(), id, amount);
        addTransaction(transaction);

        return transaction;
    }

    /**
     * Withdraws cash from the portfolio.
     */
    public PortfolioTransaction withdrawCash(Money amount) {
        Objects.requireNonNull(amount, "Amount cannot be null");
        validateCurrency(amount, "Withdrawal amount");
        validateSufficientCash(amount);

        updateCashBalance(amount.negate());

        PortfolioTransaction transaction = PortfolioTransaction.createWithdrawalTransaction(
                idGenerator.generateTransactionId(), id, amount);
        addTransaction(transaction);

        return transaction;
    }

    /**
     * Buys an asset and updates the portfolio.
     */
    public PortfolioTransaction buyAsset(Symbol symbol, BigDecimal quantity, Money price, String relatedOrderId) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        Objects.requireNonNull(quantity, "Quantity cannot be null");
        Objects.requireNonNull(price, "Price cannot be null");
        validateCurrency(price, "Price");

        Money totalCost = price.multiply(quantity);
        validateSufficientCash(totalCost);

        // Update cash balance
        updateCashBalance(totalCost.negate());

        // Update position
        updatePosition(symbol, quantity, price, TransactionType.BUY);

        // Create transaction record
        PortfolioTransaction transaction = PortfolioTransaction.createBuyTransaction(
                idGenerator.generateTransactionId(), id, symbol, quantity, price, relatedOrderId);
        addTransaction(transaction);

        return transaction;
    }

    /**
     * Sells an asset and updates the portfolio.
     */
    public PortfolioTransaction sellAsset(Symbol symbol, BigDecimal quantity, Money price, String relatedOrderId) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        Objects.requireNonNull(quantity, "Quantity cannot be null");
        Objects.requireNonNull(price, "Price cannot be null");
        validateCurrency(price, "Price");
        validateSufficientPosition(symbol, quantity);

        Money totalProceeds = price.multiply(quantity);

        // Update position
        updatePosition(symbol, quantity, price, TransactionType.SELL);

        // Update cash balance
        updateCashBalance(totalProceeds);

        // Create transaction record
        PortfolioTransaction transaction = PortfolioTransaction.createSellTransaction(
                idGenerator.generateTransactionId(), id, symbol, quantity, price, relatedOrderId);
        addTransaction(transaction);

        return transaction;
    }

    // Query Operations

    /**
     * Gets a specific position by symbol.
     */
    public Optional<Position> getPosition(Symbol symbol) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        return Optional.ofNullable(positions.get(symbol));
    }

    /**
     * Calculates the total portfolio value including cash and positions.
     */
    public Money getTotalValue(Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        Money totalPositionValue = positions.values().stream()
                .map(position -> {
                    Money currentPrice = currentPrices.get(position.getSymbol());
                    return currentPrice != null ? position.getCurrentValue(currentPrice) :
                            Money.zero(baseCurrency);
                })
                .reduce(Money.zero(baseCurrency), Money::add);

        return cashBalance.add(totalPositionValue);
    }

    /**
     * Calculates the total profit/loss across all positions.
     */
    public Money getTotalProfitLoss(Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        return positions.values().stream()
                .map(position -> {
                    Money currentPrice = currentPrices.get(position.getSymbol());
                    return currentPrice != null ? position.getProfitLoss(currentPrice) :
                            Money.zero(baseCurrency);
                })
                .reduce(Money.zero(baseCurrency), Money::add);
    }

    /**
     * Calculates the total invested amount (cost basis of all positions).
     */
    public Money getTotalInvested() {
        return positions.values().stream()
                .map(Position::getCostBasis)
                .reduce(Money.zero(baseCurrency), Money::add);
    }

    /**
     * Checks if the portfolio has sufficient cash for a transaction.
     */
    public boolean canAfford(Money amount) {
        Objects.requireNonNull(amount, "Amount cannot be null");
        validateCurrency(amount, "Amount");
        return cashBalance.isGreaterThanOrEqual(amount);
    }

    /**
     * Gets transactions filtered by type.
     */
    public List<PortfolioTransaction> getTransactionsByType(TransactionType type) {
        Objects.requireNonNull(type, "Transaction type cannot be null");
        return transactions.stream()
                .filter(tx -> tx.getType() == type)
                .collect(Collectors.toList());
    }

    /**
     * Gets transactions for a specific symbol.
     */
    public List<PortfolioTransaction> getTransactionsForSymbol(Symbol symbol) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        return transactions.stream()
                .filter(tx -> symbol.equals(tx.getSymbol()))
                .collect(Collectors.toList());
    }

    // Private helper methods

    private void updateCashBalance(Money amount) {
        this.cashBalance = cashBalance.add(amount);
        this.updatedAt = LocalDateTime.now();
    }

    private void updatePosition(Symbol symbol, BigDecimal quantity, Money price, TransactionType type) {
        Position existingPosition = positions.get(symbol);

        if (type == TransactionType.BUY) {
            if (existingPosition == null) {
                // Create new position
                String positionId = idGenerator.generateTransactionId(); // Reuse for position IDs
                Position newPosition = new Position(positionId, id, symbol, quantity, price);
                positions.put(symbol, newPosition);
            } else {
                // Add to existing position
                existingPosition.addQuantity(quantity, price);
            }
        } else if (type == TransactionType.SELL) {
            if (existingPosition == null) {
                throw new IllegalStateException("Cannot sell asset with no position");
            }

            existingPosition.removeQuantity(quantity);

            // Remove position if empty
            if (existingPosition.isEmpty()) {
                positions.remove(symbol);
            }
        }
    }

    private void addTransaction(PortfolioTransaction transaction) {
        transactions.add(transaction);
        this.updatedAt = LocalDateTime.now();
    }

    private void validateSufficientCash(Money amount) {
        if (!canAfford(amount)) {
            throw new IllegalArgumentException(
                    String.format("Insufficient cash. Required: %s, Available: %s",
                            amount, cashBalance));
        }
    }

    private void validateSufficientPosition(Symbol symbol, BigDecimal quantity) {
        Position position = positions.get(symbol);
        if (position == null) {
            throw new IllegalArgumentException("No position exists for symbol: " + symbol.getCode());
        }

        if (!position.hasSufficientQuantity(quantity)) {
            throw new IllegalArgumentException(
                    String.format("Insufficient position. Required: %s, Available: %s",
                            quantity, position.getQuantity()));
        }
    }

    private void validateCurrency(Money money, String fieldName) {
        if (!money.getCurrency().equals(baseCurrency)) {
            throw new IllegalArgumentException(
                    String.format("%s currency %s does not match portfolio base currency %s",
                            fieldName, money.getCurrency(), baseCurrency));
        }
    }

    private void validatePortfolio() {
        if (name.trim().isEmpty()) {
            throw new IllegalArgumentException("Portfolio name cannot be empty");
        }

        if (cashBalance.isNegative()) {
            throw new IllegalArgumentException("Initial cash balance cannot be negative");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Portfolio portfolio = (Portfolio) obj;
        return Objects.equals(id, portfolio.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("Portfolio[%s: '%s' - %s cash, %d positions, %d transactions]",
                id, name, cashBalance, positions.size(), transactions.size());
    }
}