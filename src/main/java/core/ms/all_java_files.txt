=== ./order/domain/BuyOrder.java ===
package core.ms.order.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;

public class BuyOrder extends AbstractOrder implements IBuyOrder {

    public BuyOrder(String id, Symbol symbol, Money price, BigDecimal quantity) {
        super(id, symbol, price, quantity);
    }

    @Override
    public Money getCostBasis() {
        return getTotalValue();
    }
}
=== ./order/domain/ITransaction.java ===
package core.ms.order.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;

public interface ITransaction {
    String getId();
    Symbol getSymbol();
    IBuyOrder getBuyOrder();
    ISellOrder getSellOrder();
    Money getPrice();
    BigDecimal getQuantity();
    LocalDateTime getCreatedAt();
}=== ./order/domain/SellOrder.java ===
package core.ms.order.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;

public class SellOrder extends AbstractOrder implements ISellOrder {

    public SellOrder(String id, Symbol symbol, Money price, BigDecimal quantity) {
        super(id, symbol, price, quantity);
    }

    @Override
    public Money getProceeds() {
        return getTotalValue();
    }
}
=== ./order/domain/validator/ValidationErrorMessage.java ===
package core.ms.order.domain.validator;

public class ValidationErrorMessage {
    private String message;

    public ValidationErrorMessage(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}=== ./order/domain/validator/annotation/OrderNotFinal.java ===
package core.ms.order.domain.validator.annotation;


import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface OrderNotFinal {
    String message() default "Status order is final";
}
=== ./order/domain/validator/ValidateOrderState.java ===
package core.ms.order.domain.validator;

import core.ms.order.domain.IOrder;
import core.ms.order.domain.validator.annotation.OrderNotFinal;
import core.ms.order.domain.value.OrderStatusEnum;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;
import java.lang.annotation.Annotation;

public class ValidateOrderState {
    private Map<Class<? extends Annotation>, MethodChecker> annotationMap = new HashMap<>();

    public ValidateOrderState() {
        annotationMap.put(OrderNotFinal.class, this::checkOrderNotFinal);
    }

    /**
     * Validates all annotated fields in the given object
     * @param target The object to validate
     * @return List of validation errors (empty if valid)
     */
    public List<ValidationErrorMessage> validate(Object target) {
        List<ValidationErrorMessage> errors = new ArrayList<>();

        // Get all fields from the class hierarchy
        Class<?> clazz = target.getClass();
        while (clazz != null) {
            Field[] fields = clazz.getDeclaredFields();

            for (Field field : fields) {
                // Check each annotation on the field
                for (Annotation annotation : field.getAnnotations()) {
                    MethodChecker checker = annotationMap.get(annotation.annotationType());
                    if (checker != null) {
                        try {
                            // Make field accessible to read its value
                            field.setAccessible(true);
                            Object fieldValue = field.get(target);

                            // Find the corresponding getter method
                            Method getterMethod = findGetterMethod(clazz, field);
                            if (getterMethod != null) {
                                Optional<ValidationErrorMessage> error = checker.checkMethod(annotation, getterMethod, fieldValue);
                                error.ifPresent(errors::add);
                            } else {
                                // If no getter found, pass null method but use fieldValue as object
                                Optional<ValidationErrorMessage> error = checker.checkMethod(annotation, null, fieldValue);
                                error.ifPresent(errors::add);
                            }

                        } catch (IllegalAccessException e) {
                            errors.add(new ValidationErrorMessage("Cannot access field: " + field.getName()));
                        }
                    }
                }
            }
            clazz = clazz.getSuperclass();
        }

        return errors;
    }

    /**
     * Validates a single object and throws exception if invalid
     * @param target The object to validate
     * @throws IllegalArgumentException if validation fails
     */
    public void validateAndThrow(Object target) {
        List<ValidationErrorMessage> errors = validate(target);
        if (!errors.isEmpty()) {
            StringBuilder message = new StringBuilder("Validation failed: ");
            for (ValidationErrorMessage error : errors) {
                message.append(error.getMessage()).append("; ");
            }
            throw new IllegalArgumentException(message.toString());
        }
    }

    /**
     * Checks if an order is not in a final state
     */
    private Optional<ValidationErrorMessage> checkOrderNotFinal(Annotation annotation, Method method, Object o) {
        OrderNotFinal orderNotFinal = (OrderNotFinal) annotation;

        // The object 'o' is the field value (IOrder instance)
        if (o instanceof IOrder) {
            IOrder order = (IOrder) o;
            OrderStatusEnum status = order.getStatus().getStatus();

            // Check if order is in a final state
            if (status == OrderStatusEnum.FILLED || status == OrderStatusEnum.CANCELLED) {
                return Optional.of(new ValidationErrorMessage(orderNotFinal.message()));
            }
        }

        return Optional.empty();
    }

    /**
     * Finds the getter method for a given field
     */
    private Method findGetterMethod(Class<?> clazz, Field field) {
        String fieldName = field.getName();
        String getterName = "get" + capitalize(fieldName);

        try {
            return clazz.getMethod(getterName);
        } catch (NoSuchMethodException e) {
            // Try boolean getter pattern
            if (field.getType() == boolean.class || field.getType() == Boolean.class) {
                String booleanGetterName = "is" + capitalize(fieldName);
                try {
                    return clazz.getMethod(booleanGetterName);
                } catch (NoSuchMethodException ex) {
                    // No getter found
                    return null;
                }
            }
            return null;
        }
    }

    private String capitalize(String str) {
        if (str == null || str.isEmpty()) return str;
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}=== ./order/domain/validator/MethodChecker.java ===
package core.ms.order.domain.validator;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Optional;

public interface MethodChecker {
    Optional<ValidationErrorMessage> checkMethod(Annotation a, Method m, Object o);

}
=== ./order/domain/AbstractTransaction.java ===
package core.ms.order.domain;

import core.ms.order.domain.validator.ValidateOrderState;
import core.ms.order.domain.validator.annotation.OrderNotFinal;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Objects;

public abstract class AbstractTransaction implements ITransaction {
    protected final String id;
    protected final Symbol symbol;

    @OrderNotFinal(message = "Buy order must be active (not FILLED or CANCELLED)")
    protected final IBuyOrder buyOrder;

    @OrderNotFinal(message = "Sell order must be active (not FILLED or CANCELLED)")
    protected final ISellOrder sellOrder;

    protected final Money price;
    protected final BigDecimal quantity;
    protected final LocalDateTime createdAt;

    private static final ValidateOrderState validator = new ValidateOrderState();

    protected AbstractTransaction(String id, Symbol symbol, IBuyOrder buyOrder,
                                  ISellOrder sellOrder, Money price, BigDecimal quantity) {
        this.id = Objects.requireNonNull(id, "ID cannot be null");
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.buyOrder = Objects.requireNonNull(buyOrder, "Buy order cannot be null");
        this.sellOrder = Objects.requireNonNull(sellOrder, "Sell order cannot be null");
        this.price = Objects.requireNonNull(price, "Price cannot be null");
        this.quantity = Objects.requireNonNull(quantity, "Quantity cannot be null");
        this.createdAt = LocalDateTime.now();

        // Validate using annotations
        validator.validateAndThrow(this);

        // Additional validation
        validateTransaction();

        // Update orders after transaction
        updateOrdersAfterTransaction();
    }

    private void validateTransaction() {
        // Validate symbols match
        if (!buyOrder.getSymbol().equals(symbol) || !sellOrder.getSymbol().equals(symbol)) {
            throw new IllegalArgumentException("All orders must have the same symbol");
        }

        // ===== NEW: ORDER MATCHING VALIDATION (REPLACES STRICT PRICE MATCHING) =====
        validateOrderMatching();

        // Validate quantity constraints
        validateQuantityConstraints();

        // Validate price currency
        if (!price.getCurrency().equals(symbol.getQuoteCurrency())) {
            throw new IllegalArgumentException("Price currency must match symbol quote currency");
        }

        // Validate quantity is positive
        if (quantity.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
    }

    // ===== NEW: ORDER MATCHING LOGIC =====
    private void validateOrderMatching() {
        // Check if buy price >= sell price (can match)
        if (buyOrder.getPrice().isLessThan(sellOrder.getPrice())) {
            throw new IllegalArgumentException("Orders cannot match: buy price is less than sell price");
        }

        // Check if execution price is within valid range
        if (price.isLessThan(sellOrder.getPrice()) || price.isGreaterThan(buyOrder.getPrice())) {
            throw new IllegalArgumentException("Execution price must be between sell price and buy price");
        }
    }

    private void validateQuantityConstraints() {
        if (quantity.compareTo(buyOrder.getRemainingQuantity()) > 0) {
            throw new IllegalArgumentException("Transaction quantity cannot exceed buy order remaining quantity");
        }
        if (quantity.compareTo(sellOrder.getRemainingQuantity()) > 0) {
            throw new IllegalArgumentException("Transaction quantity cannot exceed sell order remaining quantity");
        }
    }

    private void updateOrdersAfterTransaction() {
        // Add this transaction to both orders and update their quantities
        buyOrder.addTransaction(this, quantity);
        sellOrder.addTransaction(this, quantity);
    }

    // ===== GETTERS =====
    @Override
    public String getId() { return id; }

    @Override
    public Symbol getSymbol() { return symbol; }

    @Override
    public IBuyOrder getBuyOrder() { return buyOrder; }

    @Override
    public ISellOrder getSellOrder() { return sellOrder; }

    @Override
    public Money getPrice() { return price; }

    @Override
    public BigDecimal getQuantity() { return quantity; }

    @Override
    public LocalDateTime getCreatedAt() { return createdAt; }

    public Money getTotalValue() {
        return price.multiply(quantity);
    }

    // ===== STATIC HELPER METHOD FOR OPTIMAL PRICING =====
    public static Money determineExecutionPrice(IBuyOrder buyOrder, ISellOrder sellOrder) {
        if (buyOrder.getPrice().isLessThan(sellOrder.getPrice())) {
            throw new IllegalArgumentException("Orders cannot match: buy price is less than sell price");
        }

        // Use mid-point pricing for fair execution
        Money buyPrice = buyOrder.getPrice();
        Money sellPrice = sellOrder.getPrice();

        // Calculate mid-point: (buy + sell) / 2
        Money sum = buyPrice.add(sellPrice);
        Money midPoint = sum.divide(new BigDecimal("2"));

        return midPoint;
    }

    // ===== OBJECT METHODS =====
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        AbstractTransaction that = (AbstractTransaction) obj;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("%s[%s, %s, %s @ %s]",
                getClass().getSimpleName(), id, symbol.getFullSymbol(),
                quantity, price);
    }
}=== ./order/domain/IBuyOrder.java ===
package core.ms.order.domain;

import core.ms.shared.domain.Money;

public interface IBuyOrder extends IOrder{
    Money getCostBasis();

}
=== ./order/domain/IOrder.java ===
package core.ms.order.domain;

import core.ms.order.domain.value.OrderStatus;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

public interface IOrder {
    String getId();
    Symbol getSymbol();
    Money getPrice();
    BigDecimal getQuantity();
    OrderStatus getStatus();
    LocalDateTime getCreatedAt();
    LocalDateTime getUpdatedAt();

    void cancel();
    void cancelPartial();
    void fillPartial();
    void complete();
    void updatePrice(Money price);
    Money getTotalValue();
    boolean isActive();

    // ===== NEW: QUANTITY TRACKING METHODS =====
    BigDecimal getExecutedQuantity();
    BigDecimal getRemainingQuantity();
    List<ITransaction> getTransactions();
    int getTransactionSequence(ITransaction transaction);

    // ===== NEW: INTERNAL METHOD FOR TRANSACTION UPDATES =====
    void addTransaction(ITransaction transaction, BigDecimal executedQuantity);
}=== ./order/domain/Transaction.java ===
package core.ms.order.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;

public class Transaction extends AbstractTransaction {

    public Transaction(
            String id,
            Symbol symbol,
            IBuyOrder buyOrder,
            ISellOrder sellOrder,
            Money price,
            BigDecimal quantity
    ) {
        super(id, symbol, buyOrder, sellOrder, price, quantity);
    }

    public static Transaction fromMatchingOrders(String id, IBuyOrder buyOrder,
                                                 ISellOrder sellOrder, Money executionPrice,
                                                 BigDecimal executionQuantity) {
        if (!buyOrder.getSymbol().equals(sellOrder.getSymbol())) {
            throw new IllegalArgumentException("Orders must have the same symbol");
        }

        return new Transaction(id, buyOrder.getSymbol(), buyOrder,
                sellOrder, executionPrice, executionQuantity);
    }
}=== ./order/domain/AbstractOrder.java ===
package core.ms.order.domain;

import core.ms.order.domain.value.OrderStatus;
import core.ms.order.domain.value.OrderStatusEnum;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public abstract class AbstractOrder implements IOrder {
    protected final String id;
    protected final Symbol symbol;
    protected Money price;
    protected final BigDecimal quantity;
    protected OrderStatus status;
    protected final LocalDateTime createdAt;
    protected LocalDateTime updatedAt;

    protected BigDecimal executedQuantity;
    protected final List<ITransaction> transactions;

    protected AbstractOrder(String id, Symbol symbol, Money price, BigDecimal quantity) {
        this.id = Objects.requireNonNull(id, "ID cannot be null");
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.price = Objects.requireNonNull(price, "Price cannot be null");
        this.quantity = Objects.requireNonNull(quantity, "Quantity cannot be null");
        this.status = new OrderStatus();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();

        this.executedQuantity = BigDecimal.ZERO;
        this.transactions = new ArrayList<>();

        validatePriceCurrency(price);
        validateQuantity(quantity);
    }

    // ===== GETTERS =====
    @Override
    public String getId() { return id; }

    @Override
    public Symbol getSymbol() { return symbol; }

    @Override
    public Money getPrice() { return price; }

    @Override
    public BigDecimal getQuantity() { return quantity; }

    @Override
    public OrderStatus getStatus() { return status; }

    @Override
    public LocalDateTime getCreatedAt() { return createdAt; }

    @Override
    public LocalDateTime getUpdatedAt() { return updatedAt; }

    // ===== QUANTITY TRACKING GETTERS =====
    @Override
    public BigDecimal getExecutedQuantity() {
        return executedQuantity;
    }


    @Override
    public BigDecimal getRemainingQuantity() {
        BigDecimal remaining = quantity.subtract(executedQuantity);

        if (remaining.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO;
        }
        return remaining;
    }

    @Override
    public List<ITransaction> getTransactions() {
        return new ArrayList<>(transactions);
    }

    @Override
    public int getTransactionSequence(ITransaction transaction) {
        int index = transactions.indexOf(transaction);
        return index >= 0 ? index + 1 : -1;
    }

    // ===== TRANSACTION MANAGEMENT =====
    @Override
    public void addTransaction(ITransaction transaction, BigDecimal executedAmount) {
        Objects.requireNonNull(transaction, "Transaction cannot be null");
        Objects.requireNonNull(executedAmount, "Executed amount cannot be null");

        if (executedAmount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Executed amount must be positive");
        }

        if (executedAmount.compareTo(getRemainingQuantity()) > 0) {
            throw new IllegalArgumentException("Executed amount exceeds remaining quantity");
        }

        transactions.add(transaction);

        executedQuantity = executedQuantity.add(executedAmount);

        // If the result is zero, use BigDecimal.ZERO
        if (executedQuantity.compareTo(BigDecimal.ZERO) == 0) {
            executedQuantity = BigDecimal.ZERO;
        }

        updatedAt = LocalDateTime.now();
        updateStatusAfterExecution();
    }

    private void updateStatusAfterExecution() {
        BigDecimal remaining = getRemainingQuantity();

        if (remaining.compareTo(BigDecimal.ZERO) == 0) {
            if (status.getStatus() != OrderStatusEnum.FILLED) {
                status.completeOrder();
            }
        } else {
            if (status.getStatus() == OrderStatusEnum.PENDING) {
                status.fillPartialOrder();
            }
        }
    }

    // ===== BUSINESS METHODS =====
    @Override
    public void cancel() {
        status.cancelOrder();
        this.updatedAt = LocalDateTime.now();
    }

    @Override
    public void cancelPartial() {
        status.cancelPartialOrder();
        this.updatedAt = LocalDateTime.now();
    }

    @Override
    public void fillPartial() {
        status.fillPartialOrder();
        this.updatedAt = LocalDateTime.now();
    }

    @Override
    public void complete() {
        status.completeOrder();
        this.updatedAt = LocalDateTime.now();
    }

    @Override
    public void updatePrice(Money price) {
        Objects.requireNonNull(price, "Price cannot be null");
        validatePriceCurrency(price);

        if (status.isTerminal()) {
            throw new IllegalStateException("Cannot update price of terminal order");
        }

        this.price = price;
        this.updatedAt = LocalDateTime.now();
    }

    @Override
    public Money getTotalValue() {
        return price.multiply(quantity);
    }

    @Override
    public boolean isActive() {
        return !status.isTerminal();
    }

    public String getSymbolCode() {
        return symbol.getCode();
    }

    // ===== PROTECTED METHODS =====
    protected void validatePriceCurrency(Money price) {
        if (!price.getCurrency().equals(symbol.getQuoteCurrency())) {
            throw new IllegalArgumentException(
                    String.format("Price currency %s does not match symbol quote currency %s",
                            price.getCurrency(), symbol.getQuoteCurrency()));
        }
    }

    private void validateQuantity(BigDecimal quantity) {
        if (quantity.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
    }

    // ===== OBJECT METHODS =====
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        AbstractOrder that = (AbstractOrder) obj;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("%s[%s, %s, %s @ %s, %s, executed: %s, remaining: %s]",
                getClass().getSimpleName(), id, symbol.getFullSymbol(),
                quantity, price, status.getStatus(), executedQuantity, getRemainingQuantity());
    }
}
=== ./order/domain/value/PendingOrder.java ===
package core.ms.order.domain.value;

public class PendingOrder extends AbstractOrderState {

    public PendingOrder(StateTransition transition) {
        super(transition);
    }

    @Override
    public void cancelPartialOrder() {
        // Stay in PENDING state, just reduce quantity
        // No state transition needed
    }
}
=== ./order/domain/value/PartialOrder.java ===
package core.ms.order.domain.value;

public class PartialOrder extends AbstractOrderState {

    public PartialOrder(StateTransition transition) {
        super(transition);
    }

    @Override
    public void cancelPartialOrder() {
        // Stay in PARTIAL state, just reduce remaining quantity
        // No state transition needed
    }
}=== ./order/domain/value/StateTransition.java ===
package core.ms.order.domain.value;

public interface StateTransition {
    void transitionTo(IOrderState newState, OrderStatusEnum status);
}=== ./order/domain/value/IOrderState.java ===
package core.ms.order.domain.value;

public interface IOrderState {
    void cancelOrder();
    void cancelPartialOrder();
    void fillPartialOrder();
    void completeOrder();
}=== ./order/domain/value/FilledOrder.java ===
package core.ms.order.domain.value;

public class FilledOrder extends AbstractOrderState {

    public FilledOrder(StateTransition transition) {
        super(transition);
    }

    @Override
    public void cancelOrder() {
        throw new IllegalStateException("Cannot cancel a filled order");
    }

    @Override
    public void cancelPartialOrder() {
        throw new IllegalStateException("Cannot cancel a filled order");
    }

    @Override
    public void fillPartialOrder() {
        throw new IllegalStateException("Order is already filled");
    }

    @Override
    public void completeOrder() {
        throw new IllegalStateException("Order is already filled");
    }
}
=== ./order/domain/value/OrderStatus.java ===
package core.ms.order.domain.value;

import lombok.Getter;

public class OrderStatus implements IOrderState, StateTransition {
    private IOrderState orderState;
    // ===== GETTERS =====
    @Getter
    private OrderStatusEnum status;

    public OrderStatus() {
        orderState = new PendingOrder(this);
        status = OrderStatusEnum.PENDING;
    }

    // ===== STATE TRANSITION CALLBACK =====
    @Override
    public void transitionTo(IOrderState newState, OrderStatusEnum status) {
        this.orderState = newState;
        this.status = status;
    }

    // ===== DELEGATION TO CURRENT STATE =====
    @Override
    public void cancelOrder() {
        this.orderState.cancelOrder();
    }

    @Override
    public void cancelPartialOrder() {
        this.orderState.cancelPartialOrder();
    }

    @Override
    public void fillPartialOrder() {
        this.orderState.fillPartialOrder();
    }

    @Override
    public void completeOrder() {
        this.orderState.completeOrder();
    }

    public boolean isTerminal() {
        return status == OrderStatusEnum.FILLED || status == OrderStatusEnum.CANCELLED;
    }

    @Override
    public String toString() {
        return status.name();
    }
}=== ./order/domain/value/OrderStatusEnum.java ===
package core.ms.order.domain.value;

public enum OrderStatusEnum {
    PENDING,
    FILLED,
    PARTIAL,
    CANCELLED
}=== ./order/domain/value/AbstractOrderState.java ===
package core.ms.order.domain.value;

public abstract class AbstractOrderState implements IOrderState {
    protected StateTransition transition;

    public AbstractOrderState(StateTransition transition) {
        this.transition = transition;
    }

    @Override
    public void cancelOrder() {
        transition.transitionTo(new CancelledOrder(transition), OrderStatusEnum.CANCELLED);
    }

    @Override
    public void fillPartialOrder() {
        transition.transitionTo(new PartialOrder(transition), OrderStatusEnum.PARTIAL);
    }

    @Override
    public void completeOrder() {
        transition.transitionTo(new FilledOrder(transition), OrderStatusEnum.FILLED);
    }

    // Default implementation for cancelPartialOrder - states override if needed
    @Override
    public void cancelPartialOrder() {
        // Default: stay in same state (no transition)
        // Override in specific states where it makes sense
    }
}=== ./order/domain/value/CancelledOrder.java ===
package core.ms.order.domain.value;

public class CancelledOrder extends AbstractOrderState {

    public CancelledOrder(StateTransition transition) {
        super(transition);
    }

    @Override
    public void cancelOrder() {
        throw new IllegalStateException("Order is already cancelled");
    }

    @Override
    public void cancelPartialOrder() {
        throw new IllegalStateException("Order is already cancelled");
    }

    @Override
    public void fillPartialOrder() {
        throw new IllegalStateException("Cannot fill a cancelled order");
    }

    @Override
    public void completeOrder() {
        throw new IllegalStateException("Cannot complete a cancelled order");
    }
}=== ./order/domain/ISellOrder.java ===
package core.ms.order.domain;

import core.ms.shared.domain.Money;

public interface ISellOrder extends IOrder {
    Money getProceeds();
}=== ./portfolio/domain/PortfolioTransaction.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.TransactionType;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Objects;

public class PortfolioTransaction {
    private final String id;
    private final String portfolioId;
    private final TransactionType type;
    private final Symbol symbol; // Null for cash-only transactions
    private final BigDecimal quantity; // Zero for cash-only transactions
    private final Money price; // Price per unit for asset transactions
    private final Money totalAmount; // Total transaction amount
    private final LocalDateTime timestamp;
    private final String relatedOrderId; // Null if not related to an order

    public PortfolioTransaction(String id, String portfolioId, TransactionType type,
                                Symbol symbol, BigDecimal quantity, Money price,
                                Money totalAmount, String relatedOrderId) {
        this.id = Objects.requireNonNull(id, "Transaction ID cannot be null");
        this.portfolioId = Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        this.type = Objects.requireNonNull(type, "Transaction type cannot be null");
        this.symbol = symbol; // Can be null for cash transactions
        this.quantity = quantity != null ? quantity : BigDecimal.ZERO;
        this.price = price; // Can be null for cash transactions
        this.totalAmount = Objects.requireNonNull(totalAmount, "Total amount cannot be null");
        this.timestamp = LocalDateTime.now();
        this.relatedOrderId = relatedOrderId; // Can be null

        validateTransaction();
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getPortfolioId() {
        return portfolioId;
    }

    public TransactionType getType() {
        return type;
    }

    public Symbol getSymbol() {
        return symbol;
    }

    public BigDecimal getQuantity() {
        return quantity;
    }

    public Money getPrice() {
        return price;
    }

    public Money getTotalAmount() {
        return totalAmount;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public String getRelatedOrderId() {
        return relatedOrderId;
    }

    // Business methods
    public boolean isCashTransaction() {
        return type.isCashTransaction();
    }

    public boolean isAssetTransaction() {
        return type.isAssetTransaction();
    }

    public boolean affectsCashBalance() {
        return type.affectsCash();
    }

    public boolean affectsPosition() {
        return type.affectsPosition();
    }

    public String getSymbolCode() {
        return symbol != null ? symbol.getCode() : null;
    }

    // Static factory methods for creating specific transaction types
    public static PortfolioTransaction createBuyTransaction(String id, String portfolioId,
                                                            Symbol symbol, BigDecimal quantity,
                                                            Money price, String relatedOrderId) {
        Money totalAmount = price.multiply(quantity);
        return new PortfolioTransaction(id, portfolioId, TransactionType.BUY,
                symbol, quantity, price, totalAmount, relatedOrderId);
    }

    public static PortfolioTransaction createSellTransaction(String id, String portfolioId,
                                                             Symbol symbol, BigDecimal quantity,
                                                             Money price, String relatedOrderId) {
        Money totalAmount = price.multiply(quantity);
        return new PortfolioTransaction(id, portfolioId, TransactionType.SELL,
                symbol, quantity, price, totalAmount, relatedOrderId);
    }

    public static PortfolioTransaction createDepositTransaction(String id, String portfolioId,
                                                                Money amount) {
        return new PortfolioTransaction(id, portfolioId, TransactionType.DEPOSIT,
                null, BigDecimal.ZERO, null, amount, null);
    }

    public static PortfolioTransaction createWithdrawalTransaction(String id, String portfolioId,
                                                                   Money amount) {
        return new PortfolioTransaction(id, portfolioId, TransactionType.WITHDRAWAL,
                null, BigDecimal.ZERO, null, amount, null);
    }

    private void validateTransaction() {
        if (type.isAssetTransaction()) {
            if (symbol == null) {
                throw new IllegalArgumentException("Symbol is required for asset transactions");
            }
            if (price == null) {
                throw new IllegalArgumentException("Price is required for asset transactions");
            }
            if (quantity.compareTo(BigDecimal.ZERO) <= 0) {
                throw new IllegalArgumentException("Quantity must be positive for asset transactions");
            }
        }

        if (type.isCashTransaction()) {
            if (symbol != null) {
                throw new IllegalArgumentException("Symbol should be null for cash transactions");
            }
            if (price != null) {
                throw new IllegalArgumentException("Price should be null for cash transactions");
            }
        }

        if (totalAmount.isNegative()) {
            throw new IllegalArgumentException("Total amount cannot be negative");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PortfolioTransaction that = (PortfolioTransaction) obj;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        if (type.isAssetTransaction()) {
            return String.format("PortfolioTransaction[%s: %s %s %s @ %s = %s]",
                    id, type, quantity, symbol.getCode(), price, totalAmount);
        } else {
            return String.format("PortfolioTransaction[%s: %s %s]",
                    id, type, totalAmount);
        }
    }
}=== ./portfolio/domain/PortfolioManager.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.PortfolioSummary;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import core.ms.utils.IdGenerator;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class PortfolioManager {
    private final Map<String, Portfolio> portfolios;
    private final Map<String, Set<String>> userPortfolios; // userId -> Set of portfolioIds
    private final IdGenerator idGenerator;

    public PortfolioManager() {
        this.portfolios = new ConcurrentHashMap<>();
        this.userPortfolios = new ConcurrentHashMap<>();
        this.idGenerator = new IdGenerator();
    }

    /**
     * Creates a new portfolio for a user.
     */
    public Portfolio createPortfolio(String name, String userId, Currency baseCurrency) {
        Objects.requireNonNull(name, "Portfolio name cannot be null");
        Objects.requireNonNull(userId, "User ID cannot be null");
        Objects.requireNonNull(baseCurrency, "Base currency cannot be null");

        if (name.trim().isEmpty()) {
            throw new IllegalArgumentException("Portfolio name cannot be empty");
        }

        String portfolioId = idGenerator.generateTransactionId(); // Reuse for portfolio IDs
        Money initialCash = Money.zero(baseCurrency);

        Portfolio portfolio = new Portfolio(portfolioId, name.trim(), userId, initialCash);

        portfolios.put(portfolioId, portfolio);
        userPortfolios.computeIfAbsent(userId, k -> ConcurrentHashMap.newKeySet()).add(portfolioId);

        return portfolio;
    }

    /**
     * Creates a new portfolio with initial cash deposit.
     */
    public Portfolio createPortfolioWithInitialDeposit(String name, String userId, Money initialCash) {
        Objects.requireNonNull(initialCash, "Initial cash cannot be null");

        if (initialCash.isNegative()) {
            throw new IllegalArgumentException("Initial cash cannot be negative");
        }

        Portfolio portfolio = createPortfolio(name, userId, initialCash.getCurrency());

        if (initialCash.isPositive()) {
            portfolio.depositCash(initialCash);
        }

        return portfolio;
    }

    /**
     * Retrieves a portfolio by ID.
     */
    public Optional<Portfolio> getPortfolio(String portfolioId) {
        Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        return Optional.ofNullable(portfolios.get(portfolioId));
    }

    /**
     * Retrieves all portfolios for a specific user.
     */
    public List<Portfolio> getUserPortfolios(String userId) {
        Objects.requireNonNull(userId, "User ID cannot be null");

        Set<String> portfolioIds = userPortfolios.getOrDefault(userId, Collections.emptySet());

        return portfolioIds.stream()
                .map(portfolios::get)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    /**
     * Deletes a portfolio (only if it belongs to the specified user and has no positions).
     */
    public boolean deletePortfolio(String portfolioId, String userId) {
        Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        Objects.requireNonNull(userId, "User ID cannot be null");

        Portfolio portfolio = portfolios.get(portfolioId);
        if (portfolio == null) {
            return false;
        }

        // Verify ownership
        if (!portfolio.getUserId().equals(userId)) {
            throw new IllegalArgumentException("Portfolio does not belong to the specified user");
        }

        // Check if portfolio can be deleted (no positions)
        if (!portfolio.getPositions().isEmpty()) {
            throw new IllegalStateException("Cannot delete portfolio with active positions");
        }

        // Remove from both maps
        portfolios.remove(portfolioId);
        Set<String> userPortfolioSet = userPortfolios.get(userId);
        if (userPortfolioSet != null) {
            userPortfolioSet.remove(portfolioId);
            if (userPortfolioSet.isEmpty()) {
                userPortfolios.remove(userId);
            }
        }

        return true;
    }

    /**
     * Calculates the total value of a portfolio using current market prices.
     */
    public Money calculateTotalValue(Portfolio portfolio, Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(portfolio, "Portfolio cannot be null");
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        return portfolio.getTotalValue(currentPrices);
    }

    /**
     * Generates a comprehensive summary of a portfolio.
     */
    public PortfolioSummary generatePortfolioSummary(Portfolio portfolio, Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(portfolio, "Portfolio cannot be null");
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        Money totalValue = portfolio.getTotalValue(currentPrices);
        Money cashBalance = portfolio.getCashBalance();
        Money totalInvested = portfolio.getTotalInvested();
        Money totalProfitLoss = portfolio.getTotalProfitLoss(currentPrices);

        BigDecimal profitLossPercentage = calculateProfitLossPercentage(totalInvested, totalProfitLoss);

        int positionCount = portfolio.getPositions().size();
        int transactionCount = portfolio.getTransactions().size();

        return new PortfolioSummary(
                portfolio.getId(),
                portfolio.getName(),
                totalValue,
                cashBalance,
                totalInvested,
                totalProfitLoss,
                profitLossPercentage,
                positionCount,
                transactionCount
        );
    }

    /**
     * Gets aggregated statistics across all portfolios for a user.
     */
    public Map<String, Object> getUserPortfolioStatistics(String userId, Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(userId, "User ID cannot be null");
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        List<Portfolio> userPortfolioList = getUserPortfolios(userId);

        if (userPortfolioList.isEmpty()) {
            return Collections.emptyMap();
        }

        Currency baseCurrency = userPortfolioList.get(0).getBaseCurrency(); // Assume same currency

        Money totalValue = Money.zero(baseCurrency);
        Money totalCash = Money.zero(baseCurrency);
        Money totalInvested = Money.zero(baseCurrency);
        Money totalProfitLoss = Money.zero(baseCurrency);
        int totalPositions = 0;
        int totalTransactions = 0;

        for (Portfolio portfolio : userPortfolioList) {
            totalValue = totalValue.add(portfolio.getTotalValue(currentPrices));
            totalCash = totalCash.add(portfolio.getCashBalance());
            totalInvested = totalInvested.add(portfolio.getTotalInvested());
            totalProfitLoss = totalProfitLoss.add(portfolio.getTotalProfitLoss(currentPrices));
            totalPositions += portfolio.getPositions().size();
            totalTransactions += portfolio.getTransactions().size();
        }

        Map<String, Object> statistics = new HashMap<>();
        statistics.put("userId", userId);
        statistics.put("portfolioCount", userPortfolioList.size());
        statistics.put("totalValue", totalValue);
        statistics.put("totalCash", totalCash);
        statistics.put("totalInvested", totalInvested);
        statistics.put("totalProfitLoss", totalProfitLoss);
        statistics.put("profitLossPercentage", calculateProfitLossPercentage(totalInvested, totalProfitLoss));
        statistics.put("totalPositions", totalPositions);
        statistics.put("totalTransactions", totalTransactions);

        return statistics;
    }

    /**
     * Finds portfolios that contain a specific symbol.
     */
    public List<Portfolio> getPortfoliosWithSymbol(String userId, Symbol symbol) {
        Objects.requireNonNull(userId, "User ID cannot be null");
        Objects.requireNonNull(symbol, "Symbol cannot be null");

        return getUserPortfolios(userId).stream()
                .filter(portfolio -> portfolio.getPosition(symbol).isPresent())
                .collect(Collectors.toList());
    }

    /**
     * Gets all portfolios (admin function).
     */
    public Collection<Portfolio> getAllPortfolios() {
        return new ArrayList<>(portfolios.values());
    }

    /**
     * Gets portfolio count statistics.
     */
    public Map<String, Integer> getPortfolioStatistics() {
        Map<String, Integer> stats = new HashMap<>();
        stats.put("totalPortfolios", portfolios.size());
        stats.put("totalUsers", userPortfolios.size());

        int totalPositions = portfolios.values().stream()
                .mapToInt(p -> p.getPositions().size())
                .sum();
        stats.put("totalPositions", totalPositions);

        int totalTransactions = portfolios.values().stream()
                .mapToInt(p -> p.getTransactions().size())
                .sum();
        stats.put("totalTransactions", totalTransactions);

        return stats;
    }

    private BigDecimal calculateProfitLossPercentage(Money totalInvested, Money totalProfitLoss) {
        if (totalInvested.isZero()) {
            return BigDecimal.ZERO;
        }

        return totalProfitLoss.getAmount()
                .divide(totalInvested.getAmount(), 4, RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
    }
}
=== ./portfolio/domain/value/TransactionType.java ===
package core.ms.portfolio.domain.value;

public enum TransactionType {
    BUY("Asset Purchase"),
    SELL("Asset Sale"),
    DEPOSIT("Cash Deposit"),
    WITHDRAWAL("Cash Withdrawal");

    private final String description;

    TransactionType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Returns true if this transaction type affects the cash balance.
     */
    public boolean affectsCash() {
        return switch (this) {
            case BUY, WITHDRAWAL -> true;  // Decreases cash
            case SELL, DEPOSIT -> true;    // Increases cash
        };
    }

    /**
     * Returns true if this transaction type affects asset positions.
     */
    public boolean affectsPosition() {
        return switch (this) {
            case BUY -> true;     // Increases position
            case SELL -> true;    // Decreases position
            case DEPOSIT, WITHDRAWAL -> false; // Cash only
        };
    }

    /**
     * Returns true if this is an asset-related transaction (buy/sell).
     */
    public boolean isAssetTransaction() {
        return this == BUY || this == SELL;
    }

    /**
     * Returns true if this is a cash-only transaction (deposit/withdrawal).
     */
    public boolean isCashTransaction() {
        return this == DEPOSIT || this == WITHDRAWAL;
    }

    /**
     * Returns true if this transaction increases cash balance.
     */
    public boolean increasesCash() {
        return this == SELL || this == DEPOSIT;
    }

    /**
     * Returns true if this transaction decreases cash balance.
     */
    public boolean decreasesCash() {
        return this == BUY || this == WITHDRAWAL;
    }

    @Override
    public String toString() {
        return description;
    }
}=== ./portfolio/domain/value/PortfolioSummary.java ===
package core.ms.portfolio.domain.value;

import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Objects;

public class PortfolioSummary {
    private final String portfolioId;
    private final String portfolioName;
    private final Money totalValue;
    private final Money cashBalance;
    private final Money totalInvested;
    private final Money totalProfitLoss;
    private final BigDecimal profitLossPercentage;
    private final int positionCount;
    private final int transactionCount;
    private final LocalDateTime createdAt;

    public PortfolioSummary(String portfolioId, String portfolioName, Money totalValue,
                            Money cashBalance, Money totalInvested, Money totalProfitLoss,
                            BigDecimal profitLossPercentage, int positionCount, int transactionCount) {
        this.portfolioId = Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        this.portfolioName = Objects.requireNonNull(portfolioName, "Portfolio name cannot be null");
        this.totalValue = Objects.requireNonNull(totalValue, "Total value cannot be null");
        this.cashBalance = Objects.requireNonNull(cashBalance, "Cash balance cannot be null");
        this.totalInvested = Objects.requireNonNull(totalInvested, "Total invested cannot be null");
        this.totalProfitLoss = Objects.requireNonNull(totalProfitLoss, "Total profit/loss cannot be null");
        this.profitLossPercentage = Objects.requireNonNull(profitLossPercentage, "Profit/loss percentage cannot be null");
        this.positionCount = positionCount;
        this.transactionCount = transactionCount;
        this.createdAt = LocalDateTime.now();

        validateSummary();
    }

    // Getters
    public String getPortfolioId() {
        return portfolioId;
    }

    public String getPortfolioName() {
        return portfolioName;
    }

    public Money getTotalValue() {
        return totalValue;
    }

    public Money getCashBalance() {
        return cashBalance;
    }

    public Money getTotalInvested() {
        return totalInvested;
    }

    public Money getTotalProfitLoss() {
        return totalProfitLoss;
    }

    public BigDecimal getProfitLossPercentage() {
        return profitLossPercentage;
    }

    public int getPositionCount() {
        return positionCount;
    }

    public int getTransactionCount() {
        return transactionCount;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    // Business methods
    public boolean isPositive() {
        return totalProfitLoss.isPositive();
    }

    public boolean isNegative() {
        return totalProfitLoss.isNegative();
    }

    public boolean isBreakEven() {
        return totalProfitLoss.isZero();
    }

    public Money getPortfolioValue() {
        return totalInvested.add(cashBalance);
    }

    public BigDecimal getCashPercentage() {
        if (totalValue.isZero()) {
            return BigDecimal.ZERO;
        }

        return cashBalance.getAmount()
                .divide(totalValue.getAmount(), 4, java.math.RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
    }

    public BigDecimal getInvestedPercentage() {
        if (totalValue.isZero()) {
            return BigDecimal.ZERO;
        }

        return totalInvested.getAmount()
                .divide(totalValue.getAmount(), 4, java.math.RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
    }

    public String getPerformanceStatus() {
        if (isPositive()) {
            return "PROFIT";
        } else if (isNegative()) {
            return "LOSS";
        } else {
            return "BREAK_EVEN";
        }
    }

    private void validateSummary() {
        if (positionCount < 0) {
            throw new IllegalArgumentException("Position count cannot be negative");
        }

        if (transactionCount < 0) {
            throw new IllegalArgumentException("Transaction count cannot be negative");
        }

        if (totalValue.isNegative()) {
            throw new IllegalArgumentException("Total value cannot be negative");
        }

        if (cashBalance.isNegative()) {
            throw new IllegalArgumentException("Cash balance cannot be negative");
        }

        if (totalInvested.isNegative()) {
            throw new IllegalArgumentException("Total invested cannot be negative");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PortfolioSummary that = (PortfolioSummary) obj;
        return Objects.equals(portfolioId, that.portfolioId) &&
                Objects.equals(createdAt, that.createdAt);
    }

    @Override
    public int hashCode() {
        return Objects.hash(portfolioId, createdAt);
    }

    @Override
    public String toString() {
        return String.format("PortfolioSummary[%s: '%s' - Value: %s, P&L: %s (%.2f%%), %d positions]",
                portfolioId, portfolioName, totalValue, totalProfitLoss,
                profitLossPercentage, positionCount);
    }
}=== ./portfolio/domain/Position.java ===
package core.ms.portfolio.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.Objects;

public class Position {
    private final String id;
    private final String portfolioId;
    private final Symbol symbol;
    private BigDecimal quantity;
    private Money averagePrice;
    private final LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public Position(String id, String portfolioId, Symbol symbol, BigDecimal quantity, Money averagePrice) {
        this.id = Objects.requireNonNull(id, "Position ID cannot be null");
        this.portfolioId = Objects.requireNonNull(portfolioId, "Portfolio ID cannot be null");
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.quantity = Objects.requireNonNull(quantity, "Quantity cannot be null");
        this.averagePrice = Objects.requireNonNull(averagePrice, "Average price cannot be null");
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();

        validatePosition();
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getPortfolioId() {
        return portfolioId;
    }

    public Symbol getSymbol() {
        return symbol;
    }

    public BigDecimal getQuantity() {
        return quantity;
    }

    public Money getAveragePrice() {
        return averagePrice;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    // Business methods
    public String getSymbolCode() {
        return symbol.getCode();
    }

    /**
     * Calculates the current market value of this position.
     */
    public Money getCurrentValue(Money currentPrice) {
        Objects.requireNonNull(currentPrice, "Current price cannot be null");
        validateCurrency(currentPrice, "Current price");
        return currentPrice.multiply(quantity);
    }

    /**
     * Calculates the total cost basis of this position.
     */
    public Money getCostBasis() {
        return averagePrice.multiply(quantity);
    }

    /**
     * Calculates the profit or loss based on current market price.
     * Positive value indicates profit, negative indicates loss.
     */
    public Money getProfitLoss(Money currentPrice) {
        Objects.requireNonNull(currentPrice, "Current price cannot be null");
        validateCurrency(currentPrice, "Current price");

        Money currentValue = getCurrentValue(currentPrice);
        Money costBasis = getCostBasis();
        return currentValue.subtract(costBasis);
    }

    /**
     * Calculates the profit or loss percentage based on current market price.
     */
    public BigDecimal getProfitLossPercentage(Money currentPrice) {
        Objects.requireNonNull(currentPrice, "Current price cannot be null");
        validateCurrency(currentPrice, "Current price");

        Money profitLoss = getProfitLoss(currentPrice);
        Money costBasis = getCostBasis();

        if (costBasis.isZero()) {
            return BigDecimal.ZERO;
        }

        // Calculate: (profitLoss / costBasis) * 100
        BigDecimal profitLossAmount = profitLoss.getAmount();
        BigDecimal costBasisAmount = costBasis.getAmount();

        return profitLossAmount
                .divide(costBasisAmount, 4, RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
    }

    /**
     * Adds quantity to this position and updates the average price.
     */
    public void addQuantity(BigDecimal additionalQuantity, Money price) {
        Objects.requireNonNull(additionalQuantity, "Additional quantity cannot be null");
        Objects.requireNonNull(price, "Price cannot be null");
        validateCurrency(price, "Price");

        if (additionalQuantity.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Additional quantity must be positive");
        }

        // Calculate new average price using weighted average
        Money newAveragePrice = calculateNewAveragePrice(additionalQuantity, price);

        this.quantity = this.quantity.add(additionalQuantity);
        this.averagePrice = newAveragePrice;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Removes quantity from this position. Does not affect average price.
     */
    public void removeQuantity(BigDecimal quantityToRemove) {
        Objects.requireNonNull(quantityToRemove, "Quantity to remove cannot be null");
        validateQuantityRemoval(quantityToRemove);

        this.quantity = this.quantity.subtract(quantityToRemove);
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Returns true if this position has no quantity (empty position).
     */
    public boolean isEmpty() {
        return quantity.compareTo(BigDecimal.ZERO) == 0;
    }

    /**
     * Returns true if this position has sufficient quantity for removal.
     */
    public boolean hasSufficientQuantity(BigDecimal quantityToCheck) {
        Objects.requireNonNull(quantityToCheck, "Quantity to check cannot be null");
        return quantity.compareTo(quantityToCheck) >= 0;
    }

    private Money calculateNewAveragePrice(BigDecimal additionalQuantity, Money price) {
        // Weighted average: ((existing_qty * avg_price) + (new_qty * new_price)) / (existing_qty + new_qty)
        Money existingCost = averagePrice.multiply(quantity);
        Money additionalCost = price.multiply(additionalQuantity);
        Money totalCost = existingCost.add(additionalCost);
        BigDecimal totalQuantity = quantity.add(additionalQuantity);

        return totalCost.divide(totalQuantity);
    }

    private void validateQuantityRemoval(BigDecimal quantityToRemove) {
        if (quantityToRemove.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Quantity to remove must be positive");
        }

        if (quantityToRemove.compareTo(quantity) > 0) {
            throw new IllegalArgumentException(
                    String.format("Cannot remove %s units. Only %s units available",
                            quantityToRemove, quantity));
        }
    }

    private void validateCurrency(Money money, String fieldName) {
        if (!money.getCurrency().equals(averagePrice.getCurrency())) {
            throw new IllegalArgumentException(
                    String.format("%s currency %s does not match position currency %s",
                            fieldName, money.getCurrency(), averagePrice.getCurrency()));
        }
    }

    private void validatePosition() {
        if (quantity.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Quantity cannot be negative");
        }

        if (averagePrice.isNegative()) {
            throw new IllegalArgumentException("Average price cannot be negative");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Position position = (Position) obj;
        return Objects.equals(id, position.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("Position[%s: %s %s @ %s avg, value: %s]",
                id, quantity, symbol.getCode(), averagePrice, getCostBasis());
    }
}=== ./portfolio/domain/Portfolio.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.TransactionType;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import core.ms.utils.IdGenerator;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

public class Portfolio {
    private final String id;
    private final String name;
    private final String userId;
    private Money cashBalance;
    private final Currency baseCurrency;
    private final LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private final Map<Symbol, Position> positions;
    private final List<PortfolioTransaction> transactions;
    private final IdGenerator idGenerator;

    public Portfolio(String id, String name, String userId, Money initialCashBalance) {
        this.id = Objects.requireNonNull(id, "Portfolio ID cannot be null");
        this.name = Objects.requireNonNull(name, "Portfolio name cannot be null");
        this.userId = Objects.requireNonNull(userId, "User ID cannot be null");
        this.cashBalance = Objects.requireNonNull(initialCashBalance, "Initial cash balance cannot be null");
        this.baseCurrency = initialCashBalance.getCurrency();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.positions = new HashMap<>();
        this.transactions = new ArrayList<>();
        this.idGenerator = new IdGenerator();

        validatePortfolio();
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getUserId() {
        return userId;
    }

    public Money getCashBalance() {
        return cashBalance;
    }

    public Currency getBaseCurrency() {
        return baseCurrency;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public Collection<Position> getPositions() {
        return new ArrayList<>(positions.values());
    }

    public List<PortfolioTransaction> getTransactions() {
        return new ArrayList<>(transactions);
    }

    // Business Operations

    /**
     * Deposits cash into the portfolio.
     */
    public PortfolioTransaction depositCash(Money amount) {
        Objects.requireNonNull(amount, "Amount cannot be null");
        validateCurrency(amount, "Deposit amount");

        if (amount.isNegative() || amount.isZero()) {
            throw new IllegalArgumentException("Deposit amount must be positive");
        }

        updateCashBalance(amount);

        PortfolioTransaction transaction = PortfolioTransaction.createDepositTransaction(
                idGenerator.generateTransactionId(), id, amount);
        addTransaction(transaction);

        return transaction;
    }

    /**
     * Withdraws cash from the portfolio.
     */
    public PortfolioTransaction withdrawCash(Money amount) {
        Objects.requireNonNull(amount, "Amount cannot be null");
        validateCurrency(amount, "Withdrawal amount");
        validateSufficientCash(amount);

        updateCashBalance(amount.negate());

        PortfolioTransaction transaction = PortfolioTransaction.createWithdrawalTransaction(
                idGenerator.generateTransactionId(), id, amount);
        addTransaction(transaction);

        return transaction;
    }

    /**
     * Buys an asset and updates the portfolio.
     */
    public PortfolioTransaction buyAsset(Symbol symbol, BigDecimal quantity, Money price, String relatedOrderId) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        Objects.requireNonNull(quantity, "Quantity cannot be null");
        Objects.requireNonNull(price, "Price cannot be null");
        validateCurrency(price, "Price");

        Money totalCost = price.multiply(quantity);
        validateSufficientCash(totalCost);

        // Update cash balance
        updateCashBalance(totalCost.negate());

        // Update position
        updatePosition(symbol, quantity, price, TransactionType.BUY);

        // Create transaction record
        PortfolioTransaction transaction = PortfolioTransaction.createBuyTransaction(
                idGenerator.generateTransactionId(), id, symbol, quantity, price, relatedOrderId);
        addTransaction(transaction);

        return transaction;
    }

    /**
     * Sells an asset and updates the portfolio.
     */
    public PortfolioTransaction sellAsset(Symbol symbol, BigDecimal quantity, Money price, String relatedOrderId) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        Objects.requireNonNull(quantity, "Quantity cannot be null");
        Objects.requireNonNull(price, "Price cannot be null");
        validateCurrency(price, "Price");
        validateSufficientPosition(symbol, quantity);

        Money totalProceeds = price.multiply(quantity);

        // Update position
        updatePosition(symbol, quantity, price, TransactionType.SELL);

        // Update cash balance
        updateCashBalance(totalProceeds);

        // Create transaction record
        PortfolioTransaction transaction = PortfolioTransaction.createSellTransaction(
                idGenerator.generateTransactionId(), id, symbol, quantity, price, relatedOrderId);
        addTransaction(transaction);

        return transaction;
    }

    // Query Operations

    /**
     * Gets a specific position by symbol.
     */
    public Optional<Position> getPosition(Symbol symbol) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        return Optional.ofNullable(positions.get(symbol));
    }

    /**
     * Calculates the total portfolio value including cash and positions.
     */
    public Money getTotalValue(Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        Money totalPositionValue = positions.values().stream()
                .map(position -> {
                    Money currentPrice = currentPrices.get(position.getSymbol());
                    return currentPrice != null ? position.getCurrentValue(currentPrice) :
                            Money.zero(baseCurrency);
                })
                .reduce(Money.zero(baseCurrency), Money::add);

        return cashBalance.add(totalPositionValue);
    }

    /**
     * Calculates the total profit/loss across all positions.
     */
    public Money getTotalProfitLoss(Map<Symbol, Money> currentPrices) {
        Objects.requireNonNull(currentPrices, "Current prices cannot be null");

        return positions.values().stream()
                .map(position -> {
                    Money currentPrice = currentPrices.get(position.getSymbol());
                    return currentPrice != null ? position.getProfitLoss(currentPrice) :
                            Money.zero(baseCurrency);
                })
                .reduce(Money.zero(baseCurrency), Money::add);
    }

    /**
     * Calculates the total invested amount (cost basis of all positions).
     */
    public Money getTotalInvested() {
        return positions.values().stream()
                .map(Position::getCostBasis)
                .reduce(Money.zero(baseCurrency), Money::add);
    }

    /**
     * Checks if the portfolio has sufficient cash for a transaction.
     */
    public boolean canAfford(Money amount) {
        Objects.requireNonNull(amount, "Amount cannot be null");
        validateCurrency(amount, "Amount");
        return cashBalance.isGreaterThanOrEqual(amount);
    }

    /**
     * Gets transactions filtered by type.
     */
    public List<PortfolioTransaction> getTransactionsByType(TransactionType type) {
        Objects.requireNonNull(type, "Transaction type cannot be null");
        return transactions.stream()
                .filter(tx -> tx.getType() == type)
                .collect(Collectors.toList());
    }

    /**
     * Gets transactions for a specific symbol.
     */
    public List<PortfolioTransaction> getTransactionsForSymbol(Symbol symbol) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        return transactions.stream()
                .filter(tx -> symbol.equals(tx.getSymbol()))
                .collect(Collectors.toList());
    }

    // Private helper methods

    private void updateCashBalance(Money amount) {
        this.cashBalance = cashBalance.add(amount);
        this.updatedAt = LocalDateTime.now();
    }

    private void updatePosition(Symbol symbol, BigDecimal quantity, Money price, TransactionType type) {
        Position existingPosition = positions.get(symbol);

        if (type == TransactionType.BUY) {
            if (existingPosition == null) {
                // Create new position
                String positionId = idGenerator.generateTransactionId(); // Reuse for position IDs
                Position newPosition = new Position(positionId, id, symbol, quantity, price);
                positions.put(symbol, newPosition);
            } else {
                // Add to existing position
                existingPosition.addQuantity(quantity, price);
            }
        } else if (type == TransactionType.SELL) {
            if (existingPosition == null) {
                throw new IllegalStateException("Cannot sell asset with no position");
            }

            existingPosition.removeQuantity(quantity);

            // Remove position if empty
            if (existingPosition.isEmpty()) {
                positions.remove(symbol);
            }
        }
    }

    private void addTransaction(PortfolioTransaction transaction) {
        transactions.add(transaction);
        this.updatedAt = LocalDateTime.now();
    }

    private void validateSufficientCash(Money amount) {
        if (!canAfford(amount)) {
            throw new IllegalArgumentException(
                    String.format("Insufficient cash. Required: %s, Available: %s",
                            amount, cashBalance));
        }
    }

    private void validateSufficientPosition(Symbol symbol, BigDecimal quantity) {
        Position position = positions.get(symbol);
        if (position == null) {
            throw new IllegalArgumentException("No position exists for symbol: " + symbol.getCode());
        }

        if (!position.hasSufficientQuantity(quantity)) {
            throw new IllegalArgumentException(
                    String.format("Insufficient position. Required: %s, Available: %s",
                            quantity, position.getQuantity()));
        }
    }

    private void validateCurrency(Money money, String fieldName) {
        if (!money.getCurrency().equals(baseCurrency)) {
            throw new IllegalArgumentException(
                    String.format("%s currency %s does not match portfolio base currency %s",
                            fieldName, money.getCurrency(), baseCurrency));
        }
    }

    private void validatePortfolio() {
        if (name.trim().isEmpty()) {
            throw new IllegalArgumentException("Portfolio name cannot be empty");
        }

        if (cashBalance.isNegative()) {
            throw new IllegalArgumentException("Initial cash balance cannot be negative");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Portfolio portfolio = (Portfolio) obj;
        return Objects.equals(id, portfolio.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("Portfolio[%s: '%s' - %s cash, %d positions, %d transactions]",
                id, name, cashBalance, positions.size(), transactions.size());
    }
}=== ./order_book/domain/OrderBook.java ===
package core.ms.order_book.domain;

import core.ms.order.domain.IBuyOrder;
import core.ms.order.domain.IOrder;
import core.ms.order.domain.ISellOrder;
import core.ms.order_book.domain.value_object.*;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

public class OrderBook {
    private final Symbol symbol;
    private final TreeMap<Money, BidPriceLevel> bidLevels;
    private final TreeMap<Money, AskPriceLevel> askLevels;
    private final Map<String, IOrder> orderIndex;
    private LocalDateTime lastUpdate;
    private BigDecimal totalBidVolume;
    private BigDecimal totalAskVolume;

    private final BuyOrderPriorityCalculator buyOrderCalculator;
    private final SellOrderPriorityCalculator sellOrderCalculator;
    private final MatchFinder matchFinder;

    public OrderBook(Symbol symbol) {
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");

        this.buyOrderCalculator = new BuyOrderPriorityCalculator();
        this.sellOrderCalculator = new SellOrderPriorityCalculator();

        this.bidLevels = new TreeMap<>((price1, price2) -> {
            if (buyOrderCalculator.isPriceBetter(price2, price1)) return 1;
            if (buyOrderCalculator.isPriceBetter(price1, price2)) return -1;
            return 0;
        });

        this.askLevels = new TreeMap<>((price1, price2) -> {
            if (sellOrderCalculator.isPriceBetter(price1, price2)) return -1;
            if (sellOrderCalculator.isPriceBetter(price2, price1)) return 1;
            return 0;
        });

        this.orderIndex = new HashMap<>();
        this.lastUpdate = LocalDateTime.now();
        this.totalBidVolume = BigDecimal.ZERO;
        this.totalAskVolume = BigDecimal.ZERO;
        this.matchFinder = new MatchFinder();
    }

    public void addOrder(IOrder order) {
        Objects.requireNonNull(order, "Order cannot be null");
        validateOrder(order);

        orderIndex.put(order.getId(), order);

        Money price = order.getPrice();

        if (order instanceof IBuyOrder) {
            BidPriceLevel level = bidLevels.computeIfAbsent(price, BidPriceLevel::new);
            level.addOrder((IBuyOrder) order);
        } else if (order instanceof ISellOrder) {
            AskPriceLevel level = askLevels.computeIfAbsent(price, AskPriceLevel::new);
            level.addOrder((ISellOrder) order);
        } else {
            throw new IllegalArgumentException("Unknown order type: " + order.getClass());
        }

        updateVolumeMetrics();
        lastUpdate = LocalDateTime.now();
    }

    public boolean removeOrder(IOrder order) {
        Objects.requireNonNull(order, "Order cannot be null");

        if (orderIndex.remove(order.getId()) != null) {
            Money price = order.getPrice();

            if (order instanceof IBuyOrder) {
                BidPriceLevel level = bidLevels.get(price);
                if (level != null) {
                    level.removeOrder((IBuyOrder) order);
                    if (level.isEmpty()) {
                        bidLevels.remove(price);
                    }
                }
            } else if (order instanceof ISellOrder) {
                AskPriceLevel level = askLevels.get(price);
                if (level != null) {
                    level.removeOrder((ISellOrder) order);
                    if (level.isEmpty()) {
                        askLevels.remove(price);
                    }
                }
            } else {
                throw new IllegalArgumentException("Unknown order type: " + order.getClass());
            }

            updateVolumeMetrics();
            lastUpdate = LocalDateTime.now();
            return true;
        }
        return false;
    }

    /**
     * Removes all inactive (filled or cancelled) orders from the order book.
     * This method should be called after transactions to maintain a clean order book
     * containing only tradeable orders.
     */
    public void removeInactiveOrders() {
        // Collect inactive orders to avoid concurrent modification
        List<IOrder> inactiveOrders = orderIndex.values().stream()
                .filter(order -> !order.isActive())
                .collect(Collectors.toList());

        // Remove each inactive order
        for (IOrder inactiveOrder : inactiveOrders) {
            removeOrder(inactiveOrder);
        }
    }

    public Optional<Money> getBestBid() {
        return bidLevels.isEmpty() ? Optional.empty() : Optional.of(bidLevels.firstKey());
    }

    public Optional<Money> getBestAsk() {
        return askLevels.isEmpty() ? Optional.empty() : Optional.of(askLevels.firstKey());
    }

    public Optional<Money> getSpread() {
        Optional<Money> bestBid = getBestBid();
        Optional<Money> bestAsk = getBestAsk();

        if (bestBid.isPresent() && bestAsk.isPresent()) {
            return Optional.of(bestAsk.get().subtract(bestBid.get()));
        }
        return Optional.empty();
    }

    public Optional<IBuyOrder> getBestBuyOrder() {
        return bidLevels.values().stream()
                .map(BidPriceLevel::getFirstActiveOrder)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .findFirst();
    }

    public Optional<ISellOrder> getBestSellOrder() {
        return askLevels.values().stream()
                .map(AskPriceLevel::getFirstActiveOrder)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .findFirst();
    }

    public MarketDepth getMarketDepth(int levels) {
        if (levels <= 0) {
            throw new IllegalArgumentException("Levels must be positive");
        }

        List<BidPriceLevel> topBids = bidLevels.values().stream()
                .limit(levels)
                .collect(Collectors.toList());

        List<AskPriceLevel> topAsks = askLevels.values().stream()
                .limit(levels)
                .collect(Collectors.toList());

        return new MarketDepth(symbol, topBids, topAsks);
    }

    public List<OrderMatch> findMatches() {
        // Clean up inactive orders before finding matches
        removeInactiveOrders();
        return matchFinder.findMatches(this);
    }

    public Collection<BidPriceLevel> getBidLevels() {
        return new ArrayList<>(bidLevels.values());
    }

    public Collection<AskPriceLevel> getAskLevels() {
        return new ArrayList<>(askLevels.values());
    }

    public BigDecimal getTotalBidVolume() {
        return totalBidVolume;
    }

    public BigDecimal getTotalAskVolume() {
        return totalAskVolume;
    }

    public boolean isEmpty() {
        return bidLevels.isEmpty() && askLevels.isEmpty();
    }

    public boolean hasOrders() {
        return !isEmpty();
    }

    public int getOrderCount() {
        return orderIndex.size();
    }

    public Symbol getSymbol() {
        return symbol;
    }

    public LocalDateTime getLastUpdate() {
        return lastUpdate;
    }

    private void validateOrder(IOrder order) {
        if (!symbol.equals(order.getSymbol())) {
            throw new IllegalArgumentException(
                    "Order symbol " + order.getSymbol() + " does not match book symbol " + symbol);
        }

        if (!order.isActive()) {
            throw new IllegalArgumentException("Only active orders can be added to order book");
        }

        if (orderIndex.containsKey(order.getId())) {
            throw new IllegalArgumentException("Order " + order.getId() + " already exists in book");
        }
    }

    private void updateVolumeMetrics() {
        totalBidVolume = bidLevels.values().stream()
                .map(BidPriceLevel::getTotalQuantity)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        totalAskVolume = askLevels.values().stream()
                .map(AskPriceLevel::getTotalQuantity)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}=== ./order_book/domain/value_object/MarketDepth.java ===
package core.ms.order_book.domain.value_object;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class MarketDepth {
    private final Symbol symbol;
    private final List<BidPriceLevel> bidLevels;
    private final List<AskPriceLevel> askLevels;
    private final Money spread;
    private final BigDecimal totalBidVolume;
    private final BigDecimal totalAskVolume;
    private final LocalDateTime timestamp;

    public MarketDepth(Symbol symbol, List<BidPriceLevel> bidLevels, List<AskPriceLevel> askLevels) {
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.bidLevels = new ArrayList<>(Objects.requireNonNull(bidLevels, "Bid levels cannot be null"));
        this.askLevels = new ArrayList<>(Objects.requireNonNull(askLevels, "Ask levels cannot be null"));
        this.timestamp = LocalDateTime.now();

        this.totalBidVolume = calculateBidVolume();
        this.totalAskVolume = calculateAskVolume();
        this.spread = calculateSpread();
    }

    public Symbol getSymbol() {
        return symbol;
    }

    public List<BidPriceLevel> getBidLevels() {
        return new ArrayList<>(bidLevels);
    }

    public List<AskPriceLevel> getAskLevels() {
        return new ArrayList<>(askLevels);
    }

    public Money getSpread() {
        return spread;
    }

    public BigDecimal getTotalBidVolume() {
        return totalBidVolume;
    }

    public BigDecimal getTotalAskVolume() {
        return totalAskVolume;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public Optional<BidPriceLevel> getBestBid() {
        return bidLevels.isEmpty() ? Optional.empty() : Optional.of(bidLevels.get(0));
    }

    public Optional<AskPriceLevel> getBestAsk() {
        return askLevels.isEmpty() ? Optional.empty() : Optional.of(askLevels.get(0));
    }

    public boolean isEmpty() {
        return bidLevels.isEmpty() && askLevels.isEmpty();
    }

    public int getLevelCount() {
        return bidLevels.size() + askLevels.size();
    }

    private BigDecimal calculateBidVolume() {
        return bidLevels.stream()
                .map(BidPriceLevel::getTotalQuantity)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private BigDecimal calculateAskVolume() {
        return askLevels.stream()
                .map(AskPriceLevel::getTotalQuantity)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private Money calculateSpread() {
        Optional<BidPriceLevel> bestBid = getBestBid();
        Optional<AskPriceLevel> bestAsk = getBestAsk();

        if (bestBid.isPresent() && bestAsk.isPresent()) {
            return bestAsk.get().getPrice().subtract(bestBid.get().getPrice());
        }
        return null; // No spread when missing bid or ask
    }
}
=== ./order_book/domain/value_object/OrderMatch.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.IBuyOrder;
import core.ms.order.domain.ISellOrder;
import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Objects;

public class OrderMatch {
    private final IBuyOrder buyOrder;
    private final ISellOrder sellOrder;
    private final BigDecimal matchableQuantity;
    private final Money suggestedPrice;
    private final LocalDateTime timestamp;

    public OrderMatch(IBuyOrder buyOrder, ISellOrder sellOrder) {
        this.buyOrder = Objects.requireNonNull(buyOrder, "Buy order cannot be null");
        this.sellOrder = Objects.requireNonNull(sellOrder, "Sell order cannot be null");

        validateMatchCompatibility();

        this.matchableQuantity = calculateMatchableQuantity();
        this.suggestedPrice = calculatePriceTimePriority(); // Changed to use price-time priority
        this.timestamp = LocalDateTime.now();
    }

    public IBuyOrder getBuyOrder() {
        return buyOrder;
    }

    public ISellOrder getSellOrder() {
        return sellOrder;
    }

    public BigDecimal getMatchableQuantity() {
        return matchableQuantity;
    }

    public Money getSuggestedPrice() {
        return suggestedPrice;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public boolean isValid() {
        return matchableQuantity.compareTo(BigDecimal.ZERO) > 0 &&
                buyOrder.isActive() &&
                sellOrder.isActive();
    }

    public Money getTotalValue() {
        return suggestedPrice.multiply(matchableQuantity);
    }

    private BigDecimal calculateMatchableQuantity() {
        BigDecimal buyRemaining = buyOrder.getRemainingQuantity();
        BigDecimal sellRemaining = sellOrder.getRemainingQuantity();
        return buyRemaining.min(sellRemaining);
    }

    /**
     * Calculates execution price using midpoint pricing for fair execution.
     * This method provides equal price improvement to both buyer and seller.
     *
     * @return midpoint price between buy and sell orders
     */
    private Money calculateMidpointPrice() {
        Money buyPrice = buyOrder.getPrice();
        Money sellPrice = sellOrder.getPrice();
        return buyPrice.add(sellPrice).divide(new BigDecimal("2"));
    }

    /**
     * Calculates execution price using price-time priority rules.
     * The order that arrived first (resting order) gets filled at their preferred price.
     * This reflects real-world market behavior where:
     * - Resting orders get price protection
     * - Aggressive orders pay the market price
     * - Time priority rewards early orders
     *
     * @return execution price based on which order has time priority
     */
    private Money calculatePriceTimePriority() {
        LocalDateTime buyOrderTime = buyOrder.getCreatedAt();
        LocalDateTime sellOrderTime = sellOrder.getCreatedAt();

        // Whoever was there first gets their preferred price
        if (buyOrderTime.isBefore(sellOrderTime)) {
            // Buy order was resting, seller is aggressive
            // Seller accepts buyer's price
            return buyOrder.getPrice();
        } else if (sellOrderTime.isBefore(buyOrderTime)) {
            // Sell order was resting, buyer is aggressive
            // Buyer pays seller's price
            return sellOrder.getPrice();
        } else {
            // Same timestamp (rare edge case) - fall back to midpoint for fairness
            return calculateMidpointPrice();
        }
    }

    /**
     * Alternative price-time priority that considers order aggressiveness.
     * An aggressive order is one that crosses the spread to make a trade happen.
     *
     * @param buyOrderIsAggressive whether the buy order crossed the spread
     * @return execution price based on aggressor pays principle
     */
    public Money calculatePriceWithAggressor(boolean buyOrderIsAggressive) {
        if (buyOrderIsAggressive) {
            // Buyer is aggressive (lifted the ask), pays seller's price
            return sellOrder.getPrice();
        } else {
            // Seller is aggressive (hit the bid), accepts buyer's price
            return buyOrder.getPrice();
        }
    }

    private void validateMatchCompatibility() {
        if (!buyOrder.getSymbol().equals(sellOrder.getSymbol())) {
            throw new IllegalArgumentException("Orders must have the same symbol");
        }

        if (buyOrder.getPrice().isLessThan(sellOrder.getPrice())) {
            throw new IllegalArgumentException(
                    "Buy price " + buyOrder.getPrice() + " must be >= sell price " + sellOrder.getPrice());
        }

        if (!buyOrder.isActive() || !sellOrder.isActive()) {
            throw new IllegalArgumentException("Both orders must be active");
        }
    }
}=== ./order_book/domain/value_object/BuyOrderPriorityCalculator.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.IBuyOrder;
import core.ms.shared.domain.Money;

import java.util.Objects;

public class BuyOrderPriorityCalculator extends AbstractPriorityCalculator<IBuyOrder> {

    @Override
    public boolean isPriceBetter(Money price1, Money price2) {
        Objects.requireNonNull(price1, "First price cannot be null");
        Objects.requireNonNull(price2, "Second price cannot be null");

        return price1.isGreaterThan(price2);
    }
}=== ./order_book/domain/value_object/AskPriceLevel.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.ISellOrder;
import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class AskPriceLevel extends AbstractPriceLevel<ISellOrder> {
    private final LinkedList<ISellOrder> sellOrders; // Time-ordered queue

    public AskPriceLevel(Money price) {
        super(price);
        this.sellOrders = new LinkedList<>();
    }

    public void addOrder(ISellOrder order) {
        Objects.requireNonNull(order, "Sell order cannot be null");
        validateOrderPrice(order);

        sellOrders.addLast(order); // Time priority: first in, first out
        recalculateTotals();
    }

    public boolean removeOrder(ISellOrder order) {
        Objects.requireNonNull(order, "Sell order cannot be null");
        boolean removed = sellOrders.remove(order);
        if (removed) {
            recalculateTotals();
        }
        return removed;
    }

    @Override
    protected Stream<ISellOrder> getOrdersStream() {
        return sellOrders.stream();
    }
    public List<ISellOrder> getOrders() {
        return new ArrayList<>(sellOrders); // Defensive copy
    }

    /**
     * Returns only active orders with remaining quantity > 0.
     * This ensures that inactive or fully filled orders don't appear in order lists.
     */
    public List<ISellOrder> getActiveOrders() {
        return sellOrders.stream()
                .filter(order -> order.isActive() && order.getRemainingQuantity().compareTo(BigDecimal.ZERO) > 0)
                .collect(Collectors.toList());
    }

    @Override
    public boolean isEmpty() {
        return sellOrders.isEmpty();
    }

    public Optional<ISellOrder> getFirstOrder() {
        return sellOrders.isEmpty() ? Optional.empty() : Optional.of(sellOrders.getFirst());
    }


    @Override
    protected void recalculateTotals() {
        orderCount = sellOrders.size();
    }

    /**
     * Removes all inactive orders from this price level.
     * Should be called periodically to keep the order book clean.
     */
    public void removeInactiveOrders() {
        sellOrders.removeIf(order -> !order.isActive());
        recalculateTotals();
    }
}=== ./order_book/domain/value_object/AbstractPriorityCalculator.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.IOrder;
import core.ms.shared.domain.Money;

import java.time.LocalDateTime;
import java.util.Objects;

public abstract class AbstractPriorityCalculator<T extends IOrder> implements IPriorityCalculator<T> {

    @Override
    public boolean isHigherPriority(T order1, T order2) {
        Objects.requireNonNull(order1, "First order cannot be null");
        Objects.requireNonNull(order2, "Second order cannot be null");

        Money price1 = order1.getPrice();
        Money price2 = order2.getPrice();

        if (isPriceBetter(price1, price2)) {
            return true;
        }

        if (isPriceBetter(price2, price1)) {
            return false;
        }

        return isTimeBetter(order1.getCreatedAt(), order2.getCreatedAt());
    }

    @Override
    public boolean isTimeBetter(LocalDateTime time1, LocalDateTime time2) {
        return time1.isBefore(time2);
    }

    @Override
    public Money calculatePriceDifference(Money price1, Money price2) {
        Money difference = price1.subtract(price2);
        return difference.isNegative() ? difference.negate() : difference;
    }

    @Override
    public boolean hasSamePrice(T order1, T order2) {
        Objects.requireNonNull(order1, "First order cannot be null");
        Objects.requireNonNull(order2, "Second order cannot be null");

        Money price1 = order1.getPrice();
        Money price2 = order2.getPrice();

        return price1.equals(price2);
    }
}
=== ./order_book/domain/value_object/IPriceLevel.java ===
package core.ms.order_book.domain.value_object;

import core.ms.shared.domain.Money;

import java.math.BigDecimal;

public interface IPriceLevel {
    Money getPrice();
    BigDecimal getTotalQuantity();
    int getOrderCount();
    boolean isEmpty();
    boolean hasQuantity(BigDecimal quantity);
}=== ./order_book/domain/value_object/SellOrderPriorityCalculator.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.ISellOrder;
import core.ms.shared.domain.Money;

import java.util.Objects;

public class SellOrderPriorityCalculator extends AbstractPriorityCalculator<ISellOrder> {

    @Override
    public boolean isPriceBetter(Money price1, Money price2) {
        Objects.requireNonNull(price1, "First price cannot be null");
        Objects.requireNonNull(price2, "Second price cannot be null");

        return price1.isLessThan(price2);
    }


}=== ./order_book/domain/value_object/BidPriceLevel.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.IBuyOrder;
import core.ms.order.domain.IOrder;
import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class BidPriceLevel extends AbstractPriceLevel<IBuyOrder> {
    private final LinkedList<IBuyOrder> buyOrders; // Time-ordered queue

    public BidPriceLevel(Money price) {
        super(price);
        this.buyOrders = new LinkedList<>();
    }

    public void addOrder(IBuyOrder order) {
        Objects.requireNonNull(order, "Buy order cannot be null");
        validateOrderPrice(order);

        buyOrders.addLast(order); // Time priority: first in, first out
        recalculateTotals();
    }

    public boolean removeOrder(IBuyOrder order) {
        Objects.requireNonNull(order, "Buy order cannot be null");
        boolean removed = buyOrders.remove(order);
        if (removed) {
            recalculateTotals();
        }
        return removed;
    }

    public List<IBuyOrder> getOrders() {
        return new ArrayList<>(buyOrders); // Defensive copy
    }

    /**
     * Returns only active orders with remaining quantity > 0.
     * This ensures that inactive or fully filled orders don't appear in order lists.
     */
    public List<IBuyOrder> getActiveOrders() {
        return buyOrders.stream()
                .filter(order -> order.isActive() && order.getRemainingQuantity().compareTo(BigDecimal.ZERO) > 0)
                .collect(Collectors.toList());
    }
    @Override
    protected Stream<IBuyOrder> getOrdersStream() {
        return buyOrders.stream();
    }
    @Override
    public boolean isEmpty() {
        return buyOrders.isEmpty();
    }

    public Optional<IBuyOrder> getFirstOrder() {
        return buyOrders.isEmpty() ? Optional.empty() : Optional.of(buyOrders.getFirst());
    }

    @Override
    protected BigDecimal calculateCurrentTotal() {
        return buyOrders.stream()
                .filter(IOrder::isActive)
                .map(IBuyOrder::getRemainingQuantity)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    @Override
    protected void recalculateTotals() {
        orderCount = buyOrders.size();
    }

    /**
     * Removes all inactive orders from this price level.
     * Should be called periodically to keep the order book clean.
     */
    public void removeInactiveOrders() {
        buyOrders.removeIf(order -> !order.isActive());
        recalculateTotals();
    }
}=== ./order_book/domain/value_object/MatchFinder.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.IBuyOrder;
import core.ms.order.domain.ISellOrder;
import core.ms.order_book.domain.OrderBook;
import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class MatchFinder {

    public List<OrderMatch> findMatches(OrderBook orderBook) {
        Objects.requireNonNull(orderBook, "OrderBook cannot be null");

        List<OrderMatch> matches = new ArrayList<>();

        Optional<Money> bestBidPrice = orderBook.getBestBid();
        Optional<Money> bestAskPrice = orderBook.getBestAsk();

        if (bestBidPrice.isPresent() && bestAskPrice.isPresent()) {
            if (bestBidPrice.get().isGreaterThanOrEqual(bestAskPrice.get())) {
                Optional<IBuyOrder> bestBuyOrder = orderBook.getBestBuyOrder();
                Optional<ISellOrder> bestSellOrder = orderBook.getBestSellOrder();

                if (bestBuyOrder.isPresent() && bestSellOrder.isPresent()) {
                    if (canMatch(bestBuyOrder.get(), bestSellOrder.get())) {
                        matches.add(new OrderMatch(bestBuyOrder.get(), bestSellOrder.get()));
                    }
                }
            }
        }

        return matches;
    }

    public boolean canMatch(IBuyOrder buyOrder, ISellOrder sellOrder) {
        Objects.requireNonNull(buyOrder, "Buy order cannot be null");
        Objects.requireNonNull(sellOrder, "Sell order cannot be null");

        return buyOrder.getSymbol().equals(sellOrder.getSymbol()) &&
                buyOrder.getPrice().isGreaterThanOrEqual(sellOrder.getPrice()) &&
                buyOrder.isActive() &&
                sellOrder.isActive() &&
                buyOrder.getRemainingQuantity().compareTo(BigDecimal.ZERO) > 0 &&
                sellOrder.getRemainingQuantity().compareTo(BigDecimal.ZERO) > 0;
    }

    public Money calculateMatchPrice(Money buyPrice, Money sellPrice) {
        Objects.requireNonNull(buyPrice, "Buy price cannot be null");
        Objects.requireNonNull(sellPrice, "Sell price cannot be null");

        if (buyPrice.isLessThan(sellPrice)) {
            throw new IllegalArgumentException("Buy price must be >= sell price for matching");
        }

        return buyPrice.add(sellPrice).divide(new BigDecimal("2"));
    }

    public BigDecimal calculateMatchQuantity(BigDecimal buyQuantity, BigDecimal sellQuantity) {
        Objects.requireNonNull(buyQuantity, "Buy quantity cannot be null");
        Objects.requireNonNull(sellQuantity, "Sell quantity cannot be null");

        if (buyQuantity.compareTo(BigDecimal.ZERO) <= 0 || sellQuantity.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Quantities must be positive");
        }

        return buyQuantity.min(sellQuantity);
    }
}=== ./order_book/domain/value_object/IPriorityCalculator.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.IOrder;
import core.ms.shared.domain.Money;

import java.time.LocalDateTime;

public interface IPriorityCalculator<T extends IOrder> {
    boolean isHigherPriority(T order1, T order2);           // NOT compareOrders!
    boolean isPriceBetter(Money price1, Money price2);      // ✅ Same
    boolean isTimeBetter(LocalDateTime time1, LocalDateTime time2); // ✅ Same
    Money calculatePriceDifference(Money price1, Money price2);     // NOT comparePrices!
    boolean hasSamePrice(T order1, T order2);               // NEW method
}=== ./order_book/domain/value_object/AbstractPriceLevel.java ===
package core.ms.order_book.domain.value_object;

import core.ms.order.domain.IOrder;
import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;

public abstract class AbstractPriceLevel<T extends IOrder> implements IPriceLevel {
    protected final Money price;
    protected int orderCount;

    protected AbstractPriceLevel(Money price) {
        this.price = Objects.requireNonNull(price, "Price cannot be null");
        this.orderCount = 0;
    }

    @Override
    public Money getPrice() {
        return price;
    }

    @Override
    public BigDecimal getTotalQuantity() {
        return calculateCurrentTotal();
    }

    @Override
    public int getOrderCount() {
        return orderCount;
    }

    @Override
    public boolean hasQuantity(BigDecimal quantity) {
        return getTotalQuantity().compareTo(quantity) >= 0;
    }

    protected void validateOrderPrice(IOrder order) {
        if (!price.equals(order.getPrice())) {
            throw new IllegalArgumentException(
                    "Order price " + order.getPrice() + " does not match level price " + price);
        }
    }

    /**
     * Calculates the current total quantity from all orders in this level.
     * This method is called every time getTotalQuantity() is invoked to ensure
     * the total always reflects the current state of orders, including any
     * quantity changes due to transactions.
     */
    protected BigDecimal calculateCurrentTotal() {
        // Basic business rule: price level shows quantity of all orders at this price
        return getOrdersStream()
                .map(IOrder::getRemainingQuantity)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /**
     * Updates cached values that don't change during transactions.
     * Currently only updates order count since total quantity is calculated dynamically.
     */
    protected abstract void recalculateTotals();

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        AbstractPriceLevel<?> that = (AbstractPriceLevel<?>) obj;
        return Objects.equals(price, that.price);
    }

    @Override
    public int hashCode() {
        return Objects.hash(price);
    }
    protected abstract Stream<T> getOrdersStream();

    public Optional<T> getFirstActiveOrder() {
        return getOrdersStream()
                .filter(order -> order.isActive() && order.getRemainingQuantity().compareTo(BigDecimal.ZERO) > 0)
                .findFirst();
    }
}=== ./order_book/domain/value_object/MarketOverview.java ===
package core.ms.order_book.domain.value_object;

import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.*;

public class MarketOverview {
    private final Set<Symbol> activeSymbols;
    private final int totalOrderBooks;
    private final int totalOrders;
    private final Map<Symbol, BigDecimal> totalVolume;
    private final LocalDateTime timestamp;

    public MarketOverview(Set<Symbol> activeSymbols, int totalOrderBooks,
                          int totalOrders, Map<Symbol, BigDecimal> totalVolume) {
        this.activeSymbols = new HashSet<>(Objects.requireNonNull(activeSymbols, "Active symbols cannot be null"));
        this.totalOrderBooks = totalOrderBooks;
        this.totalOrders = totalOrders;
        this.totalVolume = new HashMap<>(Objects.requireNonNull(totalVolume, "Total volume cannot be null"));
        this.timestamp = LocalDateTime.now();
    }

    public Set<Symbol> getActiveSymbols() {
        return new HashSet<>(activeSymbols);
    }

    public int getTotalOrderBooks() {
        return totalOrderBooks;
    }

    public int getTotalOrders() {
        return totalOrders;
    }

    public Map<Symbol, BigDecimal> getTotalVolume() {
        return new HashMap<>(totalVolume);
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public BigDecimal getVolumeForSymbol(Symbol symbol) {
        return totalVolume.getOrDefault(symbol, BigDecimal.ZERO);
    }
}
=== ./order_book/domain/OrderBookManager.java ===
package core.ms.order_book.domain;

import core.ms.order.domain.IOrder;
import core.ms.order_book.domain.value_object.MarketOverview;
import core.ms.order_book.domain.value_object.OrderMatch;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class OrderBookManager {
    private final Map<Symbol, OrderBook> orderBooks;

    public OrderBookManager() {
        this.orderBooks = new ConcurrentHashMap<>();
    }

    public OrderBook getOrderBook(Symbol symbol) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        return orderBooks.computeIfAbsent(symbol, OrderBook::new);
    }

    public OrderBook createOrderBook(Symbol symbol) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");

        if (orderBooks.containsKey(symbol)) {
            throw new IllegalArgumentException("OrderBook for symbol " + symbol + " already exists");
        }

        OrderBook orderBook = new OrderBook(symbol);
        orderBooks.put(symbol, orderBook);
        return orderBook;
    }

    public boolean removeOrderBook(Symbol symbol) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");

        OrderBook removed = orderBooks.remove(symbol);
        return removed != null;
    }

    public Collection<OrderBook> getAllOrderBooks() {
        return new ArrayList<>(orderBooks.values());
    }

    public Set<Symbol> getActiveSymbols() {
        return new HashSet<>(orderBooks.keySet());
    }

    public int getTotalOrderBooks() {
        return orderBooks.size();
    }

    public synchronized void addOrderToBook(IOrder order) {
        Objects.requireNonNull(order, "Order cannot be null");
        OrderBook orderBook = getOrderBook(order.getSymbol());
        orderBook.addOrder(order);
    }

    public synchronized boolean removeOrderFromBook(IOrder order, Symbol symbol) {
        Objects.requireNonNull(order, "Order ID cannot be null");
        Objects.requireNonNull(symbol, "Symbol cannot be null");

        OrderBook orderBook = orderBooks.get(symbol);
        return orderBook != null && orderBook.removeOrder(order);
    }

    public List<OrderMatch> findAllMatches() {
        return orderBooks.values().stream()
                .flatMap(orderBook -> orderBook.findMatches().stream())
                .collect(Collectors.toList());
    }

    public MarketOverview getMarketOverview() {
        Map<Symbol, BigDecimal> totalVolumes = new HashMap<>();
        int totalOrders = 0;

        for (OrderBook orderBook : orderBooks.values()) {
            Symbol symbol = orderBook.getSymbol();
            BigDecimal totalVolume = orderBook.getTotalBidVolume().add(orderBook.getTotalAskVolume());
            totalVolumes.put(symbol, totalVolume);
            totalOrders += orderBook.getOrderCount();
        }

        return new MarketOverview(
                new HashSet<>(orderBooks.keySet()),
                orderBooks.size(),
                totalOrders,
                totalVolumes
        );
    }


}
=== ./market_engine/event/OrderAcceptedEvent.java ===
package core.ms.market_engine.event;

import core.ms.order.domain.IOrder;

import java.util.Objects;

public class OrderAcceptedEvent extends DomainEvent {
    private final IOrder order;

    public OrderAcceptedEvent(IOrder order, String engineId) {
        super(engineId);
        this.order = Objects.requireNonNull(order, "Order cannot be null");
    }

    public IOrder getOrder() {
        return order;
    }

    @Override
    public String toString() {
        return "OrderAcceptedEvent{" +
                "orderId='" + order.getId() + '\'' +
                ", symbol=" + order.getSymbol().getCode() +
                ", eventId='" + eventId + '\'' +
                '}';
    }
}
=== ./market_engine/event/TransactionCreatedEvent.java ===
package core.ms.market_engine.event;

import core.ms.order.domain.ITransaction;

import java.util.Objects;

public class TransactionCreatedEvent extends DomainEvent {
    private final ITransaction transaction;

    public TransactionCreatedEvent(ITransaction transaction, String engineId) {
        super(engineId);
        this.transaction = Objects.requireNonNull(transaction, "Transaction cannot be null");
    }

    public ITransaction getTransaction() {
        return transaction;
    }

    @Override
    public String toString() {
        return "TransactionCreatedEvent{" +
                "transactionId='" + transaction.getId() + '\'' +
                ", symbol=" + transaction.getSymbol().getCode() +
                ", eventId='" + eventId + '\'' +
                '}';
    }
}

=== ./market_engine/event/DomainEvent.java ===
package core.ms.market_engine.event;

import core.ms.utils.IdGenerator;

import java.time.LocalDateTime;
import java.util.Objects;

public abstract class DomainEvent {
    protected final String eventId;
    protected final LocalDateTime timestamp;
    protected final String engineId;

    protected DomainEvent(String engineId) {
        this.eventId = new IdGenerator().generateEventId();
        this.timestamp = LocalDateTime.now();
        this.engineId = Objects.requireNonNull(engineId, "Engine ID cannot be null");
    }

    public String getEventId() {
        return eventId;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public String getEngineId() {
        return engineId;
    }
}
=== ./market_engine/event/OrderExecutedEvent.java ===
package core.ms.market_engine.event;

import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.util.Objects;

public class OrderExecutedEvent extends DomainEvent {
    private final String orderId;
    private final BigDecimal executedQuantity;
    private final BigDecimal remainingQuantity;
    private final Money executionPrice;

    public OrderExecutedEvent(String orderId, BigDecimal executedQuantity,
                              BigDecimal remainingQuantity, Money executionPrice, String engineId) {
        super(engineId);
        this.orderId = Objects.requireNonNull(orderId, "Order ID cannot be null");
        this.executedQuantity = Objects.requireNonNull(executedQuantity, "Executed quantity cannot be null");
        this.remainingQuantity = Objects.requireNonNull(remainingQuantity, "Remaining quantity cannot be null");
        this.executionPrice = Objects.requireNonNull(executionPrice, "Execution price cannot be null");
    }

    public String getOrderId() {
        return orderId;
    }

    public BigDecimal getExecutedQuantity() {
        return executedQuantity;
    }

    public BigDecimal getRemainingQuantity() {
        return remainingQuantity;
    }

    public Money getExecutionPrice() {
        return executionPrice;
    }

    public boolean isFullyExecuted() {
        return remainingQuantity.compareTo(BigDecimal.ZERO) == 0;
    }

    @Override
    public String toString() {
        return "OrderExecutedEvent{" +
                "orderId='" + orderId + '\'' +
                ", executedQuantity=" + executedQuantity +
                ", remainingQuantity=" + remainingQuantity +
                ", executionPrice=" + executionPrice.toPlainString() +
                ", fullyExecuted=" + isFullyExecuted() +
                '}';
    }
}=== ./market_engine/TransactionProcessor.java ===
package core.ms.market_engine;

import core.ms.order.domain.ITransaction;
import core.ms.order.domain.Transaction;
import core.ms.order_book.domain.value_object.OrderMatch;
import core.ms.utils.IdGenerator;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class TransactionProcessor {
    private final IdGenerator idGenerator;

    public TransactionProcessor() {
        this.idGenerator = new IdGenerator();
    }

    /**
     * Creates a transaction from an order match.
     * Note: Order status updates and quantity management are automatically
     * handled by the Order domain when the Transaction is created.
     */
    public ITransaction createTransaction(OrderMatch match) {
        Objects.requireNonNull(match, "OrderMatch cannot be null");

        if (!match.isValid()) {
            throw new IllegalArgumentException("Cannot create transaction from invalid match");
        }

        String transactionId = idGenerator.generateTransactionId();

        // Creating the transaction automatically updates both orders
        // via AbstractTransaction.updateOrdersAfterTransaction()
        return new Transaction(
                transactionId,
                match.getBuyOrder().getSymbol(),
                match.getBuyOrder(),
                match.getSellOrder(),
                match.getSuggestedPrice(),
                match.getMatchableQuantity()
        );
    }

    /**
     * Processes multiple matches into transactions.
     * Each transaction creation automatically updates the involved orders.
     */
    public List<ITransaction> processMatches(List<OrderMatch> matches) {
        return matches.stream()
                .filter(OrderMatch::isValid)
                .map(this::createTransaction)
                .collect(Collectors.toList());
    }

}=== ./market_engine/MarketEngine.java ===
package core.ms.market_engine;

import core.ms.market_engine.event.OrderAcceptedEvent;
import core.ms.market_engine.event.OrderExecutedEvent;
import core.ms.market_engine.event.TransactionCreatedEvent;
import core.ms.order.domain.IOrder;
import core.ms.order.domain.ITransaction;
import core.ms.order_book.domain.OrderBookManager;
import core.ms.order_book.domain.value_object.OrderMatch;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class MarketEngine {
    private final String engineId;
    private final OrderBookManager orderBookManager;
    private final TransactionProcessor transactionProcessor;
    private final EventPublisher eventPublisher;
    private final LocalDateTime createdAt;

    public MarketEngine(String engineId, OrderBookManager orderBookManager) {
        this.engineId = Objects.requireNonNull(engineId, "Engine ID cannot be null");
        this.orderBookManager = Objects.requireNonNull(orderBookManager, "OrderBookManager cannot be null");
        this.transactionProcessor = new TransactionProcessor();
        this.eventPublisher = new EventPublisher();
        this.createdAt = LocalDateTime.now();
    }

    /**
     * Main business operation: processes an order through the complete workflow.
     */
    public OrderResult processOrder(IOrder order) {
        Objects.requireNonNull(order, "Order cannot be null");

        try {
            // 1. Add order to the appropriate order book
            orderBookManager.addOrderToBook(order);

            // 2. Publish order accepted event
            eventPublisher.publishOrderAccepted(new OrderAcceptedEvent(order, engineId));

            // 3. Find all possible matches across all order books
            List<OrderMatch> matches = orderBookManager.findAllMatches();

            // 4. Process any matches into transactions
            List<ITransaction> transactions = processMatches(matches);

            // 5. Extract transaction IDs for the result
            List<String> transactionIds = transactions.stream()
                    .map(ITransaction::getId)
                    .collect(Collectors.toList());

            // 6. Return appropriate result
            if (transactions.isEmpty()) {
                return OrderResult.accepted(order.getId());
            } else {
                return OrderResult.acceptedWithTransactions(order.getId(), transactionIds);
            }

        } catch (Exception e) {
            return OrderResult.rejected(order.getId(), "Processing failed: " + e.getMessage());
        }
    }

    /**
     * Processes a list of order matches into transactions.
     * Note: Order status updates and quantity management are automatically
     * handled by the Order domain when transactions are created.
     */
    private List<ITransaction> processMatches(List<OrderMatch> matches) {
        List<ITransaction> transactions = new ArrayList<>();

        for (OrderMatch match : matches) {
            if (match.isValid()) {
                try {
                    // Create transaction - this automatically updates orders via Order domain
                    ITransaction transaction = transactionProcessor.createTransaction(match);
                    transactions.add(transaction);

                    // Publish transaction created event
                    eventPublisher.publishTransactionCreated(new TransactionCreatedEvent(transaction, engineId));

                    // Publish order execution events
                    publishOrderExecutionEvents(match);

                } catch (Exception e) {
                    System.err.println("Failed to process match: " + e.getMessage());
                }
            }
        }

        return transactions;
    }

    private void publishOrderExecutionEvents(OrderMatch match) {
        eventPublisher.publishOrderExecuted(new OrderExecutedEvent(
                match.getBuyOrder().getId(),
                match.getMatchableQuantity(),
                match.getBuyOrder().getRemainingQuantity(),
                match.getSuggestedPrice(),
                engineId
        ));

        eventPublisher.publishOrderExecuted(new OrderExecutedEvent(
                match.getSellOrder().getId(),
                match.getMatchableQuantity(),
                match.getSellOrder().getRemainingQuantity(),
                match.getSuggestedPrice(),
                engineId
        ));
    }

    // Getters
    public String getEngineId() {
        return engineId;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
}=== ./market_engine/EventPublisher.java ===
package core.ms.market_engine;

import core.ms.market_engine.event.OrderAcceptedEvent;
import core.ms.market_engine.event.OrderExecutedEvent;
import core.ms.market_engine.event.TransactionCreatedEvent;
import core.ms.order.domain.ITransaction;

import java.time.LocalDateTime;
import java.util.Objects;

public class EventPublisher {

    /**
     * Publishes order accepted event.
     */
    public void publishOrderAccepted(OrderAcceptedEvent event) {
        Objects.requireNonNull(event, "Event cannot be null");
        logEvent("ORDER_ACCEPTED",
                "Order " + event.getOrder().getId() + " accepted for symbol " + event.getOrder().getSymbol().getCode());
    }

    /**
     * Publishes transaction created event.
     */
    public void publishTransactionCreated(TransactionCreatedEvent event) {
        Objects.requireNonNull(event, "Event cannot be null");
        ITransaction tx = event.getTransaction();
        logEvent("TRANSACTION_CREATED",
                "Transaction " + tx.getId() + " created: " + tx.getQuantity() + " " +
                        tx.getSymbol().getCode() + " @ " + tx.getPrice().toPlainString());
    }

    /**
     * Publishes order executed event.
     */
    public void publishOrderExecuted(OrderExecutedEvent event) {
        Objects.requireNonNull(event, "Event cannot be null");
        logEvent("ORDER_EXECUTED",
                "Order " + event.getOrderId() + " executed: " + event.getExecutedQuantity() +
                        " @ " + event.getExecutionPrice().toPlainString() +
                        " (remaining: " + event.getRemainingQuantity() + ")");
    }

    /**
     * Simple logging mechanism.
     */
    private void logEvent(String eventType, String message) {
        System.out.println("[" + LocalDateTime.now() + "] " + eventType + ": " + message);
    }
}=== ./market_engine/OrderResult.java ===
package core.ms.market_engine;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class OrderResult {
    private final String orderId;
    private final boolean success;
    private final String message;
    private final LocalDateTime timestamp;
    private final List<String> transactionIds;

    public OrderResult(String orderId, boolean success, String message, List<String> transactionIds) {
        this.orderId = Objects.requireNonNull(orderId, "Order ID cannot be null");
        this.success = success;
        this.message = Objects.requireNonNull(message, "Message cannot be null");
        this.timestamp = LocalDateTime.now();
        this.transactionIds = transactionIds != null ? new ArrayList<>(transactionIds) : new ArrayList<>();
    }

    // Static factory methods
    public static OrderResult accepted(String orderId) {
        return new OrderResult(orderId, true, "Order accepted", new ArrayList<>());
    }

    public static OrderResult acceptedWithTransactions(String orderId, List<String> transactionIds) {
        return new OrderResult(orderId, true, "Order accepted and executed", transactionIds);
    }

    public static OrderResult rejected(String orderId, String reason) {
        return new OrderResult(orderId, false, reason, new ArrayList<>());
    }

    // Getters
    public String getOrderId() {
        return orderId;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public List<String> getTransactionIds() {
        return new ArrayList<>(transactionIds);
    }

    @Override
    public String toString() {
        return "OrderResult{" +
                "orderId='" + orderId + '\'' +
                ", success=" + success +
                ", message='" + message + '\'' +
                ", transactionIds=" + transactionIds.size() +
                '}';
    }
}=== ./shared/domain/Symbol.java ===
package core.ms.shared.domain;

import java.util.Objects;

public class Symbol {
    private final String code;
    private final String name;
    private final AssetType type;
    private final Currency baseCurrency;
    private final Currency quoteCurrency;

    public Symbol(String code, String name, AssetType type, Currency baseCurrency, Currency quoteCurrency) {
        if (code == null || code.trim().isEmpty()) {
            throw new IllegalArgumentException("Code cannot be null or empty");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Name cannot be null or empty");
        }
        if (type == null) {
            throw new IllegalArgumentException("AssetType cannot be null");
        }
        if (baseCurrency == null) {
            throw new IllegalArgumentException("Base currency cannot be null");
        }
        if (quoteCurrency == null) {
            throw new IllegalArgumentException("Quote currency cannot be null");
        }

        this.code = code.toUpperCase().trim();
        this.name = name.trim();
        this.type = type;
        this.baseCurrency = baseCurrency;
        this.quoteCurrency = quoteCurrency;
    }

    // ===== GETTERS =====

    public String getCode() {
        return code;
    }

    public String getName() {
        return name;
    }

    public AssetType getType() {
        return type;
    }

    public Currency getBaseCurrency() {
        return baseCurrency;
    }

    public Currency getQuoteCurrency() {
        return quoteCurrency;
    }

    // ===== BUSINESS METHODS =====

    public String getFullSymbol() {
        return code + "/" + quoteCurrency.name();
    }

    public String getDisplayName() {
        return String.format("%s (%s)", name, code);
    }

    public boolean isCrypto() {
        return type == AssetType.CRYPTO;
    }

    public boolean isStock() {
        return type == AssetType.STOCK;
    }

    public boolean isForex() {
        return type == AssetType.FOREX;
    }

    public boolean isCommodity() {
        return type == AssetType.COMMODITY;
    }

    public boolean isCrossCurrency() {
        return baseCurrency != quoteCurrency;
    }

    // ===== FACTORY METHODS =====

    public static Symbol btcUsd() {
        return new Symbol("BTC", "Bitcoin", AssetType.CRYPTO, Currency.BTC, Currency.USD);
    }

    public static Symbol btcEur() {
        return new Symbol("BTC", "Bitcoin", AssetType.CRYPTO, Currency.BTC, Currency.EUR);
    }

    public static Symbol ethUsd() {
        return new Symbol("ETH", "Ethereum", AssetType.CRYPTO, Currency.ETH, Currency.USD);
    }

    public static Symbol eurUsd() {
        return new Symbol("EURUSD", "Euro US Dollar", AssetType.FOREX, Currency.EUR, Currency.USD);
    }

    public static Symbol gbpUsd() {
        return new Symbol("GBPUSD", "British Pound US Dollar", AssetType.FOREX, Currency.GBP, Currency.USD);
    }

    // ===== OBJECT METHODS =====

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Symbol symbol = (Symbol) obj;
        return Objects.equals(code, symbol.code) &&
                Objects.equals(name, symbol.name) &&
                type == symbol.type &&
                baseCurrency == symbol.baseCurrency &&
                quoteCurrency == symbol.quoteCurrency;
    }

    @Override
    public int hashCode() {
        return Objects.hash(code, name, type, baseCurrency, quoteCurrency);
    }

    @Override
    public String toString() {
        return getFullSymbol();
    }
}=== ./shared/domain/ArithmeticStrategy.java ===
package core.ms.shared.domain;

import java.math.BigDecimal;
import java.math.RoundingMode;

public enum ArithmeticStrategy {
    ROUND_TO_CURRENCY_PRECISION {
        @Override
        public BigDecimal processResult(BigDecimal result, Currency currency) {
            return result.setScale(currency.getDecimalPlaces(), RoundingMode.HALF_UP);
        }
    },
    PRESERVE_FULL_PRECISION {
        @Override
        public BigDecimal processResult(BigDecimal result, Currency currency) {
            return result; // Keep all decimal places
        }
    },
    ROUND_TO_WHOLE_NUMBERS {
        @Override
        public BigDecimal processResult(BigDecimal result, Currency currency) {
            return result.setScale(0, RoundingMode.HALF_UP);
        }
    };

    public abstract BigDecimal processResult(BigDecimal result, Currency currency);
}=== ./shared/domain/AssetType.java ===
package core.ms.shared.domain;

public enum AssetType {
    CRYPTO("Cryptocurrency"),
    STOCK("Stock"),
    FOREX("Foreign Exchange"),
    COMMODITY("Commodity");

    private final String displayName;

    AssetType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }

    @Override
    public String toString() {
        return displayName;
    }
}=== ./shared/domain/Currency.java ===
package core.ms.shared.domain;

import java.math.BigDecimal;

public enum Currency {
    USD("$", 2, "US Dollar", ArithmeticStrategy.ROUND_TO_CURRENCY_PRECISION),
    EUR("€", 2, "Euro", ArithmeticStrategy.ROUND_TO_CURRENCY_PRECISION),
    GBP("£", 2, "British Pound", ArithmeticStrategy.ROUND_TO_CURRENCY_PRECISION),
    JPY("¥", 0, "Japanese Yen", ArithmeticStrategy.ROUND_TO_WHOLE_NUMBERS),
    BTC("₿", 8, "Bitcoin", ArithmeticStrategy.PRESERVE_FULL_PRECISION),
    ETH("Ξ", 18, "Ethereum", ArithmeticStrategy.PRESERVE_FULL_PRECISION);

    private final String symbol;
    private final int decimalPlaces; // For display formatting only
    private final String displayName;
    private final ArithmeticStrategy arithmeticStrategy;
    Currency(String symbol, int decimalPlaces, String displayName, ArithmeticStrategy arithmeticStrategy) {
        this.symbol = symbol;
        this.decimalPlaces = decimalPlaces;
        this.displayName = displayName;
        this.arithmeticStrategy =arithmeticStrategy;
    }
    public BigDecimal processArithmeticResult(BigDecimal result) {
        return arithmeticStrategy.processResult(result, this);
    }
    public String getSymbol() {
        return symbol;
    }

    public int getDecimalPlaces() {
        return decimalPlaces;
    }

    public String getDisplayName() {
        return displayName;
    }

    public boolean isFiat() {
        return this == USD || this == EUR || this == GBP || this == JPY;
    }

    public boolean isCrypto() {
        return this == BTC || this == ETH;
    }

    @Override
    public String toString() {
        return this.name();
    }
}=== ./shared/domain/Money.java ===
package core.ms.shared.domain;


import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

public class Money {
    private final BigDecimal amount;
    private final Currency currency;

    public Money(BigDecimal amount, Currency currency) {
        if (amount == null) {
            throw new IllegalArgumentException("Amount cannot be null");
        }
        if (currency == null) {
            throw new IllegalArgumentException("Currency cannot be null");
        }
        this.amount = amount; // Keep full precision - no rounding
        this.currency = currency;
    }

    public Money(String amount, Currency currency) {
        this(new BigDecimal(amount), currency);
    }

    // ===== ARITHMETIC OPERATIONS =====

    public Money add(Money other) {
        validateSameCurrency(other);
        BigDecimal result = amount.add(other.amount);
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    public Money subtract(Money other) {
        validateSameCurrency(other);
        BigDecimal result = amount.subtract(other.amount);
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    public Money multiply(BigDecimal scalar) {
        if (scalar == null) {
            throw new IllegalArgumentException("Scalar cannot be null");
        }
        BigDecimal result = amount.multiply(scalar);
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    public Money multiply(double scalar) {
        return multiply(BigDecimal.valueOf(scalar));
    }

    public Money divide(BigDecimal divisor) {
        if (divisor == null) {
            throw new IllegalArgumentException("Divisor cannot be null");
        }
        if (divisor.compareTo(BigDecimal.ZERO) == 0) {
            throw new IllegalArgumentException("Cannot divide by zero");
        }
        // First perform division with high precision
        BigDecimal result = amount.divide(divisor, 20, RoundingMode.HALF_UP);
        // Then apply currency-specific processing
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    public Money negate() {
        BigDecimal result = amount.negate();
        BigDecimal processedResult = currency.processArithmeticResult(result);
        return new Money(processedResult, currency);
    }

    // ===== COMPARISON OPERATIONS =====

    public boolean isGreaterThan(Money other) {
        validateSameCurrency(other);
        return amount.compareTo(other.amount) > 0;
    }

    public boolean isLessThan(Money other) {
        validateSameCurrency(other);
        return amount.compareTo(other.amount) < 0;
    }

    public boolean isGreaterThanOrEqual(Money other) {
        validateSameCurrency(other);
        return amount.compareTo(other.amount) >= 0;
    }

    public boolean isLessThanOrEqual(Money other) {
        validateSameCurrency(other);
        return amount.compareTo(other.amount) <= 0;
    }

    public boolean isZero() {
        return amount.compareTo(BigDecimal.ZERO) == 0;
    }

    public boolean isPositive() {
        return amount.compareTo(BigDecimal.ZERO) > 0;
    }

    public boolean isNegative() {
        return amount.compareTo(BigDecimal.ZERO) < 0;
    }

    // ===== GETTERS =====

    public BigDecimal getAmount() {
        return amount;
    }

    public Currency getCurrency() {
        return currency;
    }

    // ===== FORMATTING =====

    public String toDisplayString() {
        BigDecimal displayAmount = amount.setScale(currency.getDecimalPlaces(), RoundingMode.HALF_UP);
        return currency.getSymbol() + displayAmount.toPlainString();
    }

    public String toPlainString() {
        return amount.toPlainString() + " " + currency.name();
    }

    // ===== FACTORY METHODS =====

    public static Money zero(Currency currency) {
        return new Money(BigDecimal.ZERO, currency);
    }

    public static Money of(String amount, Currency currency) {
        return new Money(amount, currency);
    }

    public static Money of(BigDecimal amount, Currency currency) {
        return new Money(amount, currency);
    }

    public static Money usd(String amount) {
        return new Money(amount, Currency.USD);
    }

    public static Money eur(String amount) {
        return new Money(amount, Currency.EUR);
    }

    // ===== PRIVATE METHODS =====

    private void validateSameCurrency(Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException(
                    String.format("Cannot operate on different currencies: %s and %s",
                            currency, other.currency));
        }
    }


    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Money money = (Money) obj;
        return amount.compareTo(money.amount) == 0 && currency == money.currency;
    }

    @Override
    public int hashCode() {
        BigDecimal normalizedAmount = amount.stripTrailingZeros();
        return Objects.hash(normalizedAmount, currency);
    }

    @Override
    public String toString() {
        return toDisplayString();
    }
}
=== ./shared/utils/IdGenerator.java ===
package core.ms.shared.utils;

public class IdGenerator {
    private static final String TRANSACTION_PREFIX = "TX-";
    private static final String EVENT_PREFIX = "EVT-";

    /**
     * Generates unique transaction ID.
     */
    public String generateTransactionId() {
        return TRANSACTION_PREFIX + createUniqueId();
    }

    /**
     * Generates unique event ID.
     */
    public String generateEventId() {
        return EVENT_PREFIX + createUniqueId();
    }

    /**
     * Creates a unique identifier.
     */
    private String createUniqueId() {
        long timestamp = System.currentTimeMillis();
        int random = (int) (Math.random() * 10000);
        return timestamp + "-" + String.format("%04d", random);
    }
}=== ./security/service/TokenService.java ===
package core.ms.security.service;

import org.springframework.security.core.userdetails.UserDetails;

import java.util.Date;
import java.util.Map;

/**
 * Interface définissant les opérations de base pour la gestion des tokens d'authentification.
 * Cette interface est indépendante de l'implémentation spécifique (JWT, OAuth, etc.)
 */
public interface TokenService {

    /**
     * Génère un token pour un utilisateur
     * @param userDetails Les détails de l'utilisateur
     * @return Le token généré
     */
    String generateToken(UserDetails userDetails);

    /**
     * Génère un token avec des claims personnalisées
     * @param claims Les claims à inclure dans le token
     * @param subject Le sujet du token (généralement l'identifiant de l'utilisateur)
     * @return Le token généré
     */
    String generateToken(Map<String, Object> claims, String subject);

    /**
     * Extrait le nom d'utilisateur d'un token
     * @param token Le token à analyser
     * @return Le nom d'utilisateur extrait
     */
    String extractUsername(String token);

    /**
     * Extrait la date d'expiration d'un token
     * @param token Le token à analyser
     * @return La date d'expiration
     */
    Date extractExpiration(String token);

    /**
     * Vérifie si un token est valide pour un utilisateur donné
     * @param token Le token à valider
     * @param userDetails Les détails de l'utilisateur à vérifier
     * @return true si le token est valide, false sinon
     */
    boolean validateToken(String token, UserDetails userDetails);

    /**
     * Vérifie si un token est expiré
     * @param token Le token à vérifier
     * @return true si le token est expiré, false sinon
     */
    boolean isTokenExpired(String token);

    /**
     * Rafraîchit un token existant
     * @param token Le token à rafraîchir
     * @return Un nouveau token avec une nouvelle date d'expiration
     */
    String refreshToken(String token);
}=== ./security/service/AuthenticationService.java ===
package core.ms.security.service;

import core.ms.security.DTO.LoginRequestDTO;
import core.ms.security.DTO.TokenResponseDTO;

public interface AuthenticationService {
    /**
     * Authentifier un utilisateur et générer un token
     * @param loginRequest DTO avec les identifiants
     * @return DTO avec le token généré
     */
    TokenResponseDTO authenticate(LoginRequestDTO loginRequest);

    /**
     * Valider un token
     * @param token Token à valider
     * @return Nom d'utilisateur si valide
     */
    String validateToken(String token);

    /**
     * Rafraîchir un token
     * @param token Token à rafraîchir
     * @return DTO avec nouveau token
     */
    TokenResponseDTO refreshToken(String token);
}
=== ./security/service/AuthenticationServiceImpl.java ===
package core.ms.security.service;

import core.ms.security.DTO.LoginRequestDTO;
import core.ms.security.DTO.TokenResponseDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.beans.factory.annotation.Value;

@Service
public class AuthenticationServiceImpl implements AuthenticationService{
    @Autowired
    private MSUserService userService;

    @Autowired
    private TokenService tokenService;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Value("${jwt.expiration:86400000}")
    private long jwtExpiration;

    @Override
    public TokenResponseDTO authenticate(LoginRequestDTO loginRequest) {
        UserDetails userDetails = userService.loadUserByUsername(loginRequest.getUsername());

        // Vérifier le mot de passe
        if (!passwordEncoder.matches(loginRequest.getPassword(), userDetails.getPassword())) {
            throw new BadCredentialsException("Mot de passe incorrect");
        }

        // Générer le token
        String token = tokenService.generateToken(userDetails);

        // Retourner la réponse
        return new TokenResponseDTO(token, jwtExpiration / 1000);
    }

    @Override
    public String validateToken(String token) {
        String username = tokenService.extractUsername(token);
        UserDetails userDetails = userService.loadUserByUsername(username);

        if (tokenService.validateToken(token, userDetails)) {
            return username;
        } else {
            throw new BadCredentialsException("Token invalide");
        }
    }

    @Override
    public TokenResponseDTO refreshToken(String token) {
        // Valider le token actuel
        String username = tokenService.extractUsername(token);
        UserDetails userDetails = userService.loadUserByUsername(username);

        if (!tokenService.validateToken(token, userDetails)) {
            throw new BadCredentialsException("Token invalide");
        }

        // Rafraîchir le token
        String refreshedToken = tokenService.refreshToken(token);
        return new TokenResponseDTO(refreshedToken, jwtExpiration / 1000);
    }
}
=== ./security/service/MSUserService.java ===
package core.ms.security.service;

import org.springframework.beans.factory.annotation.Autowired;
import core.ms.security.domain.MSUser;
import core.ms.security.domain.MSUserRole;
import core.ms.security.exception.UsernameAlreadyExistException;
import core.ms.security.DAO.MSUserDAO;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.stereotype.Service;
import java.util.HashSet;
import java.util.Optional;


@Service
public class MSUserService implements UserDetailsService {
    @Autowired
    MSUserDAO repository;

    @Autowired
    PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<MSUser> optMSUser = repository.findById(username);

        if(optMSUser.isPresent()){
            MSUser msUser = optMSUser.get();
            UserBuilder builder =
                        User.builder()
                            .username(msUser.getUsername())
                            .password(msUser.getUserPassword());
            HashSet<String> roles = new HashSet<>();
            switch (msUser.getRole()){
                case GUEST:
                    roles.add("GUEST");
                    break;
                case ADMIN:
                    roles.add("ADMIN");
                    break;
                case CUSTOMER:
                    roles.add("CUSTOMER");
                    break;
            }
            builder.roles(roles.toArray(new String[roles.size()]));
            UserDetails details = builder.build();
            return details;
        }else {
            throw new UsernameNotFoundException(username);
        }

    }
    public MSUser createUser(String username, String password, MSUserRole userRole) throws UsernameAlreadyExistException {
        if(repository.existsById(username)){
            throw new UsernameAlreadyExistException();
        }
        String encodedPassword = passwordEncoder.encode(password);
        MSUser newUser = new MSUser(username, MSUserRole.CUSTOMER, encodedPassword);
        return repository.save(newUser);
    }

}
=== ./security/service/TokenServiceImpl.java ===
package core.ms.security.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.SignatureAlgorithm;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Value;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
public class TokenServiceImpl implements TokenService {
    @Value("${jwt.secret:defaultSecretKeyThatShouldBeVeryLongAndSecureForProduction}")
    private String secretKey;

    @Value("${jwt.expiration:86400000}")
    private long jwtExpiration;


    @Override
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
       //Extraire les rôles des autorités
        String roles = userDetails.getAuthorities()
                .stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));
        claims.put("roles", roles);
        return generateToken(claims, userDetails.getUsername());
    }

    @Override
    public String generateToken(Map<String,Object> claims, String subject){
        Date now = new Date();
        Date expiration = new Date(now.getTime() + this.jwtExpiration);

        //Utilisation de Keys pour générer pour une clé sécurisée
        Key key = Keys.hmacShaKeyFor(secretKey.getBytes());

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(now)
                .setExpiration(expiration)
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();
    }
    private Claims extractAllClaims(String token){
        Key key = Keys.hmacShaKeyFor(secretKey.getBytes());

        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver){
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    @Override
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    @Override
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    @Override
    public boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    @Override
    public boolean isTokenExpired(String token) {
        final Date expiration = extractExpiration(token);
        return expiration.before(new Date());
    }

    @Override
    public String refreshToken(String token) {
        if(isTokenExpired(token)) {
            throw new IllegalArgumentException("Le token est expiré");
        }

        Claims claims = extractAllClaims(token);
        String subject = claims.getSubject();

        claims.remove(Claims.EXPIRATION);
        claims.remove(Claims.ISSUED_AT);

        return generateToken(claims,subject);
    }

}
=== ./security/DTO/TokenResponseDTO.java ===
package core.ms.security.DTO;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TokenResponseDTO {
    private String token;
    private long expiresIn;

    public TokenResponseDTO(String token, long expiresIn) {
        this.token = token;
        this.expiresIn = expiresIn;
    }

    private String tokenType="Bearer";

}
=== ./security/DTO/LoginRequestDTO.java ===
package core.ms.security.DTO;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class LoginRequestDTO {
    private String username;
    private String password;

    public LoginRequestDTO(String username, String password) {
        this.username = username;
        this.password = password;
    }

}
=== ./security/domain/MSUserRole.java ===
package core.ms.security.domain;

public enum MSUserRole {
    CUSTOMER,
    GUEST,
    ADMIN
}
=== ./security/domain/MSUser.java ===
package core.ms.security.domain;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;

@Entity
public class MSUser {
    @Setter
    @Getter
    @Id
    @Size(max = 20)
    @Column(name = "username")
    @NotBlank
    private String username;

    @Setter
    @Getter
    @Size(max = 500)
    @Column(name = "userpassword")
    @NotBlank
    private String userPassword;

    @Column(name = "userrole", length = 20)
    @NotNull
    private String userRoleStr;

    protected MSUser() { super(); }

    public MSUser(@Size(max = 20) @NotBlank String username, @NotNull MSUserRole role) {
        this.username = username;
        setRole(role);
    }

    public MSUser(@Size(max = 20) @NotBlank String username, @NotNull MSUserRole role, @NotBlank String password) {
        this.username = username;
        setRole(role);
        this.userPassword = password;
    }

    public MSUserRole getRole() {
        return MSUserRole.valueOf(userRoleStr);
    }

    public void setRole(MSUserRole role) {
        this.userRoleStr = role.name();
    }
}=== ./security/ui/AuthController.java ===
package core.ms.security.ui;

import core.ms.security.DTO.LoginRequestDTO;
import core.ms.security.DTO.TokenResponseDTO;
import core.ms.security.domain.MSUserRole;
import core.ms.security.exception.UsernameAlreadyExistException;
import core.ms.security.service.AuthenticationService;
import core.ms.security.service.MSUserService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

@RestController
public class AuthController {

    @Autowired
    private AuthenticationService authService;

    @Autowired
    private MSUserService userService;

    @PostMapping("/login")
    public ResponseEntity<TokenResponseDTO> login(@Valid @RequestBody LoginRequestDTO loginRequest) {
        try {
            TokenResponseDTO response = authService.authenticate(loginRequest);
            return ResponseEntity.ok(response);
        } catch (BadCredentialsException e) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Identifiants invalides", e);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR,
                    "Erreur lors de l'authentification: " + e.getMessage(), e);
        }
    }

    @PostMapping("/register")
    public ResponseEntity<String> register(@Valid @RequestBody LoginRequestDTO registerRequest) {
        System.out.println("Register request received: " + registerRequest.getUsername());

        try {
            userService.createUser(
                    registerRequest.getUsername(),
                    registerRequest.getPassword(),
                    MSUserRole.CUSTOMER
            );
            return ResponseEntity.status(HttpStatus.CREATED).body("Utilisateur créé avec succès");
        } catch (UsernameAlreadyExistException e) {
            throw new ResponseStatusException(
                    HttpStatus.CONFLICT, "Ce nom d'utilisateur existe déjà", e);
        } catch (Exception e) {
            throw new ResponseStatusException(
                    HttpStatus.INTERNAL_SERVER_ERROR, "Erreur lors de la création de l'utilisateur", e);
        }
    }



    @PostMapping("/refresh")
    public ResponseEntity<TokenResponseDTO> refreshToken(@RequestParam String token) {
        try {
            TokenResponseDTO response = authService.refreshToken(token);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            throw new ResponseStatusException(
                    HttpStatus.UNAUTHORIZED, "Impossible de rafraîchir le token: " + e.getMessage(), e);
        }
    }
}
=== ./security/DAO/MSUserDAO.java ===
package core.ms.security.DAO;

import core.ms.security.domain.MSUser;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MSUserDAO extends JpaRepository<MSUser, String> {
}
=== ./security/exception/UsernameAlreadyExistException.java ===
package core.ms.security.exception;

public class UsernameAlreadyExistException extends Exception{
}
=== ./config/AuthentificationConfig.java ===
package core.ms.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;

@Configuration
public class AuthentificationConfig {
    @Bean
    public PasswordEncoder passwordEncoder() { return PasswordEncoderFactories.createDelegatingPasswordEncoder();}
}
=== ./config/SecurityConfig.java ===
package core.ms.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.web.SecurityFilterChain;

import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Value("${jwt.secret:defaultSecretKeyThatShouldBeVeryLongAndSecureForProduction}")
    private String secretKey;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())  // Disable CSRF for API endpoints
                .authorizeHttpRequests((authorize) -> authorize
                        // Allow public access to authentication endpoints
                        .requestMatchers("/login", "/register", "/validate", "/refresh").permitAll()
                        // Allow H2 console if needed
                        .requestMatchers("/h2-console/**").permitAll()
                        // All other requests must be authenticated
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .oauth2ResourceServer((oauth2) -> oauth2
                        .jwt(Customizer.withDefaults())
                );

        // Optional: Enable frame options for H2 console
        http.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin()));

        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        // Use the same secret key used to sign tokens
        byte[] keyBytes = secretKey.getBytes(StandardCharsets.UTF_8);
        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, "HmacSHA256");

        return NimbusJwtDecoder.withSecretKey(secretKeySpec).build();
    }
}=== ./MsApplication.java ===
package core.ms;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MsApplication {

    public static void main(String[] args) {
        SpringApplication.run(MsApplication.class, args);
    }

}
