=== ./domain/ChartMetadata.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Symbol;

import java.util.Objects;

/**
 * Value object containing metadata for chart display
 */
public class ChartMetadata {
    private final Symbol symbol;
    private final TimeInterval interval;
    private final DateRange dateRange;
    private final int totalCandles;
    private final PriceRange priceRange;
    private final VolumeRange volumeRange;

    public ChartMetadata(Symbol symbol, TimeInterval interval, DateRange dateRange,
                         int totalCandles, PriceRange priceRange, VolumeRange volumeRange) {
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.interval = Objects.requireNonNull(interval, "Interval cannot be null");
        this.dateRange = dateRange; // Can be null for empty data
        this.totalCandles = totalCandles;
        this.priceRange = priceRange; // Can be null for empty data
        this.volumeRange = volumeRange; // Can be null for empty data

        if (totalCandles < 0) {
            throw new IllegalArgumentException("Total candles cannot be negative");
        }
    }

    public Symbol getSymbol() { return symbol; }
    public TimeInterval getInterval() { return interval; }
    public DateRange getDateRange() { return dateRange; }
    public int getTotalCandles() { return totalCandles; }
    public PriceRange getPriceRange() { return priceRange; }
    public VolumeRange getVolumeRange() { return volumeRange; }

    public boolean hasData() {
        return totalCandles > 0;
    }

    @Override
    public String toString() {
        return String.format("ChartMetadata[%s %s, %d candles, %s]",
                symbol.getCode(), interval.getCode(), totalCandles,
                dateRange != null ? dateRange.toString() : "no data");
    }
}=== ./domain/VolumeRange.java ===
package core.ms.OHLC.domain;

import java.math.BigDecimal;
import java.util.Objects;

/**
 * Value object representing a volume range
 */
public class VolumeRange {
    private final BigDecimal min;
    private final BigDecimal max;
    private final BigDecimal average;

    public VolumeRange(BigDecimal min, BigDecimal max, BigDecimal average) {
        this.min = Objects.requireNonNull(min, "Min volume cannot be null");
        this.max = Objects.requireNonNull(max, "Max volume cannot be null");
        this.average = Objects.requireNonNull(average, "Average volume cannot be null");

        if (min.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Min volume cannot be negative");
        }
        if (max.compareTo(min) < 0) {
            throw new IllegalArgumentException("Max volume must be >= min volume");
        }
        if (average.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Average volume cannot be negative");
        }
    }

    public BigDecimal getMin() { return min; }
    public BigDecimal getMax() { return max; }
    public BigDecimal getAverage() { return average; }

    public BigDecimal getRange() {
        return max.subtract(min);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        VolumeRange that = (VolumeRange) obj;
        return Objects.equals(min, that.min) &&
                Objects.equals(max, that.max) &&
                Objects.equals(average, that.average);
    }

    @Override
    public int hashCode() {
        return Objects.hash(min, max, average);
    }

    @Override
    public String toString() {
        return String.format("VolumeRange[min:%s, max:%s, avg:%s]",
                min.toPlainString(), max.toPlainString(), average.toPlainString());
    }
}=== ./domain/OHLCChartSeries.java ===
package core.ms.OHLC.domain;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Implementation of ChartSeries for OHLC data
 */
public class OHLCChartSeries implements ChartSeries {
    private final String id;
    private final String name;
    private final String symbol;
    private final String interval;
    private final List<ChartData> data;

    public OHLCChartSeries(String id, String name, String symbol, String interval, List<ChartData> data) {
        this.id = Objects.requireNonNull(id, "ID cannot be null");
        this.name = Objects.requireNonNull(name, "Name cannot be null");
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.interval = Objects.requireNonNull(interval, "Interval cannot be null");
        this.data = new ArrayList<>(Objects.requireNonNull(data, "Data cannot be null"));
    }

    @Override
    public String getId() { return id; }

    @Override
    public String getName() { return name; }

    @Override
    public String getSymbol() { return symbol; }

    @Override
    public String getInterval() { return interval; }

    @Override
    public List<ChartData> getData() { return new ArrayList<>(data); }

    @Override
    public boolean isEmpty() { return data.isEmpty(); }

    @Override
    public int size() { return data.size(); }

    @Override
    public String toString() {
        return String.format("ChartSeries[%s: %s, %d points]", id, name, data.size());
    }
}=== ./domain/OHLCDataFactory.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import core.ms.utils.IdGenerator;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Factory for creating OHLC domain objects from transaction data
 */
public class OHLCDataFactory {

    private static final IdGenerator ID_GENERATOR = new IdGenerator();

    /**
     * Creates OHLCData from a list of transactions
     */
    public static OHLCData createFromTransactions(Symbol symbol, TimeInterval interval,
                                                  List<TransactionData> transactions) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        Objects.requireNonNull(interval, "Interval cannot be null");
        Objects.requireNonNull(transactions, "Transactions cannot be null");

        String ohlcDataId = generateOHLCDataId(symbol, interval);
        OHLCData ohlcData = new OHLCData(ohlcDataId, symbol, interval);

        if (transactions.isEmpty()) {
            return ohlcData;
        }

        // Group transactions by interval periods
        Map<Instant, List<TransactionData>> groupedTransactions = groupTransactionsByInterval(transactions, interval);

        // Create candlesticks for each period
        for (Map.Entry<Instant, List<TransactionData>> entry : groupedTransactions.entrySet()) {
            Instant intervalStart = entry.getKey();
            List<TransactionData> intervalTransactions = entry.getValue();

            Candlestick candlestick = createCandlestick(symbol, interval, intervalStart, intervalTransactions);
            ohlcData.addCandle(candlestick);
        }

        return ohlcData;
    }

    /**
     * Creates a single candlestick from transactions within a time period
     */
    public static Candlestick createCandlestick(Symbol symbol, TimeInterval interval,
                                                Instant timestamp, List<TransactionData> transactions) {
        Objects.requireNonNull(symbol, "Symbol cannot be null");
        Objects.requireNonNull(interval, "Interval cannot be null");
        Objects.requireNonNull(timestamp, "Timestamp cannot be null");
        Objects.requireNonNull(transactions, "Transactions cannot be null");

        if (transactions.isEmpty()) {
            throw new IllegalArgumentException("Cannot create candlestick from empty transactions");
        }

        // Validate all transactions are for the same symbol
        validateTransactionsSymbol(transactions, symbol);

        // Calculate OHLC and volume
        OHLC ohlc = calculateOHLC(transactions);
        BigDecimal volume = calculateVolume(transactions);

        // Align timestamp to interval boundary
        Instant alignedTimestamp = interval.alignTimestamp(timestamp);

        String candlestickId = generateCandlestickId(symbol, interval, alignedTimestamp);

        return new Candlestick(
                candlestickId,
                symbol,
                alignedTimestamp,
                interval,
                ohlc.getOpen(),
                ohlc.getHigh(),
                ohlc.getLow(),
                ohlc.getClose(),
                volume
        );
    }

    /**
     * Aggregates multiple transactions into OHLC values
     */
    public static OHLC aggregateTransactions(List<TransactionData> transactions) {
        Objects.requireNonNull(transactions, "Transactions cannot be null");

        if (transactions.isEmpty()) {
            throw new IllegalArgumentException("Cannot aggregate empty transactions");
        }

        return calculateOHLC(transactions);
    }

    /**
     * Creates metadata for OHLCData
     */
    public static ChartMetadata createMetadata(OHLCData ohlcData) {
        Objects.requireNonNull(ohlcData, "OHLCData cannot be null");

        Optional<DateRange> dateRange = ohlcData.getDateRange();
        Optional<Money> highestPrice = ohlcData.getHighestPrice();
        Optional<Money> lowestPrice = ohlcData.getLowestPrice();

        PriceRange priceRange = null;
        if (highestPrice.isPresent() && lowestPrice.isPresent()) {
            priceRange = new PriceRange(lowestPrice.get(), highestPrice.get());
        }

        VolumeRange volumeRange = createVolumeRange(ohlcData);

        return new ChartMetadata(
                ohlcData.getSymbol(),
                ohlcData.getInterval(),
                dateRange.orElse(null),
                ohlcData.size(),
                priceRange,
                volumeRange
        );
    }

    /**
     * Creates a price range from a list of candlesticks
     */
    public static PriceRange createPriceRange(List<Candlestick> candles) {
        Objects.requireNonNull(candles, "Candles cannot be null");

        if (candles.isEmpty()) {
            throw new IllegalArgumentException("Cannot create price range from empty candles");
        }

        Money min = candles.stream()
                .map(Candlestick::getLow)
                .reduce((money1, money2) -> money1.isLessThan(money2) ? money1 : money2)
                .orElseThrow(() -> new IllegalStateException("No minimum price found"));

        Money max = candles.stream()
                .map(Candlestick::getHigh)
                .reduce((money1, money2) -> money1.isGreaterThan(money2) ? money1 : money2)
                .orElseThrow(() -> new IllegalStateException("No maximum price found"));

        return new PriceRange(min, max);
    }

    /**
     * Creates a volume range from OHLCData
     */
    public static VolumeRange createVolumeRange(OHLCData ohlcData) {
        Objects.requireNonNull(ohlcData, "OHLCData cannot be null");

        List<Candlestick> candles = ohlcData.getAllCandles();

        if (candles.isEmpty()) {
            return new VolumeRange(BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO);
        }

        BigDecimal minVolume = candles.stream()
                .map(Candlestick::getVolume)
                .min(BigDecimal::compareTo)
                .orElse(BigDecimal.ZERO);

        BigDecimal maxVolume = candles.stream()
                .map(Candlestick::getVolume)
                .max(BigDecimal::compareTo)
                .orElse(BigDecimal.ZERO);

        BigDecimal avgVolume = ohlcData.getAverageVolume();

        return new VolumeRange(minVolume, maxVolume, avgVolume);
    }

    // ===== PRIVATE HELPER METHODS =====

    private static Map<Instant, List<TransactionData>> groupTransactionsByInterval(
            List<TransactionData> transactions, TimeInterval interval) {

        return transactions.stream()
                .collect(Collectors.groupingBy(
                        transaction -> interval.alignTimestamp(transaction.getTimestamp()),
                        TreeMap::new, // Keep sorted by timestamp
                        Collectors.toList()
                ));
    }

    private static OHLC calculateOHLC(List<TransactionData> transactions) {
        // Sort transactions by timestamp to get proper sequence
        List<TransactionData> sortedTransactions = transactions.stream()
                .sorted(Comparator.comparing(TransactionData::getTimestamp))
                .collect(Collectors.toList());

        // First transaction provides the open price
        Money open = sortedTransactions.get(0).getPrice();

        // Last transaction provides the close price
        Money close = sortedTransactions.get(sortedTransactions.size() - 1).getPrice();

        // Find highest and lowest prices
        Money high = sortedTransactions.stream()
                .map(TransactionData::getPrice)
                .reduce(open, (money1, money2) -> money1.isGreaterThan(money2) ? money1 : money2);

        Money low = sortedTransactions.stream()
                .map(TransactionData::getPrice)
                .reduce(open, (money1, money2) -> money1.isLessThan(money2) ? money1 : money2);

        return new OHLC(open, high, low, close);
    }

    private static BigDecimal calculateVolume(List<TransactionData> transactions) {
        return transactions.stream()
                .map(TransactionData::getQuantity)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private static void validateTransactionsSymbol(List<TransactionData> transactions, Symbol expectedSymbol) {
        boolean allMatch = transactions.stream()
                .allMatch(transaction -> transaction.getSymbol().equals(expectedSymbol));

        if (!allMatch) {
            throw new IllegalArgumentException("All transactions must be for the same symbol: " + expectedSymbol.getCode());
        }
    }

    private static String generateOHLCDataId(Symbol symbol, TimeInterval interval) {
        return String.format("OHLC-%s-%s-%d",
                symbol.getCode(),
                interval.getCode(),
                System.currentTimeMillis());
    }

    private static String generateCandlestickId(Symbol symbol, TimeInterval interval, Instant timestamp) {
        return String.format("CANDLE-%s-%s-%d",
                symbol.getCode(),
                interval.getCode(),
                timestamp.getEpochSecond());
    }
}

// ===== USAGE EXAMPLE =====

/*
// Example usage in an application service:

@Service
public class OHLCUpdateService {

    @EventHandler
    public void handleTransactionCreated(TransactionCreatedEvent event) {
        ITransaction transaction = event.getTransaction();

        // Convert to TransactionData
        TransactionData transactionData = new TransactionData(
            transaction.getCreatedAt(),
            transaction.getPrice(),
            transaction.getQuantity(),
            transaction.getSymbol()
        );

        // Get or create OHLCData
        OHLCData ohlcData = ohlcRepository.findBySymbolAndInterval(
            transaction.getSymbol(),
            TimeInterval.ONE_MINUTE
        ).orElseGet(() -> new OHLCData(
            IdGenerator.generateId(),
            transaction.getSymbol(),
            TimeInterval.ONE_MINUTE
        ));

        // Create candlestick from this transaction
        Instant intervalTimestamp = TimeInterval.ONE_MINUTE.alignTimestamp(transaction.getCreatedAt());

        // In real implementation, you'd collect all transactions for this interval
        List<TransactionData> intervalTransactions = List.of(transactionData);

        Candlestick candlestick = OHLCDataFactory.createCandlestick(
            transaction.getSymbol(),
            TimeInterval.ONE_MINUTE,
            intervalTimestamp,
            intervalTransactions
        );

        ohlcData.addCandle(candlestick);
        ohlcRepository.save(ohlcData);
    }
}
*/=== ./domain/OHLCData.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Aggregate root for managing collections of candlesticks
 * This was missing from the original implementation!
 */
public class OHLCData {
    private final String id;
    private final Symbol symbol;
    private final TimeInterval interval;
    private final List<Candlestick> candlesticks;
    private Instant lastUpdated;

    public OHLCData(String id, Symbol symbol, TimeInterval interval) {
        this.id = Objects.requireNonNull(id, "ID cannot be null");
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.interval = Objects.requireNonNull(interval, "Interval cannot be null");
        this.candlesticks = new ArrayList<>();
        this.lastUpdated = Instant.now();
    }

    // ===== GETTERS =====

    public String getId() { return id; }
    public Symbol getSymbol() { return symbol; }
    public TimeInterval getInterval() { return interval; }
    public List<Candlestick> getAllCandles() { return new ArrayList<>(candlesticks); }
    public boolean isEmpty() { return candlesticks.isEmpty(); }
    public int size() { return candlesticks.size(); }
    public Instant getLastUpdated() { return lastUpdated; }

    // ===== AGGREGATE OPERATIONS =====

    /**
     * Adds a new candlestick to this collection
     */
    public void addCandle(Candlestick candle) {
        Objects.requireNonNull(candle, "Candlestick cannot be null");
        validateCandle(candle);

        candlesticks.add(candle);
        sortCandlesByTimestamp();
        lastUpdated = Instant.now();
    }

    /**
     * Gets candlesticks within a specific time range
     */
    public List<Candlestick> getCandlesByTimeRange(Instant startTime, Instant endTime) {
        Objects.requireNonNull(startTime, "Start time cannot be null");
        Objects.requireNonNull(endTime, "End time cannot be null");

        if (startTime.isAfter(endTime)) {
            throw new IllegalArgumentException("Start time must be before or equal to end time");
        }

        return candlesticks.stream()
                .filter(candle -> !candle.getTimestamp().isBefore(startTime) &&
                        !candle.getTimestamp().isAfter(endTime))
                .sorted(Comparator.comparing(Candlestick::getTimestamp))
                .collect(Collectors.toList());
    }

    /**
     * Gets the latest (most recent) candlestick
     */
    public Optional<Candlestick> getLatestCandle() {
        return candlesticks.stream()
                .max(Comparator.comparing(Candlestick::getTimestamp));
    }

    // ===== QUERY METHODS =====

    public String getSymbolCode() {
        return symbol.getCode();
    }

    /**
     * Gets the date range covered by this data
     */
    public Optional<DateRange> getDateRange() {
        if (candlesticks.isEmpty()) {
            return Optional.empty();
        }

        Instant earliest = candlesticks.stream()
                .min(Comparator.comparing(Candlestick::getTimestamp))
                .map(Candlestick::getTimestamp)
                .orElse(Instant.now());

        Instant latest = candlesticks.stream()
                .max(Comparator.comparing(Candlestick::getTimestamp))
                .map(Candlestick::getTimestamp)
                .orElse(Instant.now());

        return Optional.of(new DateRange(earliest, latest));
    }

    /**
     * Gets the highest price across all candlesticks
     */
    public Optional<Money> getHighestPrice() {
        return candlesticks.stream()
                .map(Candlestick::getHigh)
                .reduce((money1, money2) -> money1.isGreaterThan(money2) ? money1 : money2);
    }

    /**
     * Gets the lowest price across all candlesticks
     */
    public Optional<Money> getLowestPrice() {
        return candlesticks.stream()
                .map(Candlestick::getLow)
                .reduce((money1, money2) -> money1.isLessThan(money2) ? money1 : money2);
    }

    /**
     * Gets the average volume across all candlesticks
     */
    public BigDecimal getAverageVolume() {
        if (candlesticks.isEmpty()) {
            return BigDecimal.ZERO;
        }

        BigDecimal totalVolume = candlesticks.stream()
                .map(Candlestick::getVolume)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        return totalVolume.divide(new BigDecimal(candlesticks.size()), 2, java.math.RoundingMode.HALF_UP);
    }

    // ===== CHART CONVERSION =====

    /**
     * Converts this data to a chart series
     */
    public ChartSeries toChartSeries() {
        List<ChartData> chartDataList = candlesticks.stream()
                .sorted(Comparator.comparing(Candlestick::getTimestamp))
                .map(Candlestick::toChartData)
                .collect(Collectors.toList());

        return new OHLCChartSeries(
                id,
                symbol.getCode() + " " + interval.getCode(),
                symbol.getCode(),
                interval.getCode(),
                chartDataList
        );
    }

    // ===== VALIDATION =====

    private void validateCandle(Candlestick candle) {
        if (!candle.getSymbol().equals(this.symbol)) {
            throw new IllegalArgumentException("Candlestick symbol must match OHLCData symbol");
        }
        if (!candle.getInterval().equals(this.interval)) {
            throw new IllegalArgumentException("Candlestick interval must match OHLCData interval");
        }
    }

    private void sortCandlesByTimestamp() {
        candlesticks.sort(Comparator.comparing(Candlestick::getTimestamp));
    }

    // ===== OBJECT METHODS =====

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        OHLCData ohlcData = (OHLCData) obj;
        return Objects.equals(id, ohlcData.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("OHLCData[%s: %s %s, %d candlesticks, updated: %s]",
                id, symbol.getCode(), interval.getCode(), candlesticks.size(), lastUpdated);
    }
}=== ./domain/TimeInterval.java ===
package core.ms.OHLC.domain;

import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;

public enum TimeInterval {
    ONE_MINUTE("1m", Duration.ofMinutes(1)),
    FIVE_MINUTES("5m", Duration.ofMinutes(5)),
    FIFTEEN_MINUTES("15m", Duration.ofMinutes(15)),
    THIRTY_MINUTES("30m", Duration.ofMinutes(30)),
    ONE_HOUR("1h", Duration.ofHours(1)),
    FOUR_HOURS("4h", Duration.ofHours(4)),
    ONE_DAY("1d", Duration.ofDays(1)),
    ONE_WEEK("1w", Duration.ofDays(7)),
    ONE_MONTH("1M", Duration.ofDays(30)); // Approximate

    private final String code;
    private final Duration duration;

    TimeInterval(String code, Duration duration) {
        this.code = code;
        this.duration = duration;
    }

    // ===== GETTERS =====

    public String getCode() { return code; }
    public Duration getDuration() { return duration; }
    public long getMilliseconds() { return duration.toMillis(); }

    // ===== BUSINESS METHODS =====

    public boolean isHigherThan(TimeInterval other) {
        return this.duration.compareTo(other.duration) > 0;
    }

    public boolean isLowerThan(TimeInterval other) {
        return this.duration.compareTo(other.duration) < 0;
    }

    /**
     * Aligns a timestamp to the interval boundary
     * For example, 14:23:45 with 1h interval becomes 14:00:00
     */
    public Instant alignTimestamp(Instant timestamp) {
        long epochSecond = timestamp.getEpochSecond();
        long intervalSeconds = duration.getSeconds();
        long alignedSeconds = (epochSecond / intervalSeconds) * intervalSeconds;
        return Instant.ofEpochSecond(alignedSeconds);
    }

    /**
     * Gets the next interval timestamp
     */
    public Instant getNextTimestamp(Instant current) {
        Instant aligned = alignTimestamp(current);
        return aligned.plus(duration);
    }

    /**
     * Gets the previous interval timestamp
     */
    public Instant getPreviousTimestamp(Instant current) {
        Instant aligned = alignTimestamp(current);
        return aligned.minus(duration);
    }

    @Override
    public String toString() {
        return code;
    }
}
=== ./domain/OHLCChartData.java ===
package core.ms.OHLC.domain;

public class OHLCChartData implements ChartData {
    private final long time;
    private final double open;
    private final double high;
    private final double low;
    private final double close;
    private final double volume;

    public OHLCChartData(long time, double open, double high, double low, double close, double volume) {
        this.time = time;
        this.open = open;
        this.high = high;
        this.low = low;
        this.close = close;
        this.volume = volume;
    }

    @Override
    public long getTime() { return time; }
    @Override
    public double getOpen() { return open; }
    @Override
    public double getHigh() { return high; }
    @Override
    public double getLow() { return low; }
    @Override
    public double getClose() { return close; }
    @Override
    public double getVolume() { return volume; }

    @Override
    public String toString() {
        return String.format("ChartData[%d: O:%.2f H:%.2f L:%.2f C:%.2f V:%.2f]",
                time, open, high, low, close, volume);
    }
}=== ./domain/DateRange.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.Duration;
import java.time.Instant;
import java.util.Objects;

/**
 * Value object representing a date range
 */
public class DateRange {
    private final Instant start;
    private final Instant end;

    public DateRange(Instant start, Instant end) {
        this.start = Objects.requireNonNull(start, "Start time cannot be null");
        this.end = Objects.requireNonNull(end, "End time cannot be null");

        if (start.isAfter(end)) {
            throw new IllegalArgumentException("Start time must be before or equal to end time");
        }
    }

    public Instant getStart() { return start; }
    public Instant getEnd() { return end; }

    public Duration getDuration() {
        return Duration.between(start, end);
    }

    public boolean contains(Instant timestamp) {
        Objects.requireNonNull(timestamp, "Timestamp cannot be null");
        return !timestamp.isBefore(start) && !timestamp.isAfter(end);
    }

    public boolean overlaps(DateRange other) {
        Objects.requireNonNull(other, "Other date range cannot be null");
        return start.isBefore(other.end) && end.isAfter(other.start);
    }

    public DateRange expand(Duration duration) {
        Objects.requireNonNull(duration, "Duration cannot be null");
        return new DateRange(start.minus(duration), end.plus(duration));
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        DateRange dateRange = (DateRange) obj;
        return Objects.equals(start, dateRange.start) && Objects.equals(end, dateRange.end);
    }

    @Override
    public int hashCode() {
        return Objects.hash(start, end);
    }

    @Override
    public String toString() {
        return String.format("DateRange[%s to %s]", start, end);
    }
}=== ./domain/Candlestick.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import core.ms.utils.BigDecimalNormalizer;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.Objects;

/**
 * Core domain entity representing a single candlestick for chart data
 */
public class Candlestick {
    private final String id;
    private final Symbol symbol;
    private final Instant timestamp;
    private final TimeInterval interval;
    private final Money open;
    private final Money high;
    private final Money low;
    private final Money close;
    private final BigDecimal volume;

    public Candlestick(String id, Symbol symbol, Instant timestamp, TimeInterval interval,
                       Money open, Money high, Money low, Money close, BigDecimal volume) {
        this.id = Objects.requireNonNull(id, "ID cannot be null");
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");
        this.timestamp = Objects.requireNonNull(timestamp, "Timestamp cannot be null");
        this.interval = Objects.requireNonNull(interval, "Interval cannot be null");
        this.open = Objects.requireNonNull(open, "Open price cannot be null");
        this.high = Objects.requireNonNull(high, "High price cannot be null");
        this.low = Objects.requireNonNull(low, "Low price cannot be null");
        this.close = Objects.requireNonNull(close, "Close price cannot be null");
        this.volume = Objects.requireNonNull(volume, "Volume cannot be null");

        validateOHLC();
        validatePriceCurrency();
        validateVolume();
    }

    // ===== GETTERS =====
    public String getId() { return id; }
    public Symbol getSymbol() { return symbol; }
    public Instant getTimestamp() { return timestamp; }
    public TimeInterval getInterval() { return interval; }
    public Money getOpen() { return open; }
    public Money getHigh() { return high; }
    public Money getLow() { return low; }
    public Money getClose() { return close; }
    public BigDecimal getVolume() { return BigDecimalNormalizer.normalize(volume); }

    // ===== BUSINESS LOGIC METHODS =====

    /**
     * Returns true if this is a bullish (green) candle
     */
    public boolean isBullish() {
        return close.isGreaterThan(open);
    }

    /**
     * Returns true if this is a bearish (red) candle
     */
    public boolean isBearish() {
        return close.isLessThan(open);
    }

    /**
     * Returns true if this is a doji (open equals close)
     */
    public boolean isDoji() {
        return close.equals(open);
    }

    /**
     * Returns the size of the candle body (absolute difference between open and close)
     */
    public Money getBodySize() {
        return close.subtract(open).abs();
    }

    /**
     * Returns the total range of the candle (high minus low)
     */
    public Money getRange() {
        return high.subtract(low);
    }

    /**
     * Returns the upper shadow length
     */
    public Money getUpperShadow() {
        Money topPrice = isBullish() ? close : open;
        return high.subtract(topPrice);
    }

    /**
     * Returns the lower shadow length
     */
    public Money getLowerShadow() {
        Money bottomPrice = isBullish() ? open : close;
        return bottomPrice.subtract(low);
    }

    /**
     * Returns the typical price (high + low + close) / 3
     */
    public Money getTypicalPrice() {
        Money sum = high.add(low).add(close);
        return sum.divide(new BigDecimal("3"));
    }

    /**
     * Returns the weighted price considering volume
     */
    public Money getWeightedPrice() {
        if (volume.compareTo(BigDecimal.ZERO) == 0) {
            return getTypicalPrice();
        }
        Money totalValue = getTypicalPrice().multiply(volume);
        return totalValue.divide(volume);
    }

    // ===== CHART CONVERSION =====

    /**
     * Converts this candlestick to chart data format
     */
    public ChartData toChartData() {
        return new OHLCChartData(
                timestamp.getEpochSecond(),
                open.getAmount().doubleValue(),
                high.getAmount().doubleValue(),
                low.getAmount().doubleValue(),
                close.getAmount().doubleValue(),
                volume.doubleValue()
        );
    }

    // ===== VALIDATION =====

    private void validateOHLC() {
        if (high.isLessThan(low)) {
            throw new IllegalArgumentException("High price must be >= Low price");
        }
        if (open.isGreaterThan(high) || open.isLessThan(low)) {
            throw new IllegalArgumentException("Open price must be between High and Low");
        }
        if (close.isGreaterThan(high) || close.isLessThan(low)) {
            throw new IllegalArgumentException("Close price must be between High and Low");
        }
    }

    private void validatePriceCurrency() {
        Currency expectedCurrency = symbol.getQuoteCurrency();
        if (!open.getCurrency().equals(expectedCurrency) ||
                !high.getCurrency().equals(expectedCurrency) ||
                !low.getCurrency().equals(expectedCurrency) ||
                !close.getCurrency().equals(expectedCurrency)) {
            throw new IllegalArgumentException("All prices must use symbol's quote currency: " + expectedCurrency);
        }
    }

    private void validateVolume() {
        if (volume.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Volume cannot be negative");
        }
    }

    // ===== OBJECT METHODS =====

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Candlestick that = (Candlestick) obj;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return String.format("Candlestick[%s: %s %s O:%s H:%s L:%s C:%s V:%s %s]",
                id, symbol.getCode(), interval.getCode(),
                open.toDisplayString(), high.toDisplayString(),
                low.toDisplayString(), close.toDisplayString(),
                BigDecimalNormalizer.normalize(volume).toPlainString(),
                isBullish() ? "📈" : isBearish() ? "📉" : "➡️");
    }
}=== ./domain/ChartData.java ===
package core.ms.OHLC.domain;

public interface ChartData {
    long getTime();
    double getOpen();
    double getHigh();
    double getLow();
    double getClose();
    double getVolume();
}
=== ./domain/PriceRange.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Money;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

/**
 * Value object representing a price range
 */
public class PriceRange {
    private final Money min;
    private final Money max;

    public PriceRange(Money min, Money max) {
        this.min = Objects.requireNonNull(min, "Min price cannot be null");
        this.max = Objects.requireNonNull(max, "Max price cannot be null");

        if (!min.getCurrency().equals(max.getCurrency())) {
            throw new IllegalArgumentException("Min and max prices must have the same currency");
        }

        if (min.isGreaterThan(max)) {
            throw new IllegalArgumentException("Min price must be <= max price");
        }
    }

    public Money getMin() { return min; }
    public Money getMax() { return max; }

    public Money getRange() {
        return max.subtract(min);
    }

    public boolean contains(Money price) {
        Objects.requireNonNull(price, "Price cannot be null");
        return price.isGreaterThanOrEqual(min) && price.isLessThanOrEqual(max);
    }

    /**
     * Returns the percentage position of a price within this range (0.0 to 1.0)
     */
    public BigDecimal getPercentagePosition(Money price) {
        Objects.requireNonNull(price, "Price cannot be null");

        if (!contains(price)) {
            throw new IllegalArgumentException("Price is outside the range");
        }

        if (getRange().isZero()) {
            return BigDecimal.ZERO;
        }

        Money priceFromMin = price.subtract(min);
        return priceFromMin.getAmount()
                .divide(getRange().getAmount(), 4, RoundingMode.HALF_UP);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PriceRange that = (PriceRange) obj;
        return Objects.equals(min, that.min) && Objects.equals(max, that.max);
    }

    @Override
    public int hashCode() {
        return Objects.hash(min, max);
    }

    @Override
    public String toString() {
        return String.format("PriceRange[%s - %s]", min.toDisplayString(), max.toDisplayString());
    }
}
=== ./domain/ChartSeries.java ===
package core.ms.OHLC.domain;

public interface ChartSeries {
    String getId();
    String getName();
    String getSymbol();
    String getInterval();
    java.util.List<ChartData> getData();
    boolean isEmpty();
    int size();
}
=== ./domain/OHLC.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Money;

import java.util.Objects;

/**
 * Simple value object for OHLC calculations
 */
public class OHLC {
    private final Money open;
    private final Money high;
    private final Money low;
    private final Money close;

    public OHLC(Money open, Money high, Money low, Money close) {
        this.open = Objects.requireNonNull(open, "Open cannot be null");
        this.high = Objects.requireNonNull(high, "High cannot be null");
        this.low = Objects.requireNonNull(low, "Low cannot be null");
        this.close = Objects.requireNonNull(close, "Close cannot be null");

        validateOHLC();
    }

    public Money getOpen() { return open; }
    public Money getHigh() { return high; }
    public Money getLow() { return low; }
    public Money getClose() { return close; }

    public boolean isValid() {
        try {
            validateOHLC();
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }

    private void validateOHLC() {
        if (high.isLessThan(low)) {
            throw new IllegalArgumentException("High must be >= Low");
        }
        if (open.isGreaterThan(high) || open.isLessThan(low)) {
            throw new IllegalArgumentException("Open must be between High and Low");
        }
        if (close.isGreaterThan(high) || close.isLessThan(low)) {
            throw new IllegalArgumentException("Close must be between High and Low");
        }
    }

    @Override
    public String toString() {
        return String.format("OHLC[O:%s H:%s L:%s C:%s]",
                open.toDisplayString(), high.toDisplayString(),
                low.toDisplayString(), close.toDisplayString());
    }
}=== ./domain/TransactionData.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.Objects;

/**
 * Simple data container for transaction information used by factory
 * This is NOT a domain entity, just a data transfer object
 */
public class TransactionData {
    private final Instant timestamp;
    private final Money price;
    private final BigDecimal quantity;
    private final Symbol symbol;

    public TransactionData(Instant timestamp, Money price, BigDecimal quantity, Symbol symbol) {
        this.timestamp = Objects.requireNonNull(timestamp, "Timestamp cannot be null");
        this.price = Objects.requireNonNull(price, "Price cannot be null");
        this.quantity = Objects.requireNonNull(quantity, "Quantity cannot be null");
        this.symbol = Objects.requireNonNull(symbol, "Symbol cannot be null");

        if (quantity.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
    }

    public Instant getTimestamp() { return timestamp; }
    public Money getPrice() { return price; }
    public BigDecimal getQuantity() { return quantity; }
    public Symbol getSymbol() { return symbol; }

    public Money getTotalValue() {
        return price.multiply(quantity);
    }

    @Override
    public String toString() {
        return String.format("TransactionData[%s: %s %s @ %s]",
                timestamp, quantity.toPlainString(), symbol.getCode(), price.toDisplayString());
    }
}
