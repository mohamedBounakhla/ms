=== ./order/OrderDomainIntegrationTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.*;
import core.ms.order.domain.value_objects.OrderStatusEnum;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Order Domain Integration Tests")
class OrderDomainIntegrationTest {

    @Test
    @DisplayName("Should handle complete order lifecycle")
    void shouldHandleCompleteOrderLifecycle() {
        // Create orders
        Symbol btcUsd = Symbol.btcUsd();
        Money price = Money.of("45000", Currency.USD);
        BigDecimal quantity = new BigDecimal("1.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, quantity);

        // Verify initial state
        assertEquals(OrderStatusEnum.PENDING, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PENDING, sellOrder.getStatus().getStatus());
        assertTrue(buyOrder.isActive());
        assertTrue(sellOrder.isActive());

        // ===== FIX: CREATE TRANSACTION FIRST (this will update states automatically) =====
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity);

        // ===== NOW orders should be FILLED automatically =====
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
        assertFalse(buyOrder.isActive());
        assertFalse(sellOrder.isActive());

        // Verify transaction details
        assertNotNull(transaction);
        assertEquals(Money.of("45000.00", Currency.USD), transaction.getTotalValue());
        assertEquals(BigDecimal.ZERO, buyOrder.getRemainingQuantity());
        assertEquals(BigDecimal.ZERO, sellOrder.getRemainingQuantity());
    }

    @Test
    @DisplayName("Should handle order cancellation scenario")
    void shouldHandleOrderCancellationScenario() {
        Symbol btcUsd = Symbol.btcUsd();
        Money price = Money.of("45000", Currency.USD);
        BigDecimal quantity = new BigDecimal("1.0");

        BuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, quantity);

        // Update price
        Money newPrice = Money.of("46000", Currency.USD);
        buyOrder.updatePrice(newPrice);
        assertEquals(newPrice, buyOrder.getPrice());

        // Partial cancellation
        buyOrder.cancelPartial();
        assertEquals(OrderStatusEnum.PENDING, buyOrder.getStatus().getStatus());

        // Full cancellation
        buyOrder.cancel();
        assertEquals(OrderStatusEnum.CANCELLED, buyOrder.getStatus().getStatus());
        assertFalse(buyOrder.isActive());

        // Should not allow further modifications
        assertThrows(IllegalStateException.class, () -> buyOrder.updatePrice(price));
    }
}=== ./order/TransactionOrderStateUpdatesTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.*;
import core.ms.order.domain.value_objects.OrderStatusEnum;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.assertEquals;

@DisplayName("1. Transaction Order State Updates Tests")
class TransactionOrderStateUpdatesTest {

    private Symbol btcUsd;
    private Money price;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
        price = Money.of("45000", Currency.USD);
    }

    @Test
    @DisplayName("Should update orders to FILLED when transaction quantity equals order quantity")
    void shouldUpdateOrdersToFilledWhenTransactionQuantityEqualsOrderQuantity() {
        // Given: Orders with 1.0 BTC quantity
        BigDecimal orderQuantity = new BigDecimal("1.0");
        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        assertEquals(OrderStatusEnum.PENDING, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PENDING, sellOrder.getStatus().getStatus());

        // When: Transaction created with full quantity (1.0 BTC)
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, orderQuantity);

        // Then: Orders should be FILLED
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
    }

    @Test
    @DisplayName("Should update orders to PARTIAL when transaction quantity is less than order quantity")
    void shouldUpdateOrdersToPartialWhenTransactionQuantityIsLessThanOrderQuantity() {
        // Given: Orders with 2.0 BTC quantity
        BigDecimal orderQuantity = new BigDecimal("2.0");
        BigDecimal transactionQuantity = new BigDecimal("0.5");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Transaction created with partial quantity (0.5 BTC)
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, transactionQuantity);

        // Then: Orders should be PARTIAL
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());
    }

    @Test
    @DisplayName("Should update PARTIAL orders to FILLED when remaining quantity is fully executed")
    void shouldUpdatePartialOrdersToFilledWhenRemainingQuantityIsFullyExecuted() {
        // Given: Orders with 2.0 BTC quantity
        BigDecimal orderQuantity = new BigDecimal("2.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // ===== FIX: PROPERLY SIMULATE PARTIAL EXECUTION =====
        // First transaction: Execute 0.5 BTC to make orders PARTIAL
        BigDecimal firstTransactionQuantity = new BigDecimal("0.5");
        Transaction firstTransaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, firstTransactionQuantity);

        // Verify orders are now PARTIAL with 1.5 BTC remaining
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());
        assertEquals(new BigDecimal("0.5"), buyOrder.getExecutedQuantity());
        assertEquals(new BigDecimal("1.5"), buyOrder.getRemainingQuantity());

        // When: Second transaction executes the remaining 1.5 BTC
        BigDecimal remainingQuantity = new BigDecimal("1.5");
        Transaction secondTransaction = new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, remainingQuantity);

        // Then: Orders should now be FILLED
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
        assertEquals(orderQuantity, buyOrder.getExecutedQuantity()); // 2.0 total
        assertEquals(BigDecimal.ZERO, buyOrder.getRemainingQuantity()); // 0 remaining
    }
    @Test
    @DisplayName("Should track order state transitions through multiple transactions")
    void shouldTrackOrderStateTransitionsThroughMultipleTransactions() {
        // Given: Orders with 3.0 BTC quantity
        BigDecimal orderQuantity = new BigDecimal("3.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // Initial state: PENDING
        assertEquals(OrderStatusEnum.PENDING, buyOrder.getStatus().getStatus());
        assertEquals(BigDecimal.ZERO, buyOrder.getExecutedQuantity());
        assertEquals(orderQuantity, buyOrder.getRemainingQuantity());

        // Transaction 1: Execute 1.0 BTC (PENDING → PARTIAL)
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(new BigDecimal("1.0"), buyOrder.getExecutedQuantity());
        assertEquals(new BigDecimal("2.0"), buyOrder.getRemainingQuantity());

        // Transaction 2: Execute 1.0 BTC (PARTIAL → PARTIAL)
        Transaction tx2 = new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(new BigDecimal("2.0"), buyOrder.getExecutedQuantity());
        assertEquals(new BigDecimal("1.0"), buyOrder.getRemainingQuantity());

        // Transaction 3: Execute remaining 1.0 BTC (PARTIAL → FILLED)
        Transaction tx3 = new Transaction("tx-3", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(new BigDecimal("3.0"), buyOrder.getExecutedQuantity());
        assertEquals(BigDecimal.ZERO, buyOrder.getRemainingQuantity());
    }
    @Test
    @DisplayName("Should handle exact remaining quantity execution")
    void shouldHandleExactRemainingQuantityExecution() {
        // Given: Order with 1.0 BTC
        BigDecimal orderQuantity = new BigDecimal("1.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // First: Execute 0.3 BTC (PENDING → PARTIAL)
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, new BigDecimal("0.3"));
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(new BigDecimal("0.7"), buyOrder.getRemainingQuantity());

        // Then: Execute exactly the remaining 0.7 BTC (PARTIAL → FILLED)
        Transaction tx2 = new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, new BigDecimal("0.7"));
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(BigDecimal.ZERO, buyOrder.getRemainingQuantity());
    }
}
=== ./order/AbstractOrderTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.BuyOrder;
import core.ms.shared.domain.*;
import core.ms.order.domain.value_objects.*;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Test;
import java.math.BigDecimal;
import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Abstract Order Tests")
class AbstractOrderTest {

    private Symbol btcUsd;
    private Money price;
    private BigDecimal quantity;
    private BuyOrder buyOrder;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
        price = Money.of("45000", Currency.USD);
        quantity = new BigDecimal("0.5");
        buyOrder = new BuyOrder("order-1", btcUsd, price, quantity);
    }

    @Test
    @DisplayName("Should create order with valid parameters")
    void shouldCreateOrderWithValidParameters() {
        assertNotNull(buyOrder);
        assertEquals("order-1", buyOrder.getId());
        assertEquals(btcUsd, buyOrder.getSymbol());
        assertEquals(price, buyOrder.getPrice());
        assertEquals(quantity, buyOrder.getQuantity());
        assertEquals(OrderStatusEnum.PENDING, buyOrder.getStatus().getStatus());
        assertNotNull(buyOrder.getCreatedAt());
        assertNotNull(buyOrder.getUpdatedAt());
        assertTrue(buyOrder.isActive());
    }

    @Test
    @DisplayName("Should validate price currency matches symbol quote currency")
    void shouldValidatePriceCurrencyMatchesSymbolQuoteCurrency() {
        Money eurPrice = Money.of("40000", Currency.EUR);

        assertThrows(IllegalArgumentException.class,
                () -> new BuyOrder("order-2", btcUsd, eurPrice, quantity));
    }

    @Test
    @DisplayName("Should validate quantity is positive")
    void shouldValidateQuantityIsPositive() {
        BigDecimal negativeQuantity = new BigDecimal("-0.5");
        BigDecimal zeroQuantity = BigDecimal.ZERO;

        assertThrows(IllegalArgumentException.class,
                () -> new BuyOrder("order-2", btcUsd, price, negativeQuantity));
        assertThrows(IllegalArgumentException.class,
                () -> new BuyOrder("order-3", btcUsd, price, zeroQuantity));
    }

    @Test
    @DisplayName("Should calculate total value correctly")
    void shouldCalculateTotalValueCorrectly() {
        Money expectedTotal = Money.of("22500.00", Currency.USD); // 45000 * 0.5
        assertEquals(expectedTotal, buyOrder.getTotalValue());
    }

    @Test
    @DisplayName("Should update price when order is active")
    void shouldUpdatePriceWhenOrderIsActive() {
        Money newPrice = Money.of("46000", Currency.USD);
        LocalDateTime beforeUpdate = buyOrder.getUpdatedAt();

        buyOrder.updatePrice(newPrice);

        assertEquals(newPrice, buyOrder.getPrice());
        assertTrue(buyOrder.getUpdatedAt().isAfter(beforeUpdate));
    }

    @Test
    @DisplayName("Should not update price when order is terminal")
    void shouldNotUpdatePriceWhenOrderIsTerminal() {
        buyOrder.complete(); // Make order terminal
        Money newPrice = Money.of("46000", Currency.USD);

        assertThrows(IllegalStateException.class,
                () -> buyOrder.updatePrice(newPrice));
    }

    @Test
    @DisplayName("Should validate price currency when updating")
    void shouldValidatePriceCurrencyWhenUpdating() {
        Money eurPrice = Money.of("40000", Currency.EUR);

        assertThrows(IllegalArgumentException.class,
                () -> buyOrder.updatePrice(eurPrice));
    }

    @Test
    @DisplayName("Should handle state transitions correctly")
    void shouldHandleStateTransitionsCorrectly() {
        // Test PENDING → PARTIAL
        buyOrder.fillPartial();
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertTrue(buyOrder.isActive());

        // Test PARTIAL → FILLED
        buyOrder.complete();
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertFalse(buyOrder.isActive());
    }

    @Test
    @DisplayName("Should handle cancellation correctly")
    void shouldHandleCancellationCorrectly() {
        buyOrder.cancel();
        assertEquals(OrderStatusEnum.CANCELLED, buyOrder.getStatus().getStatus());
        assertFalse(buyOrder.isActive());
    }

    @Test
    @DisplayName("Should handle partial cancellation correctly")
    void shouldHandlePartialCancellationCorrectly() {
        assertDoesNotThrow(() -> buyOrder.cancelPartial());
        assertEquals(OrderStatusEnum.PENDING, buyOrder.getStatus().getStatus());
    }
}
=== ./order/MultipleTransactionSupportTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.*;
import core.ms.order.domain.value_objects.OrderStatusEnum;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("3. Multiple Transaction Support Tests")
class MultipleTransactionSupportTest {

    private Symbol btcUsd;
    private Money price;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
        price = Money.of("45000", Currency.USD);
    }

    @Test
    @DisplayName("Should support multiple partial transactions on same orders")
    void shouldSupportMultiplePartialTransactionsOnSameOrders() {
        // Given: Orders with 5.0 BTC
        BigDecimal orderQuantity = new BigDecimal("5.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Multiple partial transactions
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());

        Transaction tx2 = new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, new BigDecimal("2.0"));
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());

        Transaction tx3 = new Transaction("tx-3", btcUsd, buyOrder, sellOrder, price, new BigDecimal("2.0"));

        // Then: Final transaction should complete the orders
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
        assertEquals(orderQuantity, buyOrder.getExecutedQuantity());
    }

    @Test
    @DisplayName("Should track all transactions associated with an order")
    void shouldTrackAllTransactionsAssociatedWithAnOrder() {
        // Given: Order with 3.0 BTC
        BigDecimal orderQuantity = new BigDecimal("3.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Multiple transactions
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        Transaction tx2 = new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.5"));
        Transaction tx3 = new Transaction("tx-3", btcUsd, buyOrder, sellOrder, price, new BigDecimal("0.5"));

        // Then: Order should track all its transactions
        List<ITransaction> buyOrderTransactions = buyOrder.getTransactions();
        List<ITransaction> sellOrderTransactions = sellOrder.getTransactions();

        assertEquals(3, buyOrderTransactions.size());
        assertEquals(3, sellOrderTransactions.size());
        assertTrue(buyOrderTransactions.contains(tx1));
        assertTrue(buyOrderTransactions.contains(tx2));
        assertTrue(buyOrderTransactions.contains(tx3));
    }

    @Test
    @DisplayName("Should prevent transaction when remaining quantity is insufficient")
    void shouldPreventTransactionWhenRemainingQuantityIsInsufficient() {
        // Given: Order with 2.0 BTC, partially executed
        BigDecimal orderQuantity = new BigDecimal("2.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // Execute 1.5 BTC first
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.5"));

        // When: Trying to execute more than remaining (0.5 BTC)
        BigDecimal excessiveQuantity = new BigDecimal("1.0");

        // Then: Should throw exception
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, excessiveQuantity));
    }
    @Test
    @DisplayName("Transaction processing test")
    void transactionProcessing(){

        ISellOrder mySellOrder = new SellOrder(
                "sell-1",
                Symbol.eurUsd() ,
                Money.of("50.00",Currency.USD),
                new BigDecimal("12")
        );

        IBuyOrder myBuyOrder = new BuyOrder(
                "buy-1",
                Symbol.eurUsd(),
                Money.of("50.00",Currency.USD),
                new BigDecimal("3")
        );

        Transaction t1 = new Transaction(
                "t1",
                mySellOrder.getSymbol(),
                myBuyOrder,
                mySellOrder,
                myBuyOrder.getPrice(),
                myBuyOrder.getQuantity()
        );
        //Quantité initial
        assertEquals(new BigDecimal("12"),mySellOrder.getQuantity());
        //Quantité restante
        assertEquals(new BigDecimal("9"),mySellOrder.getRemainingQuantity());
        //Ordre d'achat vide
        assertSame(BigDecimal.ZERO, myBuyOrder.getRemainingQuantity());
        //Status ordre d'achat FILLED
        assertEquals(OrderStatusEnum.FILLED, myBuyOrder.getStatus().getStatus());

    }
    @Test
    @DisplayName("Transaction processing test - Buy order larger quantity")
    void transactionProcessingBuyOrderLargerQuantity(){

        ISellOrder mySellOrder = new SellOrder(
                "sell-1",
                Symbol.eurUsd(),
                Money.of("50.00", Currency.USD),
                new BigDecimal("3")
        );

        IBuyOrder myBuyOrder = new BuyOrder(
                "buy-1",
                Symbol.eurUsd(),
                Money.of("50.00", Currency.USD),
                new BigDecimal("12")
        );

        Transaction t1 = new Transaction(
                "t1",
                mySellOrder.getSymbol(),
                myBuyOrder,
                mySellOrder,
                myBuyOrder.getPrice(),
                mySellOrder.getQuantity()  // Transaction quantity is limited by the smaller sell order
        );

        // Sell order initial quantity
        assertEquals(new BigDecimal("3"), mySellOrder.getQuantity());
        // Sell order remaining quantity (should be zero - fully filled)
        assertEquals(BigDecimal.ZERO, mySellOrder.getRemainingQuantity());
        // Sell order status should be FILLED
        assertEquals(OrderStatusEnum.FILLED, mySellOrder.getStatus().getStatus());

        // Buy order initial quantity
        assertEquals(new BigDecimal("12"), myBuyOrder.getQuantity());
        // Buy order remaining quantity (12 - 3 = 9)
        assertEquals(new BigDecimal("9"), myBuyOrder.getRemainingQuantity());
        // Buy order status should be PARTIAL (not fully filled)
        assertEquals(OrderStatusEnum.PARTIAL, myBuyOrder.getStatus().getStatus());
    }
}=== ./order/BuyOrderTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.BuyOrder;
import core.ms.order.domain.entities.IOrder;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

@DisplayName("Buy Order Tests")
class BuyOrderTest {

    private BuyOrder buyOrder;
    private Money price;
    private BigDecimal quantity;

    @BeforeEach
    void setUp() {
        Symbol btcUsd = Symbol.btcUsd();
        price = Money.of("45000", Currency.USD);
        quantity = new BigDecimal("0.5");
        buyOrder = new BuyOrder("buy-order-1", btcUsd, price, quantity);
    }

    @Test
    @DisplayName("Should calculate cost basis correctly")
    void shouldCalculateCostBasisCorrectly() {
        Money expectedCostBasis = Money.of("22500.00", Currency.USD);
        assertEquals(expectedCostBasis, buyOrder.getCostBasis());
    }

    @Test
    @DisplayName("Should implement IBuyOrder interface")
    void shouldImplementIBuyOrderInterface() {
        assertTrue(buyOrder instanceof IOrder);
    }
}
=== ./order/TransactionOrderingTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.*;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("5. Transaction Ordering & Timestamps Tests")
class TransactionOrderingTest {

    private Symbol btcUsd;
    private Money price;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
        price = Money.of("45000", Currency.USD);
    }

    @Test
    @DisplayName("Should create transactions with proper timestamps")
    void shouldCreateTransactionsWithProperTimestamps() {
        // Given
        BigDecimal quantity = new BigDecimal("1.0");
        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, quantity);

        LocalDateTime beforeTransaction = LocalDateTime.now();

        // When
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity);

        LocalDateTime afterTransaction = LocalDateTime.now();

        // Then
        assertNotNull(transaction.getCreatedAt());
        assertTrue(transaction.getCreatedAt().isAfter(beforeTransaction) ||
                transaction.getCreatedAt().isEqual(beforeTransaction));
        assertTrue(transaction.getCreatedAt().isBefore(afterTransaction) ||
                transaction.getCreatedAt().isEqual(afterTransaction));
    }

    @Test
    @DisplayName("Should maintain transaction sequence order")
    void shouldMaintainTransactionSequenceOrder() {
        // Given: Order with sufficient quantity
        BigDecimal orderQuantity = new BigDecimal("3.0");
        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Creating transactions in sequence
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        // Small delay to ensure different timestamps
        try { Thread.sleep(1); } catch (InterruptedException e) {}

        Transaction tx2 = new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        try { Thread.sleep(1); } catch (InterruptedException e) {}

        Transaction tx3 = new Transaction("tx-3", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));

        // Then: Transactions should be in chronological order
        assertTrue(tx1.getCreatedAt().isBefore(tx2.getCreatedAt()));
        assertTrue(tx2.getCreatedAt().isBefore(tx3.getCreatedAt()));

        // And: Order should maintain transaction sequence
        List<ITransaction> transactions = buyOrder.getTransactions();
        assertEquals(tx1, transactions.get(0));
        assertEquals(tx2, transactions.get(1));
        assertEquals(tx3, transactions.get(2));
    }

    @Test
    @DisplayName("Should prevent concurrent transaction creation on same order")
    void shouldPreventConcurrentTransactionCreationOnSameOrder() {
        // Given: Order with limited remaining quantity
        BigDecimal orderQuantity = new BigDecimal("1.0");
        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Attempting concurrent transactions that would exceed remaining quantity
        // This simulates a race condition where two transactions try to execute simultaneously

        // First transaction should succeed
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, new BigDecimal("0.8"));

        // Second transaction should fail (only 0.2 remaining, but trying to execute 0.5)
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, new BigDecimal("0.5")));
    }

    @Test
    @DisplayName("Should generate unique transaction IDs")
    void shouldGenerateUniqueTransactionIDs() {
        // Given
        BigDecimal quantity = new BigDecimal("0.1");
        IBuyOrder buyOrder1 = new BuyOrder("buy-1", btcUsd, price, new BigDecimal("1.0"));
        ISellOrder sellOrder1 = new SellOrder("sell-1", btcUsd, price, new BigDecimal("1.0"));
        IBuyOrder buyOrder2 = new BuyOrder("buy-2", btcUsd, price, new BigDecimal("1.0"));
        ISellOrder sellOrder2 = new SellOrder("sell-2", btcUsd, price, new BigDecimal("1.0"));

        // When: Creating multiple transactions
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder1, sellOrder1, price, quantity);
        Transaction tx2 = new Transaction("tx-2", btcUsd, buyOrder2, sellOrder2, price, quantity);

        // Then: Transaction IDs should be unique
        assertNotEquals(tx1.getId(), tx2.getId());
    }

    @Test
    @DisplayName("Should track transaction execution sequence within order")
    void shouldTrackTransactionExecutionSequenceWithinOrder() {
        // Given: Order with sufficient quantity
        BigDecimal orderQuantity = new BigDecimal("3.0");
        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Multiple transactions execute
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        Transaction tx2 = new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));
        Transaction tx3 = new Transaction("tx-3", btcUsd, buyOrder, sellOrder, price, new BigDecimal("1.0"));

        // Then: Order should track execution sequence
        assertEquals(1, buyOrder.getTransactionSequence(tx1));
        assertEquals(2, buyOrder.getTransactionSequence(tx2));
        assertEquals(3, buyOrder.getTransactionSequence(tx3));
    }
}=== ./order/OrderMatchingRulesTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.*;
import core.ms.order.domain.value_objects.OrderStatusEnum;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("4. Order Matching Rules Tests")
class OrderMatchingRulesTest {

    private Symbol btcUsd;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
    }

    @Test
    @DisplayName("Should allow matching when buy price is greater than or equal to sell price")
    void shouldAllowMatchingWhenBuyPriceIsGreaterThanOrEqualToSellPrice() {
        // Given: Buy at $45,000, Sell at $44,000
        Money buyPrice = Money.of("45000", Currency.USD);
        Money sellPrice = Money.of("44000", Currency.USD);
        Money executionPrice = Money.of("44500", Currency.USD); // Mid-point
        BigDecimal quantity = new BigDecimal("1.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellPrice, quantity);

        // When: Creating transaction with execution price
        // Then: Should succeed
        assertDoesNotThrow(() ->
                new Transaction("tx-1", btcUsd, buyOrder, sellOrder, executionPrice, quantity));
    }

    @Test
    @DisplayName("Should prevent matching when buy price is less than sell price")
    void shouldPreventMatchingWhenBuyPriceIsLessThanSellPrice() {
        // Given: Buy at $44,000, Sell at $45,000 (no overlap)
        Money buyPrice = Money.of("44000", Currency.USD);
        Money sellPrice = Money.of("45000", Currency.USD);
        Money executionPrice = Money.of("44500", Currency.USD);
        BigDecimal quantity = new BigDecimal("1.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellPrice, quantity);

        // When: Trying to create transaction
        // Then: Should fail - prices don't overlap
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, executionPrice, quantity));
    }

    @Test
    @DisplayName("Should validate execution price is within buy-sell price range")
    void shouldValidateExecutionPriceIsWithinBuySellPriceRange() {
        // Given: Buy at $46,000, Sell at $44,000
        Money buyPrice = Money.of("46000", Currency.USD);
        Money sellPrice = Money.of("44000", Currency.USD);
        BigDecimal quantity = new BigDecimal("1.0");

        // Valid execution prices (between sell and buy)
        Money validPrice1 = Money.of("44000", Currency.USD); // Sell price
        Money validPrice2 = Money.of("45000", Currency.USD); // Mid-point
        Money validPrice3 = Money.of("46000", Currency.USD); // Buy price

        // Invalid execution prices (outside range)
        Money tooLow = Money.of("43000", Currency.USD);   // Below sell price
        Money tooHigh = Money.of("47000", Currency.USD);  // Above buy price

        // ===== FIX: CREATE FRESH ORDERS FOR EACH TRANSACTION =====

        // Test 1: Valid price at sell price
        IBuyOrder buyOrder1 = new BuyOrder("buy-1", btcUsd, buyPrice, quantity);
        ISellOrder sellOrder1 = new SellOrder("sell-1", btcUsd, sellPrice, quantity);
        assertDoesNotThrow(() -> new Transaction("tx-1", btcUsd, buyOrder1, sellOrder1, validPrice1, quantity));

        // Test 2: Valid price at mid-point
        IBuyOrder buyOrder2 = new BuyOrder("buy-2", btcUsd, buyPrice, quantity);
        ISellOrder sellOrder2 = new SellOrder("sell-2", btcUsd, sellPrice, quantity);
        assertDoesNotThrow(() -> new Transaction("tx-2", btcUsd, buyOrder2, sellOrder2, validPrice2, quantity));

        // Test 3: Valid price at buy price
        IBuyOrder buyOrder3 = new BuyOrder("buy-3", btcUsd, buyPrice, quantity);
        ISellOrder sellOrder3 = new SellOrder("sell-3", btcUsd, sellPrice, quantity);
        assertDoesNotThrow(() -> new Transaction("tx-3", btcUsd, buyOrder3, sellOrder3, validPrice3, quantity));

        // Test 4: Invalid price too low
        IBuyOrder buyOrder4 = new BuyOrder("buy-4", btcUsd, buyPrice, quantity);
        ISellOrder sellOrder4 = new SellOrder("sell-4", btcUsd, sellPrice, quantity);
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-4", btcUsd, buyOrder4, sellOrder4, tooLow, quantity));

        // Test 5: Invalid price too high
        IBuyOrder buyOrder5 = new BuyOrder("buy-5", btcUsd, buyPrice, quantity);
        ISellOrder sellOrder5 = new SellOrder("sell-5", btcUsd, sellPrice, quantity);
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-5", btcUsd, buyOrder5, sellOrder5, tooHigh, quantity));
    }
    @Test
    @DisplayName("Should validate execution price is within buy-sell price range - Multiple Transactions")
    void shouldValidateExecutionPriceIsWithinBuySellPriceRangeMultipleTransactions() {
        // Given: Buy at $46,000, Sell at $44,000 with LARGER quantities
        Money buyPrice = Money.of("46000", Currency.USD);
        Money sellPrice = Money.of("44000", Currency.USD);
        BigDecimal orderQuantity = new BigDecimal("10.0"); // Large enough for multiple transactions
        BigDecimal transactionQuantity = new BigDecimal("1.0"); // Small transaction size

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyPrice, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellPrice, orderQuantity);

        // Valid execution prices (between sell and buy)
        Money validPrice1 = Money.of("44000", Currency.USD); // Sell price
        Money validPrice2 = Money.of("45000", Currency.USD); // Mid-point
        Money validPrice3 = Money.of("46000", Currency.USD); // Buy price

        // Should succeed for valid prices
        assertDoesNotThrow(() -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, validPrice1, transactionQuantity));
        assertDoesNotThrow(() -> new Transaction("tx-2", btcUsd, buyOrder, sellOrder, validPrice2, transactionQuantity));
        assertDoesNotThrow(() -> new Transaction("tx-3", btcUsd, buyOrder, sellOrder, validPrice3, transactionQuantity));

        // Orders should still be PARTIAL (not FILLED) since we have remaining quantity
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());

        // Verify executed and remaining quantities
        assertEquals(new BigDecimal("3.0"), buyOrder.getExecutedQuantity());
        assertEquals(new BigDecimal("7.0"), buyOrder.getRemainingQuantity());
    }

    @Test
    @DisplayName("Should determine optimal execution price for matching orders")
    void shouldDetermineOptimalExecutionPriceForMatchingOrders() {
        // Given: Buy at $46,000, Sell at $44,000
        Money buyPrice = Money.of("46000", Currency.USD);
        Money sellPrice = Money.of("44000", Currency.USD);
        BigDecimal quantity = new BigDecimal("1.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellPrice, quantity);

        // When: Determining optimal execution price
        Money optimalPrice = Transaction.determineExecutionPrice(buyOrder, sellOrder);

        // Then: Should be mid-point (or some fair price discovery algorithm)
        Money expectedPrice = Money.of("45000", Currency.USD); // Mid-point
        assertEquals(expectedPrice, optimalPrice);
    }

}
=== ./order/SellOrderTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.SellOrder;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

@DisplayName("Sell Order Tests")
class SellOrderTest {

    private SellOrder sellOrder;
    private Money price;
    private BigDecimal quantity;

    @BeforeEach
    void setUp() {
        Symbol btcUsd = Symbol.btcUsd();
        price = Money.of("45000", Currency.USD);
        quantity = new BigDecimal("0.5");
        sellOrder = new SellOrder("sell-order-1", btcUsd, price, quantity);
    }

    @Test
    @DisplayName("Should calculate proceeds correctly")
    void shouldCalculateProceedsCorrectly() {
        Money expectedProceeds = Money.of("22500.00", Currency.USD);
        assertEquals(expectedProceeds, sellOrder.getProceeds());
    }


}=== ./order/OrderStatusTest.java ===
package core.ms.order;

import core.ms.order.domain.value_objects.OrderStatus;
import core.ms.order.domain.value_objects.OrderStatusEnum;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;


@DisplayName("Order Status State Pattern Tests")
public class OrderStatusTest {

    private OrderStatus orderStatus;

    @BeforeEach
    void setUp() {
        orderStatus = new OrderStatus();
    }

    @Test
    @DisplayName("Should start in PENDING state")
    public void shouldStartInPendingState() {
        assertEquals(OrderStatusEnum.PENDING, orderStatus.getStatus());
        assertFalse(orderStatus.isTerminal());
    }

    @Test
    @DisplayName("Should transition from PENDING to PARTIAL")
    public void shouldTransitionFromPendingToPartial() {
        orderStatus.fillPartialOrder();
        assertEquals(OrderStatusEnum.PARTIAL, orderStatus.getStatus());
        assertFalse(orderStatus.isTerminal());
    }

    @Test
    @DisplayName("Should transition from PENDING to FILLED")
    public void shouldTransitionFromPendingToFilled() {
        orderStatus.completeOrder();
        assertEquals(OrderStatusEnum.FILLED, orderStatus.getStatus());
        assertTrue(orderStatus.isTerminal());
    }

    @Test
    @DisplayName("Should transition from PENDING to CANCELLED")
    public void shouldTransitionFromPendingToCancelled() {
        orderStatus.cancelOrder();
        assertEquals(OrderStatusEnum.CANCELLED, orderStatus.getStatus());
        assertTrue(orderStatus.isTerminal());
    }

    @Test
    @DisplayName("Should transition from PARTIAL to FILLED")
    public void shouldTransitionFromPartialToFilled() {
        orderStatus.fillPartialOrder(); // PENDING → PARTIAL
        orderStatus.completeOrder();    // PARTIAL → FILLED
        assertEquals(OrderStatusEnum.FILLED, orderStatus.getStatus());
        assertTrue(orderStatus.isTerminal());
    }

    @Test
    @DisplayName("Should transition from PARTIAL to CANCELLED")
    public void shouldTransitionFromPartialToCancelled() {
        orderStatus.fillPartialOrder(); // PENDING → PARTIAL
        orderStatus.cancelOrder();      // PARTIAL → CANCELLED
        assertEquals(OrderStatusEnum.CANCELLED, orderStatus.getStatus());
        assertTrue(orderStatus.isTerminal());
    }

    @Test
    @DisplayName("Should allow partial cancellation in PENDING state")
    public void shouldAllowPartialCancellationInPending() {
        assertDoesNotThrow(() -> orderStatus.cancelPartialOrder());
        assertEquals(OrderStatusEnum.PENDING, orderStatus.getStatus());
    }

    @Test
    @DisplayName("Should allow partial cancellation in PARTIAL state")
    public void shouldAllowPartialCancellationInPartial() {
        orderStatus.fillPartialOrder(); // PENDING → PARTIAL
        assertDoesNotThrow(() -> orderStatus.cancelPartialOrder());
        assertEquals(OrderStatusEnum.PARTIAL, orderStatus.getStatus());
    }

    @Test
    @DisplayName("Should throw exception when trying to modify FILLED order")
    public void shouldThrowExceptionWhenModifyingFilledOrder() {
        orderStatus.completeOrder(); // PENDING → FILLED

        assertThrows(IllegalStateException.class, () -> orderStatus.cancelOrder());
        assertThrows(IllegalStateException.class, () -> orderStatus.fillPartialOrder());
        assertThrows(IllegalStateException.class, () -> orderStatus.completeOrder());
        assertThrows(IllegalStateException.class, () -> orderStatus.cancelPartialOrder());
    }

    @Test
    @DisplayName("Should throw exception when trying to modify CANCELLED order")
    public void shouldThrowExceptionWhenModifyingCancelledOrder() {
        orderStatus.cancelOrder(); // PENDING → CANCELLED

        assertThrows(IllegalStateException.class, () -> orderStatus.fillPartialOrder());
        assertThrows(IllegalStateException.class, () -> orderStatus.completeOrder());
        assertThrows(IllegalStateException.class, () -> orderStatus.cancelOrder());
        assertThrows(IllegalStateException.class, () -> orderStatus.cancelPartialOrder());
    }

}=== ./order/TransactionTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.*;
import core.ms.order.domain.value_objects.OrderStatusEnum;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Transaction Domain Rules Tests")
class TransactionDomainRulesTest {

    private Symbol btcUsd;
    private Money price;
    private BigDecimal quantity;
    private IBuyOrder buyOrder;
    private ISellOrder sellOrder;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
        price = Money.of("45000", Currency.USD);
        quantity = new BigDecimal("0.5");
        buyOrder = new BuyOrder("buy-1", btcUsd, price, quantity);
        sellOrder = new SellOrder("sell-1", btcUsd, price, quantity);
    }

    // ===== RULE 1: TRANSACTION PRICE CONSISTENCY =====

    @Test
    @DisplayName("Should validate transaction price matches buy order price")
    void shouldValidateTransactionPriceMatchesBuyOrderPrice() {
        Money buyOrderPrice = Money.of("45000", Currency.USD);
        Money sellOrderPrice = Money.of("45000", Currency.USD);
        Money differentTransactionPrice = Money.of("46000", Currency.USD);

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyOrderPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellOrderPrice, quantity);

        // Transaction price must match order prices
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, differentTransactionPrice, quantity));
    }

    @Test
    @DisplayName("Should create transaction when all prices match")
    void shouldCreateTransactionWhenAllPricesMatch() {
        Money matchingPrice = Money.of("45000", Currency.USD);

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, matchingPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, matchingPrice, quantity);

        // Should succeed when all prices match
        assertDoesNotThrow(
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, matchingPrice, quantity));
    }

    // ===== RULE 2: TRANSACTION QUANTITY VALIDATION =====

    @Test
    @DisplayName("Should validate transaction quantity does not exceed buy order quantity")
    void shouldValidateTransactionQuantityDoesNotExceedBuyOrderQuantity() {
        BigDecimal buyOrderQuantity = new BigDecimal("0.5");
        BigDecimal sellOrderQuantity = new BigDecimal("1.0");
        BigDecimal transactionQuantity = new BigDecimal("0.8"); // More than buy order

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, buyOrderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, sellOrderQuantity);

        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, transactionQuantity));
    }

    @Test
    @DisplayName("Should validate transaction quantity does not exceed sell order quantity")
    void shouldValidateTransactionQuantityDoesNotExceedSellOrderQuantity() {
        BigDecimal buyOrderQuantity = new BigDecimal("1.0");
        BigDecimal sellOrderQuantity = new BigDecimal("0.5");
        BigDecimal transactionQuantity = new BigDecimal("0.8"); // More than sell order

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, buyOrderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, sellOrderQuantity);

        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, transactionQuantity));
    }

    @Test
    @DisplayName("Should create transaction with valid quantity within order limits")
    void shouldCreateTransactionWithValidQuantityWithinOrderLimits() {
        BigDecimal buyOrderQuantity = new BigDecimal("1.0");
        BigDecimal sellOrderQuantity = new BigDecimal("0.8");
        BigDecimal transactionQuantity = new BigDecimal("0.5"); // Within both limits

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, buyOrderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, sellOrderQuantity);

        assertDoesNotThrow(
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, transactionQuantity));
    }

    // ===== RULE 3: ACTIVE ORDERS ONLY =====

    @Test
    @DisplayName("Should not create transaction with cancelled buy order")
    void shouldNotCreateTransactionWithCancelledBuyOrder() {
        buyOrder.cancel(); // Make buy order inactive

        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity));
    }

    @Test
    @DisplayName("Should not create transaction with cancelled sell order")
    void shouldNotCreateTransactionWithCancelledSellOrder() {
        sellOrder.cancel(); // Make sell order inactive

        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity));
    }

    @Test
    @DisplayName("Should not create transaction with filled buy order")
    void shouldNotCreateTransactionWithFilledBuyOrder() {
        buyOrder.complete(); // Make buy order filled (inactive)

        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity));
    }

    @Test
    @DisplayName("Should create transaction with pending orders")
    void shouldCreateTransactionWithPendingOrders() {
        // Both orders are pending by default
        assertDoesNotThrow(
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity));
    }

    @Test
    @DisplayName("Should create transaction with partial orders")
    void shouldCreateTransactionWithPartialOrders() {
        buyOrder.fillPartial();  // Make orders partial (still active)
        sellOrder.fillPartial();

        assertDoesNotThrow(
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity));
    }

    // ===== RULE 4: ORDER STATUS UPDATES AFTER TRANSACTION =====

    @Test
    @DisplayName("Should update order status to filled when transaction quantity equals order quantity")
    void shouldUpdateOrderStatusToFilledWhenTransactionQuantityEqualsOrderQuantity() {
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity);

        // When transaction quantity = order quantity, orders should become FILLED
        // This would be handled by the transaction creation process
        // For now, we test that the transaction was created successfully
        assertNotNull(transaction);
        assertEquals(quantity, transaction.getQuantity());
    }

    @Test
    @DisplayName("Should update order status to partial when transaction quantity is less than order quantity")
    void shouldUpdateOrderStatusToPartialWhenTransactionQuantityIsLessThanOrderQuantity() {
        BigDecimal orderQuantity = new BigDecimal("1.0");
        BigDecimal transactionQuantity = new BigDecimal("0.5"); // Less than order quantity

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, transactionQuantity);

        // Orders should become PARTIAL when partially filled
        // This would be handled by the transaction creation process
        assertNotNull(transaction);
        assertEquals(transactionQuantity, transaction.getQuantity());
    }

    // ===== EDGE CASES =====

    @Test
    @DisplayName("Should throw NullPointerException for null parameters")
    void shouldThrowNullPointerExceptionForNullParameters() {
        // Test null validation
        assertThrows(NullPointerException.class,
                () -> new Transaction(null, btcUsd, buyOrder, sellOrder, price, quantity));
        // ... other null tests
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException for business rule violations")
    void shouldThrowIllegalArgumentExceptionForBusinessRuleViolations() {
        buyOrder.complete(); // Make order inactive

        // Test business rule validation
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity));
    }

    @Test
    @DisplayName("Should validate minimum transaction quantity")
    void shouldValidateMinimumTransactionQuantity() {
        BigDecimal zeroQuantity = BigDecimal.ZERO;
        BigDecimal negativeQuantity = new BigDecimal("-0.1");

        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, zeroQuantity));
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, negativeQuantity));
    }

    @Test
    @DisplayName("Should validate buy and sell orders have same symbol")
    void shouldValidateBuyAndSellOrdersHaveSameSymbol() {
        Symbol ethUsd = Symbol.ethUsd();
        ISellOrder differentSymbolSellOrder = new SellOrder("sell-2", ethUsd,
                Money.of("3000", Currency.USD), quantity);

        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, differentSymbolSellOrder, price, quantity));
    }

    @Test
    @DisplayName("Should validate transaction symbol matches order symbols")
    void shouldValidateTransactionSymbolMatchesOrderSymbols() {
        Symbol ethUsd = Symbol.ethUsd();

        // Orders are BTC/USD but transaction claims ETH/USD
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", ethUsd, buyOrder, sellOrder, price, quantity));
    }
    @Test
    @DisplayName("Should validate price currency matches symbol quote currency")
    void shouldValidatePriceCurrencyMatchesSymbolQuoteCurrency() {
        Symbol btcEur = Symbol.btcEur(); // BTC quoted in EUR
        Money usdPrice = Money.of("45000", Currency.USD); // Wrong currency

        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcEur, buyOrder, sellOrder, usdPrice, quantity));
    }
    @Test
    @DisplayName("Should update orders to FILLED when fully executed")
    void shouldUpdateOrdersToFilledWhenFullyExecuted() {
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity);

        // Verify orders are marked as filled after transaction
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
    }
    @Test
    @DisplayName("Should transition PENDING orders to FILLED when fully executed")
    void shouldTransitionPendingOrdersToFilledWhenFullyExecuted() {
        // Given: PENDING orders with exact quantity
        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, quantity);

        assertEquals(OrderStatusEnum.PENDING, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PENDING, sellOrder.getStatus().getStatus());

        // When: Transaction created with full quantity
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, quantity);

        // Then: Orders should be FILLED
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
        assertNotNull(transaction);
    }

    @Test
    @DisplayName("Should transition PARTIAL orders to FILLED when remaining quantity fully executed")
    void shouldTransitionPartialOrdersToFilledWhenRemainingQuantityFullyExecuted() {
        // Given: Orders with larger quantity, partially filled
        BigDecimal orderQuantity = new BigDecimal("2.0");
        BigDecimal executionQuantity = new BigDecimal("2.0"); // Execute remaining

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // Make orders partial first
        buyOrder.fillPartial();
        sellOrder.fillPartial();
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());

        // When: Transaction created with full remaining quantity
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, executionQuantity);

        // Then: Orders should be FILLED
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
    }

    // ===== PARTIAL EXECUTION TESTS =====

    @Test
    @DisplayName("Should transition PENDING orders to PARTIAL when partially executed")
    void shouldTransitionPendingOrdersToPartialWhenPartiallyExecuted() {
        // Given: PENDING orders with larger quantity
        BigDecimal orderQuantity = new BigDecimal("2.0");
        BigDecimal executionQuantity = new BigDecimal("0.5"); // Partial execution

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        assertEquals(OrderStatusEnum.PENDING, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PENDING, sellOrder.getStatus().getStatus());

        // When: Transaction created with partial quantity
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, executionQuantity);

        // Then: Orders should be PARTIAL
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());
        assertNotNull(transaction);
    }

    @Test
    @DisplayName("Should keep PARTIAL orders as PARTIAL when further partially executed")
    void shouldKeepPartialOrdersAsPartialWhenFurtherPartiallyExecuted() {
        // Given: PARTIAL orders with remaining quantity
        BigDecimal orderQuantity = new BigDecimal("3.0");
        BigDecimal executionQuantity = new BigDecimal("1.0"); // Further partial execution

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // Make orders partial first
        buyOrder.fillPartial();
        sellOrder.fillPartial();
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());

        // When: Transaction created with further partial quantity
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, executionQuantity);

        // Then: Orders should remain PARTIAL
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());
    }

    // ===== MIXED EXECUTION TESTS =====

    @Test
    @DisplayName("Should handle different order quantities with partial execution")
    void shouldHandleDifferentOrderQuantitiesWithPartialExecution() {
        // Given: Orders with different quantities
        BigDecimal buyOrderQuantity = new BigDecimal("2.0");
        BigDecimal sellOrderQuantity = new BigDecimal("1.5");
        BigDecimal executionQuantity = new BigDecimal("1.0"); // Partial for both

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, buyOrderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, sellOrderQuantity);

        // When: Transaction created
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, executionQuantity);

        // Then: Both should be PARTIAL (neither fully executed)
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());
    }

    @Test
    @DisplayName("Should handle one order fully executed, other partially executed")
    void shouldHandleOneOrderFullyExecutedOtherPartiallyExecuted() {
        // Given: Orders with different quantities
        BigDecimal buyOrderQuantity = new BigDecimal("1.0");
        BigDecimal sellOrderQuantity = new BigDecimal("2.0");
        BigDecimal executionQuantity = new BigDecimal("1.0"); // Fills buy, partial sell

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, buyOrderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, sellOrderQuantity);

        // When: Transaction created
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, executionQuantity);

        // Then: Buy order FILLED, sell order PARTIAL
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());
    }

    // ===== EDGE CASES =====

    @Test
    @DisplayName("Should not change state for zero quantity execution")
    void shouldNotChangeStateForZeroQuantityExecution() {
        // This test would fail with current validation - zero quantity is rejected
        // But conceptually tests edge case handling
    }

    @Test
    @DisplayName("Should handle minimum quantity execution")
    void shouldHandleMinimumQuantityExecution() {
        BigDecimal orderQuantity = new BigDecimal("1.0");
        BigDecimal minExecution = new BigDecimal("0.001"); // Very small execution

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, minExecution);

        // Should transition to PARTIAL for small execution
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());
    }
    @Test
    @DisplayName("Should allow valid order matching when prices overlap")
    void shouldAllowValidOrderMatchingWhenPricesOverlap() {
        Money buyOrderPrice = Money.of("45000", Currency.USD);   // Willing to pay UP TO $45,000
        Money sellOrderPrice = Money.of("44000", Currency.USD);  // Willing to sell FOR AT LEAST $44,000
        Money transactionPrice = Money.of("45000", Currency.USD); // Execution at buy price (valid)

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyOrderPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellOrderPrice, quantity);

        // This SHOULD succeed - buy price >= sell price and execution price is within range
        assertDoesNotThrow(
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, transactionPrice, quantity));
    }

    @Test
    @DisplayName("Should allow execution at sell price when prices overlap")
    void shouldAllowExecutionAtSellPriceWhenPricesOverlap() {
        Money buyOrderPrice = Money.of("45000", Currency.USD);   // Willing to pay UP TO $45,000
        Money sellOrderPrice = Money.of("44000", Currency.USD);  // Willing to sell FOR AT LEAST $44,000
        Money transactionPrice = Money.of("44000", Currency.USD); // Execution at sell price (valid)

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyOrderPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellOrderPrice, quantity);

        // This SHOULD succeed - execution price equals sell price (minimum acceptable)
        assertDoesNotThrow(
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, transactionPrice, quantity));
    }

    @Test
    @DisplayName("Should allow execution at mid-point when prices overlap")
    void shouldAllowExecutionAtMidPointWhenPricesOverlap() {
        Money buyOrderPrice = Money.of("46000", Currency.USD);   // Willing to pay UP TO $46,000
        Money sellOrderPrice = Money.of("44000", Currency.USD);  // Willing to sell FOR AT LEAST $44,000
        Money transactionPrice = Money.of("45000", Currency.USD); // Mid-point execution (fair)

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyOrderPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellOrderPrice, quantity);

        // This SHOULD succeed - execution price is fair mid-point
        assertDoesNotThrow(
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, transactionPrice, quantity));
    }

    @Test
    @DisplayName("Should reject orders when buy price is less than sell price")
    void shouldRejectOrdersWhenBuyPriceIsLessThanSellPrice() {
        Money buyOrderPrice = Money.of("44000", Currency.USD);   // Willing to pay UP TO $44,000
        Money sellOrderPrice = Money.of("45000", Currency.USD);  // Willing to sell FOR AT LEAST $45,000
        Money transactionPrice = Money.of("44500", Currency.USD); // No valid execution possible

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyOrderPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellOrderPrice, quantity);

        // This SHOULD fail - buy price < sell price (no overlap)
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, transactionPrice, quantity));
    }

    @Test
    @DisplayName("Should reject execution price below sell price")
    void shouldRejectExecutionPriceBelowSellPrice() {
        Money buyOrderPrice = Money.of("46000", Currency.USD);   // Willing to pay UP TO $46,000
        Money sellOrderPrice = Money.of("44000", Currency.USD);  // Willing to sell FOR AT LEAST $44,000
        Money transactionPrice = Money.of("43000", Currency.USD); // Below sell price (invalid)

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyOrderPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellOrderPrice, quantity);

        // This SHOULD fail - execution price below seller's minimum
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, transactionPrice, quantity));
    }

    @Test
    @DisplayName("Should reject execution price above buy price")
    void shouldRejectExecutionPriceAboveBuyPrice() {
        Money buyOrderPrice = Money.of("46000", Currency.USD);   // Willing to pay UP TO $46,000
        Money sellOrderPrice = Money.of("44000", Currency.USD);  // Willing to sell FOR AT LEAST $44,000
        Money transactionPrice = Money.of("47000", Currency.USD); // Above buy price (invalid)

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, buyOrderPrice, quantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, sellOrderPrice, quantity);

        // This SHOULD fail - execution price above buyer's maximum
        assertThrows(IllegalArgumentException.class,
                () -> new Transaction("tx-1", btcUsd, buyOrder, sellOrder, transactionPrice, quantity));
    }



}=== ./order/QuantityTrackingTest.java ===
package core.ms.order;

import core.ms.order.domain.entities.*;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.assertEquals;

@DisplayName("2. Quantity Tracking Tests")
class QuantityTrackingTest {

    private Symbol btcUsd;
    private Money price;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
        price = Money.of("45000", Currency.USD);
    }

    @Test
    @DisplayName("Should track executed quantity after transaction")
    void shouldTrackExecutedQuantityAfterTransaction() {
        // Given: Order with 2.0 BTC
        BigDecimal orderQuantity = new BigDecimal("2.0");
        BigDecimal transactionQuantity = new BigDecimal("0.5");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Transaction executes 0.5 BTC
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, transactionQuantity);

        // Then: Orders should track executed quantity
        assertEquals(transactionQuantity, buyOrder.getExecutedQuantity());
        assertEquals(transactionQuantity, sellOrder.getExecutedQuantity());
    }

    @Test
    @DisplayName("Should track remaining quantity after transaction")
    void shouldTrackRemainingQuantityAfterTransaction() {
        // Given: Order with 2.0 BTC
        BigDecimal orderQuantity = new BigDecimal("2.0");
        BigDecimal transactionQuantity = new BigDecimal("0.5");
        BigDecimal expectedRemaining = new BigDecimal("1.5");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Transaction executes 0.5 BTC
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, transactionQuantity);

        // Then: Orders should track remaining quantity
        assertEquals(expectedRemaining, buyOrder.getRemainingQuantity());
        assertEquals(expectedRemaining, sellOrder.getRemainingQuantity());
    }

    @Test
    @DisplayName("Should accumulate executed quantity across multiple transactions")
    void shouldAccumulateExecutedQuantityAcrossMultipleTransactions() {
        // Given: Order with 3.0 BTC
        BigDecimal orderQuantity = new BigDecimal("3.0");
        BigDecimal firstTransaction = new BigDecimal("1.0");
        BigDecimal secondTransaction = new BigDecimal("0.5");
        BigDecimal expectedExecuted = new BigDecimal("1.5");
        BigDecimal expectedRemaining = new BigDecimal("1.5");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Multiple transactions execute
        Transaction tx1 = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, firstTransaction);
        Transaction tx2 = new Transaction("tx-2", btcUsd, buyOrder, sellOrder, price, secondTransaction);

        // Then: Should accumulate executed quantities
        assertEquals(expectedExecuted, buyOrder.getExecutedQuantity());
        assertEquals(expectedExecuted, sellOrder.getExecutedQuantity());
        assertEquals(expectedRemaining, buyOrder.getRemainingQuantity());
        assertEquals(expectedRemaining, sellOrder.getRemainingQuantity());
    }

    @Test
    @DisplayName("Should have zero remaining quantity when order is fully executed")
    void shouldHaveZeroRemainingQuantityWhenOrderIsFullyExecuted() {
        // Given: Order with 1.0 BTC
        BigDecimal orderQuantity = new BigDecimal("1.0");

        IBuyOrder buyOrder = new BuyOrder("buy-1", btcUsd, price, orderQuantity);
        ISellOrder sellOrder = new SellOrder("sell-1", btcUsd, price, orderQuantity);

        // When: Transaction executes full quantity
        Transaction transaction = new Transaction("tx-1", btcUsd, buyOrder, sellOrder, price, orderQuantity);

        // Then: Remaining quantity should be zero
        assertEquals(BigDecimal.ZERO, buyOrder.getRemainingQuantity());
        assertEquals(BigDecimal.ZERO, sellOrder.getRemainingQuantity());
        assertEquals(orderQuantity, buyOrder.getExecutedQuantity());
        assertEquals(orderQuantity, sellOrder.getExecutedQuantity());
    }
}

=== ./portfolio/domain/TransactionTypeTest.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.TransactionType;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Transaction Type Tests")
class TransactionTypeTest {

    @Test
    @DisplayName("Should correctly identify cash affecting transactions")
    void shouldCorrectlyIdentifyCashAffectingTransactions() {
        // All transaction types affect cash
        assertTrue(TransactionType.BUY.affectsCash());
        assertTrue(TransactionType.SELL.affectsCash());
        assertTrue(TransactionType.DEPOSIT.affectsCash());
        assertTrue(TransactionType.WITHDRAWAL.affectsCash());
    }

    @Test
    @DisplayName("Should correctly identify position affecting transactions")
    void shouldCorrectlyIdentifyPositionAffectingTransactions() {
        // Only BUY and SELL affect positions
        assertTrue(TransactionType.BUY.affectsPosition());
        assertTrue(TransactionType.SELL.affectsPosition());
        assertFalse(TransactionType.DEPOSIT.affectsPosition());
        assertFalse(TransactionType.WITHDRAWAL.affectsPosition());
    }

    @Test
    @DisplayName("Should correctly identify asset transactions")
    void shouldCorrectlyIdentifyAssetTransactions() {
        // BUY and SELL are asset transactions
        assertTrue(TransactionType.BUY.isAssetTransaction());
        assertTrue(TransactionType.SELL.isAssetTransaction());
        assertFalse(TransactionType.DEPOSIT.isAssetTransaction());
        assertFalse(TransactionType.WITHDRAWAL.isAssetTransaction());
    }

    @Test
    @DisplayName("Should correctly identify cash transactions")
    void shouldCorrectlyIdentifyCashTransactions() {
        // DEPOSIT and WITHDRAWAL are cash-only transactions
        assertFalse(TransactionType.BUY.isCashTransaction());
        assertFalse(TransactionType.SELL.isCashTransaction());
        assertTrue(TransactionType.DEPOSIT.isCashTransaction());
        assertTrue(TransactionType.WITHDRAWAL.isCashTransaction());
    }

    @Test
    @DisplayName("Should correctly identify cash increasing transactions")
    void shouldCorrectlyIdentifyCashIncreasingTransactions() {
        // SELL and DEPOSIT increase cash
        assertFalse(TransactionType.BUY.increasesCash());
        assertTrue(TransactionType.SELL.increasesCash());
        assertTrue(TransactionType.DEPOSIT.increasesCash());
        assertFalse(TransactionType.WITHDRAWAL.increasesCash());
    }

    @Test
    @DisplayName("Should correctly identify cash decreasing transactions")
    void shouldCorrectlyIdentifyCashDecreasingTransactions() {
        // BUY and WITHDRAWAL decrease cash
        assertTrue(TransactionType.BUY.decreasesCash());
        assertFalse(TransactionType.SELL.decreasesCash());
        assertFalse(TransactionType.DEPOSIT.decreasesCash());
        assertTrue(TransactionType.WITHDRAWAL.decreasesCash());
    }

    @Test
    @DisplayName("Should have proper descriptions")
    void shouldHaveProperDescriptions() {
        assertEquals("Asset Purchase", TransactionType.BUY.getDescription());
        assertEquals("Asset Sale", TransactionType.SELL.getDescription());
        assertEquals("Cash Deposit", TransactionType.DEPOSIT.getDescription());
        assertEquals("Cash Withdrawal", TransactionType.WITHDRAWAL.getDescription());
    }

    @Test
    @DisplayName("Should have proper toString representation")
    void shouldHaveProperToStringRepresentation() {
        assertEquals("Asset Purchase", TransactionType.BUY.toString());
        assertEquals("Asset Sale", TransactionType.SELL.toString());
        assertEquals("Cash Deposit", TransactionType.DEPOSIT.toString());
        assertEquals("Cash Withdrawal", TransactionType.WITHDRAWAL.toString());
    }

    @Test
    @DisplayName("Should have all expected enum values")
    void shouldHaveAllExpectedEnumValues() {
        TransactionType[] values = TransactionType.values();
        assertEquals(4, values.length);

        assertTrue(java.util.Arrays.asList(values).contains(TransactionType.BUY));
        assertTrue(java.util.Arrays.asList(values).contains(TransactionType.SELL));
        assertTrue(java.util.Arrays.asList(values).contains(TransactionType.DEPOSIT));
        assertTrue(java.util.Arrays.asList(values).contains(TransactionType.WITHDRAWAL));
    }
}=== ./portfolio/domain/PositionTest.java ===
package core.ms.portfolio.domain;

import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Position Tests")
class PositionTest {

    private String positionId;
    private String portfolioId;
    private Symbol testSymbol;
    private BigDecimal initialQuantity;
    private Money initialPrice;
    private Position position;

    @BeforeEach
    void setUp() {
        positionId = "pos-123";
        portfolioId = "portfolio-456";
        testSymbol = Symbol.btcUsd();
        initialQuantity = new BigDecimal("1.0");
        initialPrice = Money.of("50000.00", Currency.USD);
        position = new Position(positionId, portfolioId, testSymbol, initialQuantity, initialPrice);
    }

    @Nested
    @DisplayName("Position Creation Tests")
    class PositionCreationTests {

        @Test
        @DisplayName("Should create position successfully")
        void shouldCreatePositionSuccessfully() {
            // Then
            assertEquals(positionId, position.getId());
            assertEquals(portfolioId, position.getPortfolioId());
            assertEquals(testSymbol, position.getSymbol());
            assertEquals(initialQuantity, position.getQuantity());
            assertEquals(initialPrice, position.getAveragePrice());
            assertNotNull(position.getCreatedAt());
            assertNotNull(position.getUpdatedAt());
            assertEquals("BTC", position.getSymbolCode());
        }

        @Test
        @DisplayName("Should throw exception for null required fields")
        void shouldThrowExceptionForNullRequiredFields() {
            // When & Then
            assertThrows(NullPointerException.class, () ->
                    new Position(null, portfolioId, testSymbol, initialQuantity, initialPrice));

            assertThrows(NullPointerException.class, () ->
                    new Position(positionId, null, testSymbol, initialQuantity, initialPrice));

            assertThrows(NullPointerException.class, () ->
                    new Position(positionId, portfolioId, null, initialQuantity, initialPrice));

            assertThrows(NullPointerException.class, () ->
                    new Position(positionId, portfolioId, testSymbol, null, initialPrice));

            assertThrows(NullPointerException.class, () ->
                    new Position(positionId, portfolioId, testSymbol, initialQuantity, null));
        }

        @Test
        @DisplayName("Should validate quantity and price constraints")
        void shouldValidateQuantityAndPriceConstraints() {
            // When & Then - Negative quantity should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new Position(positionId, portfolioId, testSymbol, new BigDecimal("-1.0"), initialPrice));

            // When & Then - Negative price should throw
            Money negativePrice = Money.of("-100.00", Currency.USD);
            assertThrows(IllegalArgumentException.class, () ->
                    new Position(positionId, portfolioId, testSymbol, initialQuantity, negativePrice));
        }

        @Test
        @DisplayName("Should allow zero quantity position")
        void shouldAllowZeroQuantityPosition() {
            // When
            Position zeroPosition = new Position(positionId, portfolioId, testSymbol, BigDecimal.ZERO, initialPrice);

            // Then
            assertEquals(BigDecimal.ZERO, zeroPosition.getQuantity());
            assertTrue(zeroPosition.isEmpty());
        }
    }

    @Nested
    @DisplayName("Value Calculation Tests")
    class ValueCalculationTests {

        @Test
        @DisplayName("Should calculate current value correctly")
        void shouldCalculateCurrentValueCorrectly() {
            // Given
            Money currentPrice = Money.of("60000.00", Currency.USD);

            // When
            Money currentValue = position.getCurrentValue(currentPrice);

            // Then
            Money expectedValue = currentPrice.multiply(initialQuantity);
            assertEquals(expectedValue, currentValue);
        }

        @Test
        @DisplayName("Should calculate cost basis correctly")
        void shouldCalculateCostBasisCorrectly() {
            // When
            Money costBasis = position.getCostBasis();

            // Then
            Money expectedCostBasis = initialPrice.multiply(initialQuantity);
            assertEquals(expectedCostBasis, costBasis);
        }

        @Test
        @DisplayName("Should calculate profit correctly")
        void shouldCalculateProfitCorrectly() {
            // Given
            Money currentPrice = Money.of("60000.00", Currency.USD); // Price increased

            // When
            Money profitLoss = position.getProfitLoss(currentPrice);

            // Then
            Money expectedProfit = Money.of("10000.00", Currency.USD); // (60000 - 50000) * 1.0
            assertEquals(expectedProfit, profitLoss);
            assertTrue(profitLoss.isPositive());
        }

        @Test
        @DisplayName("Should calculate loss correctly")
        void shouldCalculateLossCorrectly() {
            // Given
            Money currentPrice = Money.of("40000.00", Currency.USD); // Price decreased

            // When
            Money profitLoss = position.getProfitLoss(currentPrice);

            // Then
            Money expectedLoss = Money.of("-10000.00", Currency.USD); // (40000 - 50000) * 1.0
            assertEquals(expectedLoss, profitLoss);
            assertTrue(profitLoss.isNegative());
        }

        @Test
        @DisplayName("Should calculate profit loss percentage correctly")
        void shouldCalculateProfitLossPercentageCorrectly() {
            // Given
            Money currentPrice = Money.of("60000.00", Currency.USD); // 20% increase

            // When
            BigDecimal profitLossPercentage = position.getProfitLossPercentage(currentPrice);

            // Then
            assertEquals(new BigDecimal("20.0000"), profitLossPercentage);
        }

        @Test
        @DisplayName("Should handle zero cost basis for percentage calculation")
        void shouldHandleZeroCostBasisForPercentageCalculation() {
            // Given
            Position zeroPosition = new Position(positionId, portfolioId, testSymbol,
                    BigDecimal.ZERO, Money.zero(Currency.USD));
            Money currentPrice = Money.of("60000.00", Currency.USD);

            // When
            BigDecimal profitLossPercentage = zeroPosition.getProfitLossPercentage(currentPrice);

            // Then
            assertEquals(BigDecimal.ZERO, profitLossPercentage);
        }

        @Test
        @DisplayName("Should validate currency consistency in calculations")
        void shouldValidateCurrencyConsistencyInCalculations() {
            // Given
            Money wrongCurrencyPrice = Money.of("50000.00", Currency.EUR);

            // When & Then
            assertThrows(IllegalArgumentException.class, () ->
                    position.getCurrentValue(wrongCurrencyPrice));

            assertThrows(IllegalArgumentException.class, () ->
                    position.getProfitLoss(wrongCurrencyPrice));

            assertThrows(IllegalArgumentException.class, () ->
                    position.getProfitLossPercentage(wrongCurrencyPrice));
        }
    }

    @Nested
    @DisplayName("Quantity Management Tests")
    class QuantityManagementTests {

        @Test
        @DisplayName("Should add quantity and update average price correctly")
        void shouldAddQuantityAndUpdateAveragePriceCorrectly() {
            // Given
            BigDecimal additionalQuantity = new BigDecimal("1.0");
            Money newPrice = Money.of("60000.00", Currency.USD);

            // When
            position.addQuantity(additionalQuantity, newPrice);

            // Then
            assertEquals(new BigDecimal("2.0"), position.getQuantity());
            // Weighted average: ((1.0 * 50000) + (1.0 * 60000)) / 2.0 = 55000
            Money expectedAveragePrice = Money.of("55000.00", Currency.USD);
            assertEquals(expectedAveragePrice, position.getAveragePrice());
        }

        @Test
        @DisplayName("Should add quantity with complex weighted average")
        void shouldAddQuantityWithComplexWeightedAverage() {
            // Given - Start with 2.0 BTC at $50,000 avg
            position.addQuantity(new BigDecimal("1.0"), Money.of("50000.00", Currency.USD));

            // When - Add 1.0 BTC at $70,000
            position.addQuantity(new BigDecimal("1.0"), Money.of("70000.00", Currency.USD));

            // Then
            assertEquals(new BigDecimal("3.0"), position.getQuantity());
            // Weighted average: ((2.0 * 50000) + (1.0 * 70000)) / 3.0 = 56666.67
            Money expectedAveragePrice = Money.of("56666.67", Currency.USD);
            assertEquals(expectedAveragePrice.getAmount().setScale(2),
                    position.getAveragePrice().getAmount().setScale(2));
        }

        @Test
        @DisplayName("Should remove quantity correctly")
        void shouldRemoveQuantityCorrectly() {
            // Given
            BigDecimal quantityToRemove = new BigDecimal("0.5");

            // When
            position.removeQuantity(quantityToRemove);

            // Then
            assertEquals(new BigDecimal("0.5"), position.getQuantity());
            assertEquals(initialPrice, position.getAveragePrice()); // Average price unchanged
            assertFalse(position.isEmpty());
        }

        @Test
        @DisplayName("Should remove all quantity and become empty")
        void shouldRemoveAllQuantityAndBecomeEmpty() {
            // When
            position.removeQuantity(initialQuantity);

            // Then
            assertEquals(BigDecimal.ZERO, position.getQuantity());
            assertTrue(position.isEmpty());
        }

        @Test
        @DisplayName("Should validate quantity addition constraints")
        void shouldValidateQuantityAdditionConstraints() {
            // When & Then - Null quantity
            assertThrows(NullPointerException.class, () ->
                    position.addQuantity(null, initialPrice));

            // When & Then - Null price
            assertThrows(NullPointerException.class, () ->
                    position.addQuantity(new BigDecimal("1.0"), null));

            // When & Then - Zero quantity
            assertThrows(IllegalArgumentException.class, () ->
                    position.addQuantity(BigDecimal.ZERO, initialPrice));

            // When & Then - Negative quantity
            assertThrows(IllegalArgumentException.class, () ->
                    position.addQuantity(new BigDecimal("-0.5"), initialPrice));

            // When & Then - Wrong currency
            Money wrongCurrencyPrice = Money.of("60000.00", Currency.EUR);
            assertThrows(IllegalArgumentException.class, () ->
                    position.addQuantity(new BigDecimal("1.0"), wrongCurrencyPrice));
        }

        @Test
        @DisplayName("Should validate quantity removal constraints")
        void shouldValidateQuantityRemovalConstraints() {
            // When & Then - Null quantity
            assertThrows(NullPointerException.class, () ->
                    position.removeQuantity(null));

            // When & Then - Zero quantity
            assertThrows(IllegalArgumentException.class, () ->
                    position.removeQuantity(BigDecimal.ZERO));

            // When & Then - Negative quantity
            assertThrows(IllegalArgumentException.class, () ->
                    position.removeQuantity(new BigDecimal("-0.5")));

            // When & Then - Insufficient quantity
            assertThrows(IllegalArgumentException.class, () ->
                    position.removeQuantity(new BigDecimal("2.0"))); // Only have 1.0
        }

        @Test
        @DisplayName("Should check sufficient quantity correctly")
        void shouldCheckSufficientQuantityCorrectly() {
            // Then
            assertTrue(position.hasSufficientQuantity(new BigDecimal("0.5")));
            assertTrue(position.hasSufficientQuantity(new BigDecimal("1.0")));
            assertFalse(position.hasSufficientQuantity(new BigDecimal("1.5")));
        }
    }

    @Nested
    @DisplayName("Equality and String Representation Tests")
    class EqualityAndStringTests {

        @Test
        @DisplayName("Should have proper equality based on ID")
        void shouldHaveProperEqualityBasedOnId() {
            // Given
            Position position1 = new Position(positionId, portfolioId, testSymbol, initialQuantity, initialPrice);
            Position position2 = new Position(positionId, "different-portfolio", testSymbol, initialQuantity, initialPrice);
            Position position3 = new Position("different-id", portfolioId, testSymbol, initialQuantity, initialPrice);

            // When & Then
            assertEquals(position1, position2); // Same ID
            assertNotEquals(position1, position3); // Different ID
            assertEquals(position1.hashCode(), position2.hashCode());
        }

        @Test
        @DisplayName("Should have proper string representation")
        void shouldHaveProperStringRepresentation() {
            // When
            String result = position.toString();

            // Then
            assertTrue(result.contains(positionId));
            assertTrue(result.contains("1"));
            assertTrue(result.contains("BTC"));
            assertTrue(result.contains(initialPrice.toString()));
        }
    }
}=== ./portfolio/domain/PortfolioTransactionTest.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.TransactionType;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Portfolio Transaction Tests")
class PortfolioTransactionTest {

    private String transactionId;
    private String portfolioId;
    private Symbol testSymbol;
    private Money testPrice;
    private Money totalAmount;

    @BeforeEach
    void setUp() {
        transactionId = "tx-123";
        portfolioId = "portfolio-456";
        testSymbol = Symbol.btcUsd();
        testPrice = Money.of("50000.00", Currency.USD);
        totalAmount = Money.of("5000.00", Currency.USD);
    }

    @Nested
    @DisplayName("Asset Transaction Tests")
    class AssetTransactionTests {

        @Test
        @DisplayName("Should create buy transaction successfully")
        void shouldCreateBuyTransactionSuccessfully() {
            // Given
            BigDecimal quantity = new BigDecimal("0.1");
            String orderId = "order-789";

            // When
            PortfolioTransaction transaction = PortfolioTransaction.createBuyTransaction(
                    transactionId, portfolioId, testSymbol, quantity, testPrice, orderId);

            // Then
            assertEquals(transactionId, transaction.getId());
            assertEquals(portfolioId, transaction.getPortfolioId());
            assertEquals(TransactionType.BUY, transaction.getType());
            assertEquals(testSymbol, transaction.getSymbol());
            assertEquals(quantity, transaction.getQuantity());
            assertEquals(testPrice, transaction.getPrice());
            assertEquals(testPrice.multiply(quantity), transaction.getTotalAmount());
            assertEquals(orderId, transaction.getRelatedOrderId());
            assertNotNull(transaction.getTimestamp());

            assertTrue(transaction.isAssetTransaction());
            assertFalse(transaction.isCashTransaction());
            assertTrue(transaction.affectsCashBalance());
            assertTrue(transaction.affectsPosition());
        }

        @Test
        @DisplayName("Should create sell transaction successfully")
        void shouldCreateSellTransactionSuccessfully() {
            // Given
            BigDecimal quantity = new BigDecimal("0.05");
            String orderId = "order-790";

            // When
            PortfolioTransaction transaction = PortfolioTransaction.createSellTransaction(
                    transactionId, portfolioId, testSymbol, quantity, testPrice, orderId);

            // Then
            assertEquals(transactionId, transaction.getId());
            assertEquals(portfolioId, transaction.getPortfolioId());
            assertEquals(TransactionType.SELL, transaction.getType());
            assertEquals(testSymbol, transaction.getSymbol());
            assertEquals(quantity, transaction.getQuantity());
            assertEquals(testPrice, transaction.getPrice());
            assertEquals(testPrice.multiply(quantity), transaction.getTotalAmount());
            assertEquals(orderId, transaction.getRelatedOrderId());

            assertTrue(transaction.isAssetTransaction());
            assertFalse(transaction.isCashTransaction());
            assertTrue(transaction.affectsCashBalance());
            assertTrue(transaction.affectsPosition());
        }

        @Test
        @DisplayName("Should get symbol code correctly")
        void shouldGetSymbolCodeCorrectly() {
            // Given
            PortfolioTransaction transaction = PortfolioTransaction.createBuyTransaction(
                    transactionId, portfolioId, testSymbol, new BigDecimal("0.1"), testPrice, null);

            // When & Then
            assertEquals("BTC", transaction.getSymbolCode());
        }

        @Test
        @DisplayName("Should validate asset transaction requirements")
        void shouldValidateAssetTransactionRequirements() {
            // When & Then - Missing symbol should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, TransactionType.BUY,
                            null, new BigDecimal("0.1"), testPrice, totalAmount, null));

            // When & Then - Missing price should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, TransactionType.BUY,
                            testSymbol, new BigDecimal("0.1"), null, totalAmount, null));

            // When & Then - Zero quantity should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, TransactionType.BUY,
                            testSymbol, BigDecimal.ZERO, testPrice, totalAmount, null));

            // When & Then - Negative quantity should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, TransactionType.BUY,
                            testSymbol, new BigDecimal("-0.1"), testPrice, totalAmount, null));
        }
    }

    @Nested
    @DisplayName("Cash Transaction Tests")
    class CashTransactionTests {

        @Test
        @DisplayName("Should create deposit transaction successfully")
        void shouldCreateDepositTransactionSuccessfully() {
            // Given
            Money depositAmount = Money.of("1000.00", Currency.USD);

            // When
            PortfolioTransaction transaction = PortfolioTransaction.createDepositTransaction(
                    transactionId, portfolioId, depositAmount);

            // Then
            assertEquals(transactionId, transaction.getId());
            assertEquals(portfolioId, transaction.getPortfolioId());
            assertEquals(TransactionType.DEPOSIT, transaction.getType());
            assertNull(transaction.getSymbol());
            assertEquals(BigDecimal.ZERO, transaction.getQuantity());
            assertNull(transaction.getPrice());
            assertEquals(depositAmount, transaction.getTotalAmount());
            assertNull(transaction.getRelatedOrderId());

            assertFalse(transaction.isAssetTransaction());
            assertTrue(transaction.isCashTransaction());
            assertTrue(transaction.affectsCashBalance());
            assertFalse(transaction.affectsPosition());
        }

        @Test
        @DisplayName("Should create withdrawal transaction successfully")
        void shouldCreateWithdrawalTransactionSuccessfully() {
            // Given
            Money withdrawalAmount = Money.of("500.00", Currency.USD);

            // When
            PortfolioTransaction transaction = PortfolioTransaction.createWithdrawalTransaction(
                    transactionId, portfolioId, withdrawalAmount);

            // Then
            assertEquals(transactionId, transaction.getId());
            assertEquals(portfolioId, transaction.getPortfolioId());
            assertEquals(TransactionType.WITHDRAWAL, transaction.getType());
            assertNull(transaction.getSymbol());
            assertEquals(BigDecimal.ZERO, transaction.getQuantity());
            assertNull(transaction.getPrice());
            assertEquals(withdrawalAmount, transaction.getTotalAmount());
            assertNull(transaction.getRelatedOrderId());

            assertFalse(transaction.isAssetTransaction());
            assertTrue(transaction.isCashTransaction());
            assertTrue(transaction.affectsCashBalance());
            assertFalse(transaction.affectsPosition());
        }

        @Test
        @DisplayName("Should return null symbol code for cash transactions")
        void shouldReturnNullSymbolCodeForCashTransactions() {
            // Given
            PortfolioTransaction transaction = PortfolioTransaction.createDepositTransaction(
                    transactionId, portfolioId, totalAmount);

            // When & Then
            assertNull(transaction.getSymbolCode());
        }

        @Test
        @DisplayName("Should validate cash transaction requirements")
        void shouldValidateCashTransactionRequirements() {
            // When & Then - Symbol should be null for cash transactions
            assertThrows(IllegalArgumentException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, TransactionType.DEPOSIT,
                            testSymbol, BigDecimal.ZERO, null, totalAmount, null));

            // When & Then - Price should be null for cash transactions
            assertThrows(IllegalArgumentException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, TransactionType.DEPOSIT,
                            null, BigDecimal.ZERO, testPrice, totalAmount, null));
        }
    }

    @Nested
    @DisplayName("Validation Tests")
    class ValidationTests {

        @Test
        @DisplayName("Should throw exception for null required fields")
        void shouldThrowExceptionForNullRequiredFields() {
            // When & Then - Null transaction ID
            assertThrows(NullPointerException.class, () ->
                    new PortfolioTransaction(null, portfolioId, TransactionType.DEPOSIT,
                            null, BigDecimal.ZERO, null, totalAmount, null));

            // When & Then - Null portfolio ID
            assertThrows(NullPointerException.class, () ->
                    new PortfolioTransaction(transactionId, null, TransactionType.DEPOSIT,
                            null, BigDecimal.ZERO, null, totalAmount, null));

            // When & Then - Null transaction type
            assertThrows(NullPointerException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, null,
                            null, BigDecimal.ZERO, null, totalAmount, null));

            // When & Then - Null total amount
            assertThrows(NullPointerException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, TransactionType.DEPOSIT,
                            null, BigDecimal.ZERO, null, null, null));
        }

        @Test
        @DisplayName("Should throw exception for negative total amount")
        void shouldThrowExceptionForNegativeTotalAmount() {
            // Given
            Money negativeAmount = Money.of("-100.00", Currency.USD);

            // When & Then
            assertThrows(IllegalArgumentException.class, () ->
                    new PortfolioTransaction(transactionId, portfolioId, TransactionType.DEPOSIT,
                            null, BigDecimal.ZERO, null, negativeAmount, null));
        }
    }

    @Nested
    @DisplayName("Equality and String Representation Tests")
    class EqualityAndStringTests {

        @Test
        @DisplayName("Should have proper equality based on ID")
        void shouldHaveProperEqualityBasedOnId() {
            // Given
            PortfolioTransaction transaction1 = PortfolioTransaction.createDepositTransaction(
                    transactionId, portfolioId, totalAmount);
            PortfolioTransaction transaction2 = PortfolioTransaction.createDepositTransaction(
                    transactionId, "different-portfolio", totalAmount);
            PortfolioTransaction transaction3 = PortfolioTransaction.createDepositTransaction(
                    "different-id", portfolioId, totalAmount);

            // When & Then
            assertEquals(transaction1, transaction2); // Same ID
            assertNotEquals(transaction1, transaction3); // Different ID
            assertEquals(transaction1.hashCode(), transaction2.hashCode());
        }

        @Test
        @DisplayName("Should have proper string representation for asset transactions")
        void shouldHaveProperStringRepresentationForAssetTransactions() {
            // Given
            PortfolioTransaction transaction = PortfolioTransaction.createBuyTransaction(
                    transactionId, portfolioId, testSymbol, new BigDecimal("0.1"), testPrice, "order-123");

            // When
            String result = transaction.toString();

            // Then
            assertTrue(result.contains(transactionId));
            assertTrue(result.contains("Asset Purchase")); // Changed from "BUY" to the actual description
            assertTrue(result.contains("0.1"));
            assertTrue(result.contains("BTC"));
            assertTrue(result.contains(testPrice.toString()));

            // Debug output to see actual format
            System.out.println("Asset transaction toString: " + result);
        }

        @Test
        @DisplayName("Should have proper string representation for cash transactions")
        void shouldHaveProperStringRepresentationForCashTransactions() {
            // Given
            PortfolioTransaction transaction = PortfolioTransaction.createDepositTransaction(
                    transactionId, portfolioId, totalAmount);

            // When
            String result = transaction.toString();

            // Then
            assertTrue(result.contains(transactionId));
            assertTrue(result.contains("Cash Deposit")); // Changed from "DEPOSIT" to the actual description
            assertTrue(result.contains(totalAmount.toString()));

            // Debug output to see actual format
            System.out.println("Cash transaction toString: " + result);
        }
    }
}=== ./portfolio/domain/PortfolioTest.java ===
package core.ms.portfolio.domain;

import core.ms.portfolio.domain.value.TransactionType;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Portfolio Tests")
class PortfolioTest {

    private String portfolioId;
    private String portfolioName;
    private String userId;
    private Money initialCash;
    private Portfolio portfolio;

    @BeforeEach
    void setUp() {
        portfolioId = "portfolio-123";
        portfolioName = "My Investment Portfolio";
        userId = "user-456";
        initialCash = Money.of("10000.00", Currency.USD);
        portfolio = new Portfolio(portfolioId, portfolioName, userId, initialCash);
    }

    @Nested
    @DisplayName("Portfolio Creation Tests")
    class PortfolioCreationTests {

        @Test
        @DisplayName("Should create portfolio successfully")
        void shouldCreatePortfolioSuccessfully() {
            // Then
            assertEquals(portfolioId, portfolio.getId());
            assertEquals(portfolioName, portfolio.getName());
            assertEquals(userId, portfolio.getUserId());
            assertEquals(initialCash, portfolio.getCashBalance());
            assertEquals(Currency.USD, portfolio.getBaseCurrency());
            assertNotNull(portfolio.getCreatedAt());
            assertNotNull(portfolio.getUpdatedAt());
            assertTrue(portfolio.getPositions().isEmpty());
            assertTrue(portfolio.getTransactions().isEmpty());
        }

        @Test
        @DisplayName("Should throw exception for null required fields")
        void shouldThrowExceptionForNullRequiredFields() {
            // When & Then
            assertThrows(NullPointerException.class, () ->
                    new Portfolio(null, portfolioName, userId, initialCash));

            assertThrows(NullPointerException.class, () ->
                    new Portfolio(portfolioId, null, userId, initialCash));

            assertThrows(NullPointerException.class, () ->
                    new Portfolio(portfolioId, portfolioName, null, initialCash));

            assertThrows(NullPointerException.class, () ->
                    new Portfolio(portfolioId, portfolioName, userId, null));
        }

        @Test
        @DisplayName("Should validate portfolio constraints")
        void shouldValidatePortfolioConstraints() {
            // When & Then - Empty name should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new Portfolio(portfolioId, "", userId, initialCash));

            assertThrows(IllegalArgumentException.class, () ->
                    new Portfolio(portfolioId, "   ", userId, initialCash));

            // When & Then - Negative initial cash should throw
            Money negativeCash = Money.of("-100.00", Currency.USD);
            assertThrows(IllegalArgumentException.class, () ->
                    new Portfolio(portfolioId, portfolioName, userId, negativeCash));
        }
    }

    @Nested
    @DisplayName("Cash Management Tests")
    class CashManagementTests {

        @Test
        @DisplayName("Should deposit cash successfully")
        void shouldDepositCashSuccessfully() {
            // Given
            Money depositAmount = Money.of("5000.00", Currency.USD);
            Money expectedBalance = Money.of("15000.00", Currency.USD);

            // When
            PortfolioTransaction transaction = portfolio.depositCash(depositAmount);

            // Then
            assertEquals(expectedBalance, portfolio.getCashBalance());
            assertNotNull(transaction);
            assertEquals(TransactionType.DEPOSIT, transaction.getType());
            assertEquals(depositAmount, transaction.getTotalAmount());
            assertEquals(1, portfolio.getTransactions().size());
        }

        @Test
        @DisplayName("Should withdraw cash successfully")
        void shouldWithdrawCashSuccessfully() {
            // Given
            Money withdrawalAmount = Money.of("3000.00", Currency.USD);
            Money expectedBalance = Money.of("7000.00", Currency.USD);

            // When
            PortfolioTransaction transaction = portfolio.withdrawCash(withdrawalAmount);

            // Then
            assertEquals(expectedBalance, portfolio.getCashBalance());
            assertNotNull(transaction);
            assertEquals(TransactionType.WITHDRAWAL, transaction.getType());
            assertEquals(withdrawalAmount, transaction.getTotalAmount());
            assertEquals(1, portfolio.getTransactions().size());
        }

        @Test
        @DisplayName("Should validate cash deposit constraints")
        void shouldValidateCashDepositConstraints() {
            // When & Then - Null amount
            assertThrows(NullPointerException.class, () ->
                    portfolio.depositCash(null));

            // When & Then - Zero amount
            assertThrows(IllegalArgumentException.class, () ->
                    portfolio.depositCash(Money.zero(Currency.USD)));

            // When & Then - Negative amount
            assertThrows(IllegalArgumentException.class, () ->
                    portfolio.depositCash(Money.of("-100.00", Currency.USD)));

            // When & Then - Wrong currency
            assertThrows(IllegalArgumentException.class, () ->
                    portfolio.depositCash(Money.of("1000.00", Currency.EUR)));
        }

        @Test
        @DisplayName("Should validate cash withdrawal constraints")
        void shouldValidateCashWithdrawalConstraints() {
            // When & Then - Insufficient funds
            Money largeAmount = Money.of("15000.00", Currency.USD);
            assertThrows(IllegalArgumentException.class, () ->
                    portfolio.withdrawCash(largeAmount));

            // When & Then - Wrong currency
            assertThrows(IllegalArgumentException.class, () ->
                    portfolio.withdrawCash(Money.of("1000.00", Currency.EUR)));
        }

        @Test
        @DisplayName("Should check affordability correctly")
        void shouldCheckAffordabilityCorrectly() {
            // Then
            assertTrue(portfolio.canAfford(Money.of("5000.00", Currency.USD)));
            assertTrue(portfolio.canAfford(Money.of("10000.00", Currency.USD)));
            assertFalse(portfolio.canAfford(Money.of("15000.00", Currency.USD)));
        }
    }

    @Nested
    @DisplayName("Asset Trading Tests")
    class AssetTradingTests {

        @Test
        @DisplayName("Should buy asset successfully")
        void shouldBuyAssetSuccessfully() {
            // Given
            Symbol btcSymbol = Symbol.btcUsd();
            BigDecimal quantity = new BigDecimal("0.2");
            Money price = Money.of("50000.00", Currency.USD);
            String orderId = "order-123";
            Money expectedCost = Money.of("10000.00", Currency.USD);
            Money expectedCashBalance = Money.zero(Currency.USD); // 10000 - 10000

            // When
            PortfolioTransaction transaction = portfolio.buyAsset(btcSymbol, quantity, price, orderId);

            // Then
            assertEquals(expectedCashBalance, portfolio.getCashBalance());
            assertEquals(1, portfolio.getPositions().size());

            Optional<Position> position = portfolio.getPosition(btcSymbol);
            assertTrue(position.isPresent());
            assertEquals(quantity, position.get().getQuantity());
            assertEquals(price, position.get().getAveragePrice());

            assertNotNull(transaction);
            assertEquals(TransactionType.BUY, transaction.getType());
            assertEquals(expectedCost, transaction.getTotalAmount());
            assertEquals(orderId, transaction.getRelatedOrderId());
            assertEquals(1, portfolio.getTransactions().size());
        }

        @Test
        @DisplayName("Should sell asset successfully")
        void shouldSellAssetSuccessfully() {
            // Given - First buy some assets
            Symbol btcSymbol = Symbol.btcUsd();
            BigDecimal buyQuantity = new BigDecimal("0.2");
            Money buyPrice = Money.of("50000.00", Currency.USD);
            portfolio.buyAsset(btcSymbol, buyQuantity, buyPrice, "buy-order");

            // When - Sell half
            BigDecimal sellQuantity = new BigDecimal("0.1");
            Money sellPrice = Money.of("60000.00", Currency.USD);
            String sellOrderId = "sell-order";
            Money expectedProceeds = Money.of("6000.00", Currency.USD);
            Money expectedCashBalance = Money.of("6000.00", Currency.USD); // 0 + 6000

            PortfolioTransaction transaction = portfolio.sellAsset(btcSymbol, sellQuantity, sellPrice, sellOrderId);

            // Then
            assertEquals(expectedCashBalance, portfolio.getCashBalance());

            Optional<Position> position = portfolio.getPosition(btcSymbol);
            assertTrue(position.isPresent());
            assertEquals(new BigDecimal("0.1"), position.get().getQuantity());
            assertEquals(buyPrice, position.get().getAveragePrice()); // Average price unchanged

            assertNotNull(transaction);
            assertEquals(TransactionType.SELL, transaction.getType());
            assertEquals(expectedProceeds, transaction.getTotalAmount());
            assertEquals(sellOrderId, transaction.getRelatedOrderId());
            assertEquals(2, portfolio.getTransactions().size());
        }

        @Test
        @DisplayName("Should sell entire position and remove it")
        void shouldSellEntirePositionAndRemoveIt() {
            // Given - Buy some assets
            Symbol btcSymbol = Symbol.btcUsd();
            BigDecimal quantity = new BigDecimal("0.2");
            Money price = Money.of("50000.00", Currency.USD);
            portfolio.buyAsset(btcSymbol, quantity, price, "buy-order");

            // When - Sell entire position
            portfolio.sellAsset(btcSymbol, quantity, price, "sell-order");

            // Then
            assertTrue(portfolio.getPosition(btcSymbol).isEmpty());
            assertEquals(0, portfolio.getPositions().size());
        }

        @Test
        @DisplayName("Should handle multiple positions correctly")
        void shouldHandleMultiplePositionsCorrectly() {
            // Given
            Symbol btcSymbol = Symbol.btcUsd();
            Symbol ethSymbol = Symbol.ethUsd();

            // When - CORRECTED AMOUNTS to fit within $10,000 budget
            portfolio.buyAsset(btcSymbol, new BigDecimal("0.1"), Money.of("50000.00", Currency.USD), null);  // $5,000
            portfolio.buyAsset(ethSymbol, new BigDecimal("1.5"), Money.of("3000.00", Currency.USD), null);   // $4,500

            // Then
            assertEquals(2, portfolio.getPositions().size());
            assertTrue(portfolio.getPosition(btcSymbol).isPresent());
            assertTrue(portfolio.getPosition(ethSymbol).isPresent());
            assertEquals(Money.of("500.00", Currency.USD), portfolio.getCashBalance()); // 10000 - 5000 - 4500 = 500
        }

        @Test
        @DisplayName("Should validate asset trading constraints")
        void shouldValidateAssetTradingConstraints() {
            Symbol btcSymbol = Symbol.btcUsd();

            // When & Then - Insufficient cash for buying
            Money expensivePrice = Money.of("100000.00", Currency.USD);
            assertThrows(IllegalArgumentException.class, () ->
                    portfolio.buyAsset(btcSymbol, new BigDecimal("0.2"), expensivePrice, null));

            // When & Then - Selling non-existent position
            assertThrows(IllegalArgumentException.class, () ->
                    portfolio.sellAsset(btcSymbol, new BigDecimal("0.1"), Money.of("50000.00", Currency.USD), null));

            // Given - Buy some assets
            portfolio.buyAsset(btcSymbol, new BigDecimal("0.1"), Money.of("50000.00", Currency.USD), null);

            // When & Then - Selling more than available
            assertThrows(IllegalArgumentException.class, () ->
                    portfolio.sellAsset(btcSymbol, new BigDecimal("0.2"), Money.of("50000.00", Currency.USD), null));
        }
    }

    @Nested
    @DisplayName("Portfolio Valuation Tests")
    class PortfolioValuationTests {

        @Test
        @DisplayName("Should calculate total value correctly")
        void shouldCalculateTotalValueCorrectly() {
            // Given
            Symbol btcSymbol = Symbol.btcUsd();
            Symbol ethSymbol = Symbol.ethUsd();

            // CORRECTED AMOUNTS to fit within budget
            portfolio.buyAsset(btcSymbol, new BigDecimal("0.1"), Money.of("50000.00", Currency.USD), null);   // $5,000
            portfolio.buyAsset(ethSymbol, new BigDecimal("1.5"), Money.of("3000.00", Currency.USD), null);    // $4,500

            Map<Symbol, Money> currentPrices = new HashMap<>();
            currentPrices.put(btcSymbol, Money.of("60000.00", Currency.USD)); // BTC up 20%
            currentPrices.put(ethSymbol, Money.of("2500.00", Currency.USD));  // ETH down 16.67%

            // When
            Money totalValue = portfolio.getTotalValue(currentPrices);

            // Then
            // Cash: 500 (10000 - 5000 - 4500)
            // BTC: 0.1 * 60000 = 6000
            // ETH: 1.5 * 2500 = 3750
            // Total: 500 + 6000 + 3750 = 10250
            Money expectedTotalValue = Money.of("10250.00", Currency.USD);
            assertEquals(expectedTotalValue, totalValue);
        }

        @Test
        @DisplayName("Should calculate total profit loss correctly")
        void shouldCalculateTotalProfitLossCorrectly() {
            // Given
            Symbol btcSymbol = Symbol.btcUsd();
            portfolio.buyAsset(btcSymbol, new BigDecimal("0.1"), Money.of("50000.00", Currency.USD), null);

            Map<Symbol, Money> currentPrices = new HashMap<>();
            currentPrices.put(btcSymbol, Money.of("60000.00", Currency.USD)); // 20% gain

            // When
            Money totalProfitLoss = portfolio.getTotalProfitLoss(currentPrices);

            // Then
            Money expectedProfitLoss = Money.of("1000.00", Currency.USD); // (60000 - 50000) * 0.1
            assertEquals(expectedProfitLoss, totalProfitLoss);
        }

        @Test
        @DisplayName("Should calculate total invested correctly")
        void shouldCalculateTotalInvestedCorrectly() {
            // Given
            Symbol btcSymbol = Symbol.btcUsd();
            Symbol ethSymbol = Symbol.ethUsd();

            // CORRECTED AMOUNTS
            portfolio.buyAsset(btcSymbol, new BigDecimal("0.1"), Money.of("50000.00", Currency.USD), null);   // $5,000
            portfolio.buyAsset(ethSymbol, new BigDecimal("1.5"), Money.of("3000.00", Currency.USD), null);    // $4,500

            // When
            Money totalInvested = portfolio.getTotalInvested();

            // Then
            Money expectedInvested = Money.of("9500.00", Currency.USD); // 5000 + 4500
            assertEquals(expectedInvested, totalInvested);
        }
    }

    @Nested
    @DisplayName("Transaction History Tests")
    class TransactionHistoryTests {

        @Test
        @DisplayName("Should get transactions by type correctly")
        void shouldGetTransactionsByTypeCorrectly() {
            // Given
            portfolio.depositCash(Money.of("5000.00", Currency.USD));
            portfolio.withdrawCash(Money.of("1000.00", Currency.USD));
            portfolio.buyAsset(Symbol.btcUsd(), new BigDecimal("0.1"), Money.of("50000.00", Currency.USD), null);

            // When
            List<PortfolioTransaction> cashTransactions = portfolio.getTransactionsByType(TransactionType.DEPOSIT);
            List<PortfolioTransaction> buyTransactions = portfolio.getTransactionsByType(TransactionType.BUY);

            // Then
            assertEquals(1, cashTransactions.size());
            assertEquals(TransactionType.DEPOSIT, cashTransactions.get(0).getType());

            assertEquals(1, buyTransactions.size());
            assertEquals(TransactionType.BUY, buyTransactions.get(0).getType());
        }

        @Test
        @DisplayName("Should get transactions for symbol correctly")
        void shouldGetTransactionsForSymbolCorrectly() {
            // Given
            Symbol btcSymbol = Symbol.btcUsd();
            Symbol ethSymbol = Symbol.ethUsd();

            // CORRECTED AMOUNTS to fit within budget
            portfolio.buyAsset(btcSymbol, new BigDecimal("0.08"), Money.of("50000.00", Currency.USD), null);  // $4,000
            portfolio.buyAsset(ethSymbol, new BigDecimal("1.0"), Money.of("3000.00", Currency.USD), null);    // $3,000
            portfolio.buyAsset(btcSymbol, new BigDecimal("0.05"), Money.of("55000.00", Currency.USD), null);  // $2,750

            // Total spent: $4,000 + $3,000 + $2,750 = $9,750 (within $10,000 budget)

            // When
            List<PortfolioTransaction> btcTransactions = portfolio.getTransactionsForSymbol(btcSymbol);
            List<PortfolioTransaction> ethTransactions = portfolio.getTransactionsForSymbol(ethSymbol);

            // Then
            assertEquals(2, btcTransactions.size());
            assertEquals(1, ethTransactions.size());

            btcTransactions.forEach(tx -> assertEquals(btcSymbol, tx.getSymbol()));
            ethTransactions.forEach(tx -> assertEquals(ethSymbol, tx.getSymbol()));

            // Verify cash balance
            assertEquals(Money.of("250.00", Currency.USD), portfolio.getCashBalance()); // 10000 - 9750
        }
    }

    @Nested
    @DisplayName("Equality and String Representation Tests")
    class EqualityAndStringTests {

        @Test
        @DisplayName("Should have proper equality based on ID")
        void shouldHaveProperEqualityBasedOnId() {
            // Given
            Portfolio portfolio1 = new Portfolio(portfolioId, portfolioName, userId, initialCash);
            Portfolio portfolio2 = new Portfolio(portfolioId, "Different Name", "different-user", initialCash);
            Portfolio portfolio3 = new Portfolio("different-id", portfolioName, userId, initialCash);

            // When & Then
            assertEquals(portfolio1, portfolio2); // Same ID
            assertNotEquals(portfolio1, portfolio3); // Different ID
            assertEquals(portfolio1.hashCode(), portfolio2.hashCode());
        }

        @Test
        @DisplayName("Should have proper string representation")
        void shouldHaveProperStringRepresentation() {
            // When
            String result = portfolio.toString();

            // Then
            assertTrue(result.contains(portfolioId));
            assertTrue(result.contains(portfolioName));
            assertTrue(result.contains(initialCash.toString()));
        }
    }
}=== ./order_book/SellOrderPriorityCalculatorTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.ISellOrder;
import core.ms.order_book.domain.value_object.SellOrderPriorityCalculator;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@DisplayName("Sell Order Priority Calculator Tests")
class SellOrderPriorityCalculatorTest {

    private SellOrderPriorityCalculator calculator;
    private ISellOrder sellOrder1;
    private ISellOrder sellOrder2;
    private LocalDateTime earlierTime;
    private LocalDateTime laterTime;

    @BeforeEach
    void setUp() {
        calculator = new SellOrderPriorityCalculator();
        earlierTime = LocalDateTime.of(2024, 1, 1, 10, 0);
        laterTime = LocalDateTime.of(2024, 1, 1, 10, 5);

        sellOrder1 = mock(ISellOrder.class);
        sellOrder2 = mock(ISellOrder.class);
    }

    @Nested
    @DisplayName("Price Priority Tests")
    class PricePriorityTests {

        @Test
        @DisplayName("Should prioritize lower price over higher price")
        void should_prioritize_lower_price_over_higher_price() {
            // Given: Two different prices
            Money lowerPrice = Money.of("99.50", Currency.USD);
            Money higherPrice = Money.of("100.00", Currency.USD);

            // When: Comparing prices
            boolean result = calculator.isPriceBetter(lowerPrice, higherPrice);

            // Then: Lower price should be better
            assertTrue(result);
        }

        @Test
        @DisplayName("Should not prioritize higher price over lower price")
        void should_not_prioritize_higher_price_over_lower_price() {
            // Given: Two different prices
            Money lowerPrice = Money.of("99.50", Currency.USD);
            Money higherPrice = Money.of("100.00", Currency.USD);

            // When: Comparing prices (reversed)
            boolean result = calculator.isPriceBetter(higherPrice, lowerPrice);

            // Then: Higher price should not be better
            assertFalse(result);
        }

        @Test
        @DisplayName("Should prioritize earlier time when same price")
        void should_prioritize_earlier_time_when_same_price() {
            // Given: Two orders at same price, different times
            Money samePrice = Money.of("100.00", Currency.USD);

            when(sellOrder1.getPrice()).thenReturn(samePrice);
            when(sellOrder1.getCreatedAt()).thenReturn(earlierTime);
            when(sellOrder2.getPrice()).thenReturn(samePrice);
            when(sellOrder2.getCreatedAt()).thenReturn(laterTime);

            // When: Comparing order priority
            boolean result = calculator.isHigherPriority(sellOrder1, sellOrder2);

            // Then: Earlier order should have priority
            assertTrue(result);
        }
    }
}=== ./order_book/OrderBookTest.java ===
package core.ms.order_book;

import core.ms.order_book.domain.OrderBook;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order.domain.entities.ISellOrder;
import core.ms.order_book.domain.value_object.*;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import core.ms.shared.domain.Currency;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.Collection;
import java.util.List;

@DisplayName("Order Book Tests")
class OrderBookTest {

    private OrderBook orderBook;
    private Symbol symbol;
    private IBuyOrder buyOrder1;
    private IBuyOrder buyOrder2;
    private IBuyOrder buyOrder3;
    private ISellOrder sellOrder1;
    private ISellOrder sellOrder2;
    private ISellOrder sellOrder3;

    @BeforeEach
    void setUp() {
        symbol = Symbol.btcUsd();
        orderBook = new OrderBook(symbol);

        // Setup buy orders with different prices and times
        buyOrder1 = createMockBuyOrder("buy1", Money.of("101.00", Currency.USD),
                new BigDecimal("10"), LocalDateTime.of(2024, 1, 1, 10, 0));
        buyOrder2 = createMockBuyOrder("buy2", Money.of("100.00", Currency.USD),
                new BigDecimal("5"), LocalDateTime.of(2024, 1, 1, 10, 1));
        buyOrder3 = createMockBuyOrder("buy3", Money.of("101.00", Currency.USD),
                new BigDecimal("8"), LocalDateTime.of(2024, 1, 1, 10, 2));

        // Setup sell orders with different prices and times
        sellOrder1 = createMockSellOrder("sell1", Money.of("102.00", Currency.USD),
                new BigDecimal("6"), LocalDateTime.of(2024, 1, 1, 10, 0));
        sellOrder2 = createMockSellOrder("sell2", Money.of("103.00", Currency.USD),
                new BigDecimal("4"), LocalDateTime.of(2024, 1, 1, 10, 1));
        sellOrder3 = createMockSellOrder("sell3", Money.of("102.00", Currency.USD),
                new BigDecimal("7"), LocalDateTime.of(2024, 1, 1, 10, 2));
    }

    @Nested
    @DisplayName("Order Book Initialization Tests")
    class InitializationTests {

        @Test
        @DisplayName("Should initialize empty order book correctly")
        void should_initialize_empty_order_book_correctly() {
            // Given: New order book
            OrderBook newBook = new OrderBook(symbol);

            // When/Then: Should be empty
            assertEquals(symbol, newBook.getSymbol());
            assertTrue(newBook.isEmpty());
            assertFalse(newBook.hasOrders());
            assertEquals(0, newBook.getOrderCount());
            assertEquals(BigDecimal.ZERO, newBook.getTotalBidVolume());
            assertEquals(BigDecimal.ZERO, newBook.getTotalAskVolume());
            assertFalse(newBook.getBestBid().isPresent());
            assertFalse(newBook.getBestAsk().isPresent());
            assertFalse(newBook.getSpread().isPresent());
            assertFalse(newBook.getBestBuyOrder().isPresent());
            assertFalse(newBook.getBestSellOrder().isPresent());
            assertTrue(newBook.getBidLevels().isEmpty());
            assertTrue(newBook.getAskLevels().isEmpty());
            assertNotNull(newBook.getLastUpdate());
        }

        @Test
        @DisplayName("Should reject null symbol")
        void should_reject_null_symbol() {
            // When/Then: Should throw exception
            assertThrows(NullPointerException.class, () ->
                    new OrderBook(null));
        }
    }

    @Nested
    @DisplayName("Buy Order Management Tests")
    class BuyOrderManagementTests {

        @Test
        @DisplayName("Should add buy order to correct bid level")
        void should_add_buy_order_to_correct_bid_level() {
            // Given: Empty order book
            assertTrue(orderBook.isEmpty());

            // When: Adding buy order
            orderBook.addOrder(buyOrder1);

            // Then: Should create bid level and add order
            assertFalse(orderBook.isEmpty());
            assertTrue(orderBook.hasOrders());
            assertEquals(1, orderBook.getOrderCount());
            assertEquals(Money.of("101.00", Currency.USD), orderBook.getBestBid().get());
            assertEquals("buy1", orderBook.getBestBuyOrder().get().getId());
            assertEquals(new BigDecimal("10"), orderBook.getTotalBidVolume());
            assertEquals(BigDecimal.ZERO, orderBook.getTotalAskVolume());

            // And: Should have one bid level
            Collection<BidPriceLevel> bidLevels = orderBook.getBidLevels();
            assertEquals(1, bidLevels.size());
            BidPriceLevel bidLevel = bidLevels.iterator().next();
            assertEquals(Money.of("101.00", Currency.USD), bidLevel.getPrice());
            assertEquals(1, bidLevel.getOrderCount());
            assertEquals(new BigDecimal("10"), bidLevel.getTotalQuantity());
        }

        @Test
        @DisplayName("Should maintain price priority across bid levels")
        void should_maintain_price_priority_across_bid_levels() {
            // Given: Order book

            // When: Adding buy orders at different prices
            orderBook.addOrder(buyOrder2); // $100.00
            orderBook.addOrder(buyOrder1); // $101.00 (higher)

            // Then: Best bid should be highest price
            assertEquals(Money.of("101.00", Currency.USD), orderBook.getBestBid().get());
            assertEquals("buy1", orderBook.getBestBuyOrder().get().getId());

            // And: Total volume should be aggregated
            assertEquals(new BigDecimal("15"), orderBook.getTotalBidVolume());

            // And: Should have two bid levels
            Collection<BidPriceLevel> bidLevels = orderBook.getBidLevels();
            assertEquals(2, bidLevels.size());
        }

        @Test
        @DisplayName("Should handle multiple orders at same price level")
        void should_handle_multiple_orders_at_same_price_level() {
            // Given: Order book

            // When: Adding multiple orders at same price
            orderBook.addOrder(buyOrder1); // $101.00, time 10:00
            orderBook.addOrder(buyOrder3); // $101.00, time 10:02

            // Then: Should aggregate volume and maintain time priority
            assertEquals(new BigDecimal("18"), orderBook.getTotalBidVolume());
            assertEquals("buy1", orderBook.getBestBuyOrder().get().getId()); // Earlier time
            assertEquals(2, orderBook.getOrderCount());

            // And: Should have one bid level with multiple orders
            Collection<BidPriceLevel> bidLevels = orderBook.getBidLevels();
            assertEquals(1, bidLevels.size());
            BidPriceLevel bidLevel = bidLevels.iterator().next();
            assertEquals(2, bidLevel.getOrderCount());
            assertEquals(new BigDecimal("18"), bidLevel.getTotalQuantity());
        }

        @Test
        @DisplayName("Should update last update time when adding order")
        void should_update_last_update_time_when_adding_order() {
            // Given: Order book with initial time
            LocalDateTime initialTime = orderBook.getLastUpdate();

            // When: Adding order after a delay
            try {
                Thread.sleep(1); // Ensure time difference
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            orderBook.addOrder(buyOrder1);

            // Then: Last update should be more recent
            assertTrue(orderBook.getLastUpdate().isAfter(initialTime));
        }
    }

    @Nested
    @DisplayName("Sell Order Management Tests")
    class SellOrderManagementTests {

        @Test
        @DisplayName("Should add sell order to correct ask level")
        void should_add_sell_order_to_correct_ask_level() {
            // Given: Empty order book
            assertTrue(orderBook.isEmpty());

            // When: Adding sell order
            orderBook.addOrder(sellOrder1);

            // Then: Should create ask level and add order
            assertFalse(orderBook.isEmpty());
            assertTrue(orderBook.hasOrders());
            assertEquals(1, orderBook.getOrderCount());
            assertEquals(Money.of("102.00", Currency.USD), orderBook.getBestAsk().get());
            assertEquals("sell1", orderBook.getBestSellOrder().get().getId());
            assertEquals(BigDecimal.ZERO, orderBook.getTotalBidVolume());
            assertEquals(new BigDecimal("6"), orderBook.getTotalAskVolume());

            // And: Should have one ask level
            Collection<AskPriceLevel> askLevels = orderBook.getAskLevels();
            assertEquals(1, askLevels.size());
            AskPriceLevel askLevel = askLevels.iterator().next();
            assertEquals(Money.of("102.00", Currency.USD), askLevel.getPrice());
            assertEquals(1, askLevel.getOrderCount());
            assertEquals(new BigDecimal("6"), askLevel.getTotalQuantity());
        }

        @Test
        @DisplayName("Should maintain price priority across ask levels")
        void should_maintain_price_priority_across_ask_levels() {
            // Given: Order book

            // When: Adding sell orders at different prices
            orderBook.addOrder(sellOrder2); // $103.00
            orderBook.addOrder(sellOrder1); // $102.00 (lower/better)

            // Then: Best ask should be lowest price
            assertEquals(Money.of("102.00", Currency.USD), orderBook.getBestAsk().get());
            assertEquals("sell1", orderBook.getBestSellOrder().get().getId());

            // And: Total volume should be aggregated
            assertEquals(new BigDecimal("10"), orderBook.getTotalAskVolume());

            // And: Should have two ask levels
            Collection<AskPriceLevel> askLevels = orderBook.getAskLevels();
            assertEquals(2, askLevels.size());
        }

        @Test
        @DisplayName("Should handle multiple orders at same ask level")
        void should_handle_multiple_orders_at_same_ask_level() {
            // Given: Order book

            // When: Adding multiple orders at same price
            orderBook.addOrder(sellOrder1); // $102.00, time 10:00
            orderBook.addOrder(sellOrder3); // $102.00, time 10:02

            // Then: Should aggregate volume and maintain time priority
            assertEquals(new BigDecimal("13"), orderBook.getTotalAskVolume());
            assertEquals("sell1", orderBook.getBestSellOrder().get().getId()); // Earlier time
            assertEquals(2, orderBook.getOrderCount());

            // And: Should have one ask level with multiple orders
            Collection<AskPriceLevel> askLevels = orderBook.getAskLevels();
            assertEquals(1, askLevels.size());
            AskPriceLevel askLevel = askLevels.iterator().next();
            assertEquals(2, askLevel.getOrderCount());
            assertEquals(new BigDecimal("13"), askLevel.getTotalQuantity());
        }
    }

    @Nested
    @DisplayName("Order Removal Tests")
    class OrderRemovalTests {

        @Test
        @DisplayName("Should remove buy order and update metrics")
        void should_remove_buy_order_and_update_metrics() {
            // Given: Order book with buy orders
            orderBook.addOrder(buyOrder1);
            orderBook.addOrder(buyOrder2);
            assertEquals(2, orderBook.getOrderCount());
            assertEquals(new BigDecimal("15"), orderBook.getTotalBidVolume());

            // When: Removing buy order
            boolean removed = orderBook.removeOrder(buyOrder1);

            // Then: Should remove successfully and update metrics
            assertTrue(removed);
            assertEquals(1, orderBook.getOrderCount());
            assertEquals(new BigDecimal("5"), orderBook.getTotalBidVolume());
            assertEquals(Money.of("100.00", Currency.USD), orderBook.getBestBid().get());
            assertEquals("buy2", orderBook.getBestBuyOrder().get().getId());
        }

        @Test
        @DisplayName("Should remove sell order and update metrics")
        void should_remove_sell_order_and_update_metrics() {
            // Given: Order book with sell orders
            orderBook.addOrder(sellOrder1);
            orderBook.addOrder(sellOrder2);
            assertEquals(2, orderBook.getOrderCount());
            assertEquals(new BigDecimal("10"), orderBook.getTotalAskVolume());

            // When: Removing sell order
            boolean removed = orderBook.removeOrder(sellOrder1);

            // Then: Should remove successfully and update metrics
            assertTrue(removed);
            assertEquals(1, orderBook.getOrderCount());
            assertEquals(new BigDecimal("4"), orderBook.getTotalAskVolume());
            assertEquals(Money.of("103.00", Currency.USD), orderBook.getBestAsk().get());
            assertEquals("sell2", orderBook.getBestSellOrder().get().getId());
        }

        @Test
        @DisplayName("Should remove empty price levels")
        void should_remove_empty_price_levels() {
            // Given: Price level with single order
            orderBook.addOrder(buyOrder1);
            assertEquals(1, orderBook.getBidLevels().size());

            // When: Removing the only order at that price
            boolean removed = orderBook.removeOrder(buyOrder1);

            // Then: Price level should be removed
            assertTrue(removed);
            assertTrue(orderBook.getBidLevels().isEmpty());
            assertFalse(orderBook.getBestBid().isPresent());
            assertFalse(orderBook.getBestBuyOrder().isPresent());
            assertEquals(BigDecimal.ZERO, orderBook.getTotalBidVolume());
            assertTrue(orderBook.isEmpty());
        }

        @Test
        @DisplayName("Should maintain best prices after removal")
        void should_maintain_best_prices_after_removal() {
            // Given: Multiple price levels
            orderBook.addOrder(buyOrder1); // $101.00 (best)
            orderBook.addOrder(buyOrder2); // $100.00 (second best)
            orderBook.addOrder(sellOrder1); // $102.00 (best ask)
            orderBook.addOrder(sellOrder2); // $103.00 (second best ask)

            // When: Removing best orders
            orderBook.removeOrder(buyOrder1);
            orderBook.removeOrder(sellOrder1);

            // Then: Second best should become best
            assertEquals(Money.of("100.00", Currency.USD), orderBook.getBestBid().get());
            assertEquals(Money.of("103.00", Currency.USD), orderBook.getBestAsk().get());
            assertEquals("buy2", orderBook.getBestBuyOrder().get().getId());
            assertEquals("sell2", orderBook.getBestSellOrder().get().getId());
        }

        @Test
        @DisplayName("Should return false when removing non-existent order")
        void should_return_false_when_removing_non_existent_order() {
            // Given: Order book with one order
            orderBook.addOrder(buyOrder1);
            int initialCount = orderBook.getOrderCount();

            // When: Removing different order
            boolean removed = orderBook.removeOrder(buyOrder2);

            // Then: Should return false and not affect book
            assertFalse(removed);
            assertEquals(initialCount, orderBook.getOrderCount());
            assertEquals(buyOrder1.getId(), orderBook.getBestBuyOrder().get().getId());
        }

        @Test
        @DisplayName("Should update last update time when removing order")
        void should_update_last_update_time_when_removing_order() {
            // Given: Order book with order
            orderBook.addOrder(buyOrder1);
            LocalDateTime timeAfterAdd = orderBook.getLastUpdate();

            // When: Removing order after a delay
            try {
                Thread.sleep(1); // Ensure time difference
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            orderBook.removeOrder(buyOrder1);

            // Then: Last update should be more recent
            assertTrue(orderBook.getLastUpdate().isAfter(timeAfterAdd));
        }
    }

    @Nested
    @DisplayName("Spread Calculation Tests")
    class SpreadCalculationTests {

        @Test
        @DisplayName("Should calculate spread correctly")
        void should_calculate_spread_correctly() {
            // Given: Order book with bid and ask
            orderBook.addOrder(buyOrder2);  // $100.00 (bid)
            orderBook.addOrder(sellOrder1); // $102.00 (ask)

            // When: Getting spread
            Optional<Money> spread = orderBook.getSpread();

            // Then: Should be ask - bid
            assertTrue(spread.isPresent());
            assertEquals(Money.of("2.00", Currency.USD), spread.get());
        }

        @Test
        @DisplayName("Should calculate spread with multiple levels")
        void should_calculate_spread_with_multiple_levels() {
            // Given: Order book with multiple levels
            orderBook.addOrder(buyOrder1); // $101.00 (best bid)
            orderBook.addOrder(buyOrder2); // $100.00
            orderBook.addOrder(sellOrder1); // $102.00 (best ask)
            orderBook.addOrder(sellOrder2); // $103.00

            // When: Getting spread
            Optional<Money> spread = orderBook.getSpread();

            // Then: Should use best bid and ask
            assertTrue(spread.isPresent());
            assertEquals(Money.of("1.00", Currency.USD), spread.get());
        }

        @Test
        @DisplayName("Should return empty spread when missing bid side")
        void should_return_empty_spread_when_missing_bid_side() {
            // Given: Order book with only ask
            orderBook.addOrder(sellOrder1);

            // When: Getting spread
            Optional<Money> spread = orderBook.getSpread();

            // Then: Should be empty
            assertFalse(spread.isPresent());
        }

        @Test
        @DisplayName("Should return empty spread when missing ask side")
        void should_return_empty_spread_when_missing_ask_side() {
            // Given: Order book with only bid
            orderBook.addOrder(buyOrder1);

            // When: Getting spread
            Optional<Money> spread = orderBook.getSpread();

            // Then: Should be empty
            assertFalse(spread.isPresent());
        }

        @Test
        @DisplayName("Should return empty spread when no orders")
        void should_return_empty_spread_when_no_orders() {
            // Given: Empty order book
            assertTrue(orderBook.isEmpty());

            // When: Getting spread
            Optional<Money> spread = orderBook.getSpread();

            // Then: Should be empty
            assertFalse(spread.isPresent());
        }
    }

    @Nested
    @DisplayName("Market Depth Tests")
    class MarketDepthTests {

        @Test
        @DisplayName("Should return correct market depth")
        void should_return_correct_market_depth() {
            // Given: Order book with multiple levels
            setupOrderBookWithMultipleLevels();

            // When: Getting market depth
            MarketDepth depth = orderBook.getMarketDepth(2);

            // Then: Should return top 2 levels each side
            assertEquals(2, depth.getBidLevels().size());
            assertEquals(2, depth.getAskLevels().size());
            assertEquals(symbol, depth.getSymbol());
            assertNotNull(depth.getTimestamp());

            // And: Should be price-ordered
            List<BidPriceLevel> bids = depth.getBidLevels();
            assertEquals(Money.of("101.00", Currency.USD), bids.get(0).getPrice()); // Best
            assertEquals(Money.of("100.00", Currency.USD), bids.get(1).getPrice()); // Second

            List<AskPriceLevel> asks = depth.getAskLevels();
            assertEquals(Money.of("102.00", Currency.USD), asks.get(0).getPrice()); // Best
            assertEquals(Money.of("103.00", Currency.USD), asks.get(1).getPrice()); // Second
        }

        @Test
        @DisplayName("Should limit depth to available levels")
        void should_limit_depth_to_available_levels() {
            // Given: Order book with 1 level each side
            orderBook.addOrder(buyOrder1);
            orderBook.addOrder(sellOrder1);

            // When: Requesting 5 levels
            MarketDepth depth = orderBook.getMarketDepth(5);

            // Then: Should return only available levels
            assertEquals(1, depth.getBidLevels().size());
            assertEquals(1, depth.getAskLevels().size());
            assertEquals(Money.of("101.00", Currency.USD), depth.getBidLevels().get(0).getPrice());
            assertEquals(Money.of("102.00", Currency.USD), depth.getAskLevels().get(0).getPrice());
        }

        @Test
        @DisplayName("Should handle empty order book")
        void should_handle_empty_order_book() {
            // Given: Empty order book
            assertTrue(orderBook.isEmpty());

            // When: Getting market depth
            MarketDepth depth = orderBook.getMarketDepth(5);

            // Then: Should return empty depth
            assertTrue(depth.getBidLevels().isEmpty());
            assertTrue(depth.getAskLevels().isEmpty());
            assertTrue(depth.isEmpty());
            assertEquals(0, depth.getLevelCount());
        }

        @Test
        @DisplayName("Should reject invalid depth levels")
        void should_reject_invalid_depth_levels() {
            // Given: Order book

            // When/Then: Should throw exception for invalid levels
            assertThrows(IllegalArgumentException.class, () ->
                    orderBook.getMarketDepth(0));
            assertThrows(IllegalArgumentException.class, () ->
                    orderBook.getMarketDepth(-1));
        }

        @Test
        @DisplayName("Should calculate depth metrics correctly")
        void should_calculate_depth_metrics_correctly() {
            // Given: Order book with multiple levels
            setupOrderBookWithMultipleLevels();

            // When: Getting market depth
            MarketDepth depth = orderBook.getMarketDepth(10);

            // Then: Should calculate metrics correctly
            assertEquals(new BigDecimal("15"), depth.getTotalBidVolume());
            assertEquals(new BigDecimal("10"), depth.getTotalAskVolume());
            assertEquals(Money.of("1.00", Currency.USD), depth.getSpread());
            assertEquals(Money.of("101.00", Currency.USD), depth.getBestBid().get().getPrice());
            assertEquals(Money.of("102.00", Currency.USD), depth.getBestAsk().get().getPrice());
        }
    }

    @Nested
    @DisplayName("Order Matching Tests")
    class OrderMatchingTests {

        @Test
        @DisplayName("Should find match when bid meets ask")
        void should_find_match_when_bid_meets_ask() {
            // Given: Orders that can match
            IBuyOrder matchingBuyOrder = createMockBuyOrder("buy-match",
                    Money.of("103.00", Currency.USD), new BigDecimal("10"),
                    LocalDateTime.of(2024, 1, 1, 10, 0));
            orderBook.addOrder(matchingBuyOrder);
            orderBook.addOrder(sellOrder1); // $102.00

            // When: Finding matches
            List<OrderMatch> matches = orderBook.findMatches();

            // Then: Should find one match
            assertEquals(1, matches.size());
            OrderMatch match = matches.get(0);
            assertEquals("buy-match", match.getBuyOrder().getId());
            assertEquals("sell1", match.getSellOrder().getId());
            assertEquals(new BigDecimal("6"), match.getMatchableQuantity());
            assertTrue(match.isValid());
        }

        @Test
        @DisplayName("Should not find match when bid below ask")
        void should_not_find_match_when_bid_below_ask() {
            // Given: Orders that cannot match
            orderBook.addOrder(buyOrder2); // $100.00
            orderBook.addOrder(sellOrder1); // $102.00

            // When: Finding matches
            List<OrderMatch> matches = orderBook.findMatches();

            // Then: Should find no matches
            assertTrue(matches.isEmpty());
        }

        @Test
        @DisplayName("Should not find match in empty order book")
        void should_not_find_match_in_empty_order_book() {
            // Given: Empty order book
            assertTrue(orderBook.isEmpty());

            // When: Finding matches
            List<OrderMatch> matches = orderBook.findMatches();

            // Then: Should find no matches
            assertTrue(matches.isEmpty());
        }

        @Test
        @DisplayName("Should not find match with only one side")
        void should_not_find_match_with_only_one_side() {
            // Given: Order book with only buy orders
            orderBook.addOrder(buyOrder1);
            orderBook.addOrder(buyOrder2);

            // When: Finding matches
            List<OrderMatch> matches = orderBook.findMatches();

            // Then: Should find no matches
            assertTrue(matches.isEmpty());
        }
    }

    @Nested
    @DisplayName("Order Validation Tests")
    class OrderValidationTests {

        @Test
        @DisplayName("Should reject order with wrong symbol")
        void should_reject_order_with_wrong_symbol() {
            // Given: Order with different symbol
            IBuyOrder wrongSymbolOrder = createMockBuyOrder("wrong-symbol",
                    Money.of("100.00", Currency.USD), new BigDecimal("10"),
                    LocalDateTime.of(2024, 1, 1, 10, 0));
            when(wrongSymbolOrder.getSymbol()).thenReturn(Symbol.ethUsd());

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    orderBook.addOrder(wrongSymbolOrder));
        }

        @Test
        @DisplayName("Should reject inactive order")
        void should_reject_inactive_order() {
            // Given: Inactive order
            IBuyOrder inactiveOrder = createMockBuyOrder("inactive",
                    Money.of("100.00", Currency.USD), new BigDecimal("10"),
                    LocalDateTime.of(2024, 1, 1, 10, 0));
            when(inactiveOrder.isActive()).thenReturn(false);

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    orderBook.addOrder(inactiveOrder));
        }

        @Test
        @DisplayName("Should reject duplicate order")
        void should_reject_duplicate_order() {
            // Given: Order already in book
            orderBook.addOrder(buyOrder1);

            // When/Then: Should throw exception for duplicate
            assertThrows(IllegalArgumentException.class, () ->
                    orderBook.addOrder(buyOrder1));
        }

        @Test
        @DisplayName("Should reject null order")
        void should_reject_null_order() {
            // When/Then: Should throw exception
            assertThrows(NullPointerException.class, () ->
                    orderBook.addOrder(null));
        }

        @Test
        @DisplayName("Should reject null order for removal")
        void should_reject_null_order_for_removal() {
            // When/Then: Should throw exception
            assertThrows(NullPointerException.class, () ->
                    orderBook.removeOrder(null));
        }
    }

    @Nested
    @DisplayName("State Query Tests")
    class StateQueryTests {

        @Test
        @DisplayName("Should return correct order count")
        void should_return_correct_order_count() {
            // Given: Empty order book
            assertEquals(0, orderBook.getOrderCount());

            // When: Adding orders
            orderBook.addOrder(buyOrder1);
            orderBook.addOrder(buyOrder2);
            orderBook.addOrder(sellOrder1);

            // Then: Should return correct count
            assertEquals(3, orderBook.getOrderCount());

            // When: Removing order
            orderBook.removeOrder(buyOrder1);

            // Then: Should update count
            assertEquals(2, orderBook.getOrderCount());
        }

        @Test
        @DisplayName("Should return correct volume metrics")
        void should_return_correct_volume_metrics() {
            // Given: Order book with mixed orders
            orderBook.addOrder(buyOrder1);  // 10
            orderBook.addOrder(buyOrder2);  // 5
            orderBook.addOrder(sellOrder1); // 6
            orderBook.addOrder(sellOrder2); // 4

            // When/Then: Should calculate volumes correctly
            assertEquals(new BigDecimal("15"), orderBook.getTotalBidVolume());
            assertEquals(new BigDecimal("10"), orderBook.getTotalAskVolume());
        }

        @Test
        @DisplayName("Should provide defensive copies of levels")
        void should_provide_defensive_copies_of_levels() {
            // Given: Order book with orders
            orderBook.addOrder(buyOrder1);
            orderBook.addOrder(sellOrder1);

            // When: Getting level collections
            Collection<BidPriceLevel> bidLevels = orderBook.getBidLevels();
            Collection<AskPriceLevel> askLevels = orderBook.getAskLevels();

            // Then: Should be defensive copies
            assertEquals(1, bidLevels.size());
            assertEquals(1, askLevels.size());

            // And: Modifying returned collections should not affect book
            bidLevels.clear();
            askLevels.clear();
            assertEquals(1, orderBook.getBidLevels().size());
            assertEquals(1, orderBook.getAskLevels().size());
        }
    }

    // Helper methods
    private void setupOrderBookWithMultipleLevels() {
        // Add multiple bid levels
        orderBook.addOrder(buyOrder1); // $101.00
        orderBook.addOrder(buyOrder2); // $100.00

        // Add multiple ask levels
        orderBook.addOrder(sellOrder1); // $102.00
        orderBook.addOrder(sellOrder2); // $103.00
    }

    private IBuyOrder createMockBuyOrder(String id, Money price, BigDecimal quantity, LocalDateTime time) {
        IBuyOrder order = mock(IBuyOrder.class);
        when(order.getId()).thenReturn(id);
        when(order.getSymbol()).thenReturn(symbol);
        when(order.getPrice()).thenReturn(price);
        when(order.getRemainingQuantity()).thenReturn(quantity);
        when(order.getCreatedAt()).thenReturn(time);
        when(order.isActive()).thenReturn(true);
        return order;
    }

    private ISellOrder createMockSellOrder(String id, Money price, BigDecimal quantity, LocalDateTime time) {
        ISellOrder order = mock(ISellOrder.class);
        when(order.getId()).thenReturn(id);
        when(order.getSymbol()).thenReturn(symbol);
        when(order.getPrice()).thenReturn(price);
        when(order.getRemainingQuantity()).thenReturn(quantity);
        when(order.getCreatedAt()).thenReturn(time);
        when(order.isActive()).thenReturn(true);
        return order;
    }
}=== ./order_book/MatchFinderTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order.domain.entities.ISellOrder;
import core.ms.order_book.domain.value_object.MatchFinder;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@DisplayName("Match Finder Tests")
class MatchFinderTest {

    private MatchFinder matchFinder;
    private IBuyOrder buyOrder;
    private ISellOrder sellOrder;
    private Symbol symbol;

    @BeforeEach
    void setUp() {
        matchFinder = new MatchFinder();
        symbol = Symbol.btcUsd();

        buyOrder = mock(IBuyOrder.class);
        sellOrder = mock(ISellOrder.class);
    }

    @Nested
    @DisplayName("Order Matching Tests")
    class OrderMatchingTests {

        @Test
        @DisplayName("Should match when bid meets ask")
        void should_match_when_bid_meets_ask() {
            // Given: Compatible orders
            setupCompatibleOrders(
                    Money.of("100.00", Currency.USD), // Buy price
                    Money.of("99.00", Currency.USD),  // Sell price
                    new BigDecimal("10"),             // Buy quantity
                    new BigDecimal("5")               // Sell quantity
            );

            // When: Checking if orders can match
            boolean canMatch = matchFinder.canMatch(buyOrder, sellOrder);

            // Then: Should be able to match
            assertTrue(canMatch);
        }

        @Test
        @DisplayName("Should not match when bid below ask")
        void should_not_match_when_bid_below_ask() {
            // Given: Incompatible orders (bid < ask)
            setupCompatibleOrders(
                    Money.of("99.00", Currency.USD),  // Buy price (lower)
                    Money.of("100.00", Currency.USD), // Sell price (higher)
                    new BigDecimal("10"),
                    new BigDecimal("5")
            );

            // When: Checking if orders can match
            boolean canMatch = matchFinder.canMatch(buyOrder, sellOrder);

            // Then: Should not be able to match
            assertFalse(canMatch);
        }

        @Test
        @DisplayName("Should not match orders with different symbols")
        void should_not_match_orders_with_different_symbols() {
            // Given: Orders with different symbols
            when(buyOrder.getSymbol()).thenReturn(Symbol.btcUsd());
            when(sellOrder.getSymbol()).thenReturn(Symbol.ethUsd());
            when(buyOrder.getPrice()).thenReturn(Money.of("100.00", Currency.USD));
            when(sellOrder.getPrice()).thenReturn(Money.of("99.00", Currency.USD));
            when(buyOrder.isActive()).thenReturn(true);
            when(sellOrder.isActive()).thenReturn(true);
            when(buyOrder.getRemainingQuantity()).thenReturn(new BigDecimal("10"));
            when(sellOrder.getRemainingQuantity()).thenReturn(new BigDecimal("5"));

            // When: Checking if orders can match
            boolean canMatch = matchFinder.canMatch(buyOrder, sellOrder);

            // Then: Should not be able to match
            assertFalse(canMatch);
        }

        @Test
        @DisplayName("Should not match inactive orders")
        void should_not_match_inactive_orders() {
            // Given: Inactive buy order
            setupCompatibleOrders(
                    Money.of("100.00", Currency.USD),
                    Money.of("99.00", Currency.USD),
                    new BigDecimal("10"),
                    new BigDecimal("5")
            );
            when(buyOrder.isActive()).thenReturn(false); // Inactive

            // When: Checking if orders can match
            boolean canMatch = matchFinder.canMatch(buyOrder, sellOrder);

            // Then: Should not be able to match
            assertFalse(canMatch);
        }

        @Test
        @DisplayName("Should not match orders with zero quantity")
        void should_not_match_orders_with_zero_quantity() {
            // Given: Order with zero remaining quantity
            setupCompatibleOrders(
                    Money.of("100.00", Currency.USD),
                    Money.of("99.00", Currency.USD),
                    BigDecimal.ZERO,  // Zero quantity
                    new BigDecimal("5")
            );

            // When: Checking if orders can match
            boolean canMatch = matchFinder.canMatch(buyOrder, sellOrder);

            // Then: Should not be able to match
            assertFalse(canMatch);
        }
    }

    @Nested
    @DisplayName("Price Calculation Tests")
    class PriceCalculationTests {

        @Test
        @DisplayName("Should calculate midpoint price correctly")
        void should_calculate_midpoint_price_correctly() {
            // Given: Buy at $100, Sell at $98
            Money buyPrice = Money.of("100.00", Currency.USD);
            Money sellPrice = Money.of("98.00", Currency.USD);

            // When: Calculating match price
            Money matchPrice = matchFinder.calculateMatchPrice(buyPrice, sellPrice);

            // Then: Should return midpoint
            assertEquals(Money.of("99.00", Currency.USD), matchPrice);
        }

        @Test
        @DisplayName("Should calculate midpoint for equal prices")
        void should_calculate_midpoint_for_equal_prices() {
            // Given: Same buy and sell price
            Money price = Money.of("100.00", Currency.USD);

            // When: Calculating match price
            Money matchPrice = matchFinder.calculateMatchPrice(price, price);

            // Then: Should return same price
            assertEquals(price, matchPrice);
        }

        @Test
        @DisplayName("Should reject invalid price combination")
        void should_reject_invalid_price_combination() {
            // Given: Buy price < sell price
            Money buyPrice = Money.of("98.00", Currency.USD);
            Money sellPrice = Money.of("100.00", Currency.USD);

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    matchFinder.calculateMatchPrice(buyPrice, sellPrice));
        }
    }

    @Nested
    @DisplayName("Quantity Calculation Tests")
    class QuantityCalculationTests {

        @Test
        @DisplayName("Should calculate minimum quantity")
        void should_calculate_minimum_quantity() {
            // Given: Buy 10 shares, Sell 5 shares
            BigDecimal buyQuantity = new BigDecimal("10");
            BigDecimal sellQuantity = new BigDecimal("5");

            // When: Calculating match quantity
            BigDecimal matchQuantity = matchFinder.calculateMatchQuantity(buyQuantity, sellQuantity);

            // Then: Should return minimum
            assertEquals(new BigDecimal("5"), matchQuantity);
        }

        @Test
        @DisplayName("Should calculate minimum when sell quantity is larger")
        void should_calculate_minimum_when_sell_quantity_is_larger() {
            // Given: Buy 5 shares, Sell 10 shares
            BigDecimal buyQuantity = new BigDecimal("5");
            BigDecimal sellQuantity = new BigDecimal("10");

            // When: Calculating match quantity
            BigDecimal matchQuantity = matchFinder.calculateMatchQuantity(buyQuantity, sellQuantity);

            // Then: Should return minimum
            assertEquals(new BigDecimal("5"), matchQuantity);
        }

        @Test
        @DisplayName("Should reject zero quantities")
        void should_reject_zero_quantities() {
            // Given: Zero quantity
            BigDecimal zeroQuantity = BigDecimal.ZERO;
            BigDecimal validQuantity = new BigDecimal("10");

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    matchFinder.calculateMatchQuantity(zeroQuantity, validQuantity));
            assertThrows(IllegalArgumentException.class, () ->
                    matchFinder.calculateMatchQuantity(validQuantity, zeroQuantity));
        }

        @Test
        @DisplayName("Should reject negative quantities")
        void should_reject_negative_quantities() {
            // Given: Negative quantity
            BigDecimal negativeQuantity = new BigDecimal("-5");
            BigDecimal validQuantity = new BigDecimal("10");

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    matchFinder.calculateMatchQuantity(negativeQuantity, validQuantity));
        }
    }

    private void setupCompatibleOrders(Money buyPrice, Money sellPrice,
                                       BigDecimal buyQuantity, BigDecimal sellQuantity) {
        when(buyOrder.getSymbol()).thenReturn(symbol);
        when(sellOrder.getSymbol()).thenReturn(symbol);
        when(buyOrder.getPrice()).thenReturn(buyPrice);
        when(sellOrder.getPrice()).thenReturn(sellPrice);
        when(buyOrder.isActive()).thenReturn(true);
        when(sellOrder.isActive()).thenReturn(true);
        when(buyOrder.getRemainingQuantity()).thenReturn(buyQuantity);
        when(sellOrder.getRemainingQuantity()).thenReturn(sellQuantity);
    }
}=== ./order_book/OrderBookManagerTechnicalTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order.domain.entities.ISellOrder;
import core.ms.order_book.domain.OrderBook;
import core.ms.order_book.domain.OrderBookManager;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@DisplayName("Order Book Manager - Technical Tests")
class OrderBookManagerTechnicalTest {

    private OrderBookManager manager;
    private Symbol btcSymbol;
    private Symbol ethSymbol;

    @BeforeEach
    void setUp() {
        manager = new OrderBookManager();
        btcSymbol = Symbol.btcUsd();
        ethSymbol = Symbol.ethUsd();
    }

    @Test
    @DisplayName("Should handle concurrent order book creation safely")
    @Timeout(10) // Test should complete within 10 seconds
    void should_handle_concurrent_order_book_creation_safely() throws Exception {
        // Given: Multiple threads trying to create same book
        int threadCount = 10;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch finishLatch = new CountDownLatch(threadCount);
        List<Future<OrderBook>> futures = new ArrayList<>();

        // When: Multiple threads request same order book simultaneously
        for (int i = 0; i < threadCount; i++) {
            Future<OrderBook> future = executor.submit(() -> {
                try {
                    startLatch.await(); // Synchronize start
                    return manager.getOrderBook(btcSymbol);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException(e);
                } finally {
                    finishLatch.countDown();
                }
            });
            futures.add(future);
        }

        startLatch.countDown(); // Start all threads
        finishLatch.await(5, TimeUnit.SECONDS); // Wait for completion

        // Then: All threads should get same instance (thread safety)
        OrderBook firstBook = futures.get(0).get();
        assertNotNull(firstBook);

        for (Future<OrderBook> future : futures) {
            OrderBook book = future.get();
            assertSame(firstBook, book, "All threads should get the same OrderBook instance");
        }

        // And: Only one book should be created
        assertEquals(1, manager.getTotalOrderBooks());

        executor.shutdown();
        assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));
    }

    @Test
    @DisplayName("Should handle concurrent order operations without data corruption")
    @Timeout(15) // Test should complete within 15 seconds
    void should_handle_concurrent_order_operations_without_data_corruption() throws Exception {
        // Given: Shared order book and multiple orders
        int orderCount = 100;
        ExecutorService executor = Executors.newFixedThreadPool(10);
        CountDownLatch finishLatch = new CountDownLatch(orderCount);
        AtomicInteger successCount = new AtomicInteger(0);

        // When: Multiple threads add orders concurrently
        for (int i = 0; i < orderCount; i++) {
            final int orderId = i;
            executor.submit(() -> {
                try {
                    if (orderId % 2 == 0) {
                        IBuyOrder order = createMockBuyOrder("buy-" + orderId, btcSymbol,
                                Money.of("50000.00", Currency.USD), new BigDecimal("0.1"),
                                LocalDateTime.now().plusNanos(orderId));
                        manager.addOrderToBook(order);
                    } else {
                        ISellOrder order = createMockSellOrder("sell-" + orderId, btcSymbol,
                                Money.of("50000.00", Currency.USD), new BigDecimal("0.1"),
                                LocalDateTime.now().plusNanos(orderId));
                        manager.addOrderToBook(order);
                    }
                    successCount.incrementAndGet();
                } catch (Exception e) {
                    System.err.println("Failed to add order " + orderId + ": " + e.getMessage());
                } finally {
                    finishLatch.countDown();
                }
            });
        }

        boolean completed = finishLatch.await(10, TimeUnit.SECONDS);
        assertTrue(completed, "All operations should complete within timeout");

        // Then: Verify data integrity
        OrderBook btcBook = manager.getOrderBook(btcSymbol);

        // Note: Due to thread safety implementations, we expect all orders to be added successfully
        // The exact count may depend on the synchronization mechanism used
        assertTrue(btcBook.getOrderCount() > 0, "At least some orders should be added");
        assertEquals(successCount.get(), btcBook.getOrderCount(),
                "Order count should match successful additions");

        executor.shutdown();
        assertTrue(executor.awaitTermination(2, TimeUnit.SECONDS));
    }

    @Test
    @DisplayName("Should handle concurrent access to multiple order books")
    @Timeout(10)
    void should_handle_concurrent_access_to_multiple_order_books() throws Exception {
        // Given: Multiple symbols and concurrent operations
        int operationsPerSymbol = 20;
        ExecutorService executor = Executors.newFixedThreadPool(8);
        CountDownLatch finishLatch = new CountDownLatch(operationsPerSymbol * 2); // BTC + ETH

        // When: Concurrent operations on different symbols
        // BTC operations
        for (int i = 0; i < operationsPerSymbol; i++) {
            final int orderId = i;
            executor.submit(() -> {
                try {
                    IBuyOrder btcOrder = createMockBuyOrder("btc-" + orderId, btcSymbol,
                            Money.of("50000.00", Currency.USD), new BigDecimal("0.1"),
                            LocalDateTime.now().plusNanos(orderId));
                    manager.addOrderToBook(btcOrder);
                } finally {
                    finishLatch.countDown();
                }
            });
        }

        // ETH operations
        for (int i = 0; i < operationsPerSymbol; i++) {
            final int orderId = i;
            executor.submit(() -> {
                try {
                    ISellOrder ethOrder = createMockSellOrder("eth-" + orderId, ethSymbol,
                            Money.of("3000.00", Currency.USD), new BigDecimal("1.0"),
                            LocalDateTime.now().plusNanos(orderId + 1000));
                    manager.addOrderToBook(ethOrder);
                } finally {
                    finishLatch.countDown();
                }
            });
        }

        boolean completed = finishLatch.await(8, TimeUnit.SECONDS);
        assertTrue(completed, "All operations should complete within timeout");

        // Then: Verify both books are created and populated correctly
        assertEquals(2, manager.getTotalOrderBooks());

        Set<Symbol> activeSymbols = manager.getActiveSymbols();
        assertTrue(activeSymbols.contains(btcSymbol));
        assertTrue(activeSymbols.contains(ethSymbol));

        OrderBook btcBook = manager.getOrderBook(btcSymbol);
        OrderBook ethBook = manager.getOrderBook(ethSymbol);

        assertTrue(btcBook.getOrderCount() > 0, "BTC book should have orders");
        assertTrue(ethBook.getOrderCount() > 0, "ETH book should have orders");

        executor.shutdown();
        assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));
    }

    @Test
    @DisplayName("Should handle high-frequency concurrent read operations")
    @Timeout(10)
    void should_handle_high_frequency_concurrent_read_operations() throws Exception {
        // Given: Pre-populated order book
        OrderBook btcBook = manager.getOrderBook(btcSymbol);

        // Add some initial orders
        for (int i = 0; i < 10; i++) {
            IBuyOrder order = createMockBuyOrder("init-" + i, btcSymbol,
                    Money.of("50000.00", Currency.USD), new BigDecimal("0.1"),
                    LocalDateTime.now().plusNanos(i));
            manager.addOrderToBook(order);
        }

        int readOperations = 200;
        ExecutorService executor = Executors.newFixedThreadPool(20);
        CountDownLatch finishLatch = new CountDownLatch(readOperations);
        AtomicInteger successfulReads = new AtomicInteger(0);

        // When: Multiple threads perform read operations concurrently
        for (int i = 0; i < readOperations; i++) {
            executor.submit(() -> {
                try {
                    // Perform various read operations
                    int totalBooks = manager.getTotalOrderBooks();
                    Set<Symbol> symbols = manager.getActiveSymbols();
                    OrderBook book = manager.getOrderBook(btcSymbol);
                    int orderCount = book.getOrderCount();

                    // Verify basic consistency
                    assertTrue(totalBooks > 0);
                    assertFalse(symbols.isEmpty());
                    assertTrue(orderCount >= 0);

                    successfulReads.incrementAndGet();
                } catch (Exception e) {
                    System.err.println("Read operation failed: " + e.getMessage());
                } finally {
                    finishLatch.countDown();
                }
            });
        }

        boolean completed = finishLatch.await(5, TimeUnit.SECONDS);
        assertTrue(completed, "All read operations should complete within timeout");

        // Then: All reads should succeed without corruption
        assertEquals(readOperations, successfulReads.get(),
                "All read operations should succeed");

        executor.shutdown();
        assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));
    }

    /*@Test
    @DisplayName("Should handle memory pressure during concurrent operations")
    @Timeout(15)
    void should_handle_memory_pressure_during_concurrent_operations() throws Exception {
        // Given: Large number of operations to stress test memory
        int totalOperations = 500;
        ExecutorService executor = Executors.newFixedThreadPool(5);
        CountDownLatch finishLatch = new CountDownLatch(totalOperations);

        // When: Creating many order books and orders
        for (int i = 0; i < totalOperations; i++) {
            final int operationId = i;
            executor.submit(() -> {
                try {
                    Symbol dynamicSymbol = createMockSymbol("SYM-" + (operationId % 50)); // 50 different symbols

                    IBuyOrder order = createMockBuyOrder("order-" + operationId, dynamicSymbol,
                            Money.of("100.00", Currency.USD), new BigDecimal("1.0"),
                            LocalDateTime.now().plusNanos(operationId));

                    manager.addOrderToBook(order);

                    // Occasionally trigger garbage collection candidate operations
                    if (operationId % 100 == 0) {
                        manager.getMarketOverview(); // Complex aggregation operation
                    }

                } catch (OutOfMemoryError e) {
                    fail("Should not run out of memory during normal operations");
                } catch (Exception e) {
                    // Log but don't fail test - some operations might fail under pressure
                    System.err.println("Operation " + operationId + " failed: " + e.getMessage());
                } finally {
                    finishLatch.countDown();
                }
            });
        }

        boolean completed = finishLatch.await(12, TimeUnit.SECONDS);
        assertTrue(completed, "All operations should complete within timeout");

        // Then: System should remain stable
        assertTrue(manager.getTotalOrderBooks() > 0, "Should have created order books");
        assertTrue(manager.getTotalOrderBooks() <= 50, "Should not exceed expected number of books");

        executor.shutdown();
        assertTrue(executor.awaitTermination(3, TimeUnit.SECONDS));
    }*/

    // Helper methods
    private Symbol createMockSymbol(String code) {
        Symbol symbol = mock(Symbol.class);
        when(symbol.getCode()).thenReturn(code);
        when(symbol.toString()).thenReturn(code);
        return symbol;
    }

    private IBuyOrder createMockBuyOrder(String id, Symbol symbol, Money price,
                                         BigDecimal quantity, LocalDateTime time) {
        IBuyOrder order = mock(IBuyOrder.class);
        when(order.getId()).thenReturn(id);
        when(order.getSymbol()).thenReturn(symbol);
        when(order.getPrice()).thenReturn(price);
        when(order.getRemainingQuantity()).thenReturn(quantity);
        when(order.getCreatedAt()).thenReturn(time);
        when(order.isActive()).thenReturn(true);
        return order;
    }

    private ISellOrder createMockSellOrder(String id, Symbol symbol, Money price,
                                           BigDecimal quantity, LocalDateTime time) {
        ISellOrder order = mock(ISellOrder.class);
        when(order.getId()).thenReturn(id);
        when(order.getSymbol()).thenReturn(symbol);
        when(order.getPrice()).thenReturn(price);
        when(order.getRemainingQuantity()).thenReturn(quantity);
        when(order.getCreatedAt()).thenReturn(time);
        when(order.isActive()).thenReturn(true);
        return order;
    }
}=== ./order_book/OrderBookManagerBusinessTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order.domain.entities.ISellOrder;
import core.ms.order_book.domain.OrderBook;
import core.ms.order_book.domain.OrderBookManager;
import core.ms.order_book.domain.value_object.MarketOverview;
import core.ms.order_book.domain.value_object.OrderMatch;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@DisplayName("Order Book Manager - Business Logic Tests")
class OrderBookManagerBusinessTest {

    private OrderBookManager manager;
    private Symbol btcSymbol;
    private Symbol ethSymbol;
    private Symbol aaplSymbol;
    private IBuyOrder btcBuyOrder;
    private ISellOrder btcSellOrder;
    private IBuyOrder ethBuyOrder;
    private ISellOrder ethSellOrder;
    private IBuyOrder aaplBuyOrder;
    private ISellOrder aaplSellOrder;

    @BeforeEach
    void setUp() {
        manager = new OrderBookManager();
        btcSymbol = Symbol.btcUsd();
        ethSymbol = Symbol.ethUsd();
        aaplSymbol = createMockSymbol("AAPL");

        // Setup orders for different symbols
        btcBuyOrder = createMockBuyOrder("btc-buy-1", btcSymbol,
                Money.of("50000.00", Currency.USD), new BigDecimal("1.5"),
                LocalDateTime.of(2024, 1, 1, 10, 0));
        btcSellOrder = createMockSellOrder("btc-sell-1", btcSymbol,
                Money.of("49500.00", Currency.USD), new BigDecimal("0.8"),
                LocalDateTime.of(2024, 1, 1, 10, 1));

        ethBuyOrder = createMockBuyOrder("eth-buy-1", ethSymbol,
                Money.of("3000.00", Currency.USD), new BigDecimal("5.0"),
                LocalDateTime.of(2024, 1, 1, 10, 2));
        ethSellOrder = createMockSellOrder("eth-sell-1", ethSymbol,
                Money.of("3100.00", Currency.USD), new BigDecimal("3.0"),
                LocalDateTime.of(2024, 1, 1, 10, 3));

        aaplBuyOrder = createMockBuyOrder("aapl-buy-1", aaplSymbol,
                Money.of("180.00", Currency.USD), new BigDecimal("100"),
                LocalDateTime.of(2024, 1, 1, 10, 4));
        aaplSellOrder = createMockSellOrder("aapl-sell-1", aaplSymbol,
                Money.of("179.50", Currency.USD), new BigDecimal("150"),
                LocalDateTime.of(2024, 1, 1, 10, 5));
    }

    @Nested
    @DisplayName("Order Book Lifecycle Management")
    class OrderBookLifecycleTests {

        @Test
        @DisplayName("Should create order book for new symbol")
        void should_create_order_book_for_new_symbol() {
            // Given: Empty manager
            assertEquals(0, manager.getTotalOrderBooks());

            // When: Getting order book for new symbol
            OrderBook orderBook = manager.getOrderBook(btcSymbol);

            // Then: Should create and return new book
            assertNotNull(orderBook);
            assertEquals(btcSymbol, orderBook.getSymbol());
            assertEquals(1, manager.getTotalOrderBooks());
            assertTrue(manager.getActiveSymbols().contains(btcSymbol));
            assertTrue(orderBook.isEmpty());
        }

        @Test
        @DisplayName("Should return existing order book for same symbol")
        void should_return_existing_order_book_for_same_symbol() {
            // Given: Manager with existing book
            OrderBook firstCall = manager.getOrderBook(btcSymbol);

            // When: Getting same symbol again
            OrderBook secondCall = manager.getOrderBook(btcSymbol);

            // Then: Should return same instance
            assertSame(firstCall, secondCall);
            assertEquals(1, manager.getTotalOrderBooks());
        }

        @Test
        @DisplayName("Should create separate books for different symbols")
        void should_create_separate_books_for_different_symbols() {
            // When: Getting books for different symbols
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            OrderBook ethBook = manager.getOrderBook(ethSymbol);
            OrderBook aaplBook = manager.getOrderBook(aaplSymbol);

            // Then: Should create separate books
            assertNotSame(btcBook, ethBook);
            assertNotSame(ethBook, aaplBook);
            assertEquals(3, manager.getTotalOrderBooks());

            Set<Symbol> activeSymbols = manager.getActiveSymbols();
            assertEquals(3, activeSymbols.size());
            assertTrue(activeSymbols.contains(btcSymbol));
            assertTrue(activeSymbols.contains(ethSymbol));
            assertTrue(activeSymbols.contains(aaplSymbol));
        }

        @Test
        @DisplayName("Should create order book explicitly")
        void should_create_order_book_explicitly() {
            // Given: Empty manager
            assertEquals(0, manager.getTotalOrderBooks());

            // When: Creating order book explicitly
            OrderBook orderBook = manager.createOrderBook(btcSymbol);

            // Then: Should create new book and be retrievable
            assertNotNull(orderBook);
            assertEquals(btcSymbol, orderBook.getSymbol());
            assertEquals(1, manager.getTotalOrderBooks());

            OrderBook retrieved = manager.getOrderBook(btcSymbol);
            assertSame(orderBook, retrieved);
        }

        @Test
        @DisplayName("Should reject creating duplicate order book")
        void should_reject_creating_duplicate_order_book() {
            // Given: Manager with existing book
            manager.createOrderBook(btcSymbol);

            // When/Then: Should throw exception for duplicate
            IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
                    () -> manager.createOrderBook(btcSymbol));
            assertTrue(exception.getMessage().contains("already exists"));
        }

        @Test
        @DisplayName("Should remove order book successfully")
        void should_remove_order_book_successfully() {
            // Given: Manager with multiple order books
            manager.getOrderBook(btcSymbol);
            manager.getOrderBook(ethSymbol);
            assertEquals(2, manager.getTotalOrderBooks());

            // When: Removing one book
            boolean removed = manager.removeOrderBook(btcSymbol);

            // Then: Should remove successfully
            assertTrue(removed);
            assertEquals(1, manager.getTotalOrderBooks());
            assertFalse(manager.getActiveSymbols().contains(btcSymbol));
            assertTrue(manager.getActiveSymbols().contains(ethSymbol));
        }

        @Test
        @DisplayName("Should return false when removing non-existent book")
        void should_return_false_when_removing_non_existent_book() {
            // Given: Empty manager
            assertEquals(0, manager.getTotalOrderBooks());

            // When: Removing non-existent book
            boolean removed = manager.removeOrderBook(btcSymbol);

            // Then: Should return false
            assertFalse(removed);
            assertEquals(0, manager.getTotalOrderBooks());
        }

        @Test
        @DisplayName("Should handle null symbol validation")
        void should_handle_null_symbol_validation() {
            // When/Then: Should throw exception for null symbol
            assertThrows(NullPointerException.class, () -> manager.getOrderBook(null));
            assertThrows(NullPointerException.class, () -> manager.createOrderBook(null));
            assertThrows(NullPointerException.class, () -> manager.removeOrderBook(null));
        }
    }

    @Nested
    @DisplayName("Order Routing and Management")
    class OrderRoutingTests {

        @Test
        @DisplayName("Should route order to correct symbol book")
        void should_route_order_to_correct_symbol_book() {
            // When: Adding order
            manager.addOrderToBook(btcBuyOrder);

            // Then: Should be in correct book only
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            assertEquals(1, btcBook.getOrderCount());
            assertEquals(btcBuyOrder.getId(), btcBook.getBestBuyOrder().get().getId());

            // And: Other books should remain empty
            OrderBook ethBook = manager.getOrderBook(ethSymbol);
            assertTrue(ethBook.isEmpty());
        }

        @Test
        @DisplayName("Should manage orders across multiple symbol books")
        void should_manage_orders_across_multiple_symbol_books() {
            // When: Adding orders to different books
            manager.addOrderToBook(btcBuyOrder);
            manager.addOrderToBook(ethBuyOrder);
            manager.addOrderToBook(aaplBuyOrder);

            // Then: Each book should contain its respective order
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            OrderBook ethBook = manager.getOrderBook(ethSymbol);
            OrderBook aaplBook = manager.getOrderBook(aaplSymbol);

            assertEquals(1, btcBook.getOrderCount());
            assertEquals(1, ethBook.getOrderCount());
            assertEquals(1, aaplBook.getOrderCount());

            assertEquals("btc-buy-1", btcBook.getBestBuyOrder().get().getId());
            assertEquals("eth-buy-1", ethBook.getBestBuyOrder().get().getId());
            assertEquals("aapl-buy-1", aaplBook.getBestBuyOrder().get().getId());
        }

        @Test
        @DisplayName("Should remove order from specified symbol book")
        void should_remove_order_from_specified_symbol_book() {
            // Given: Orders in different books
            manager.addOrderToBook(btcBuyOrder);
            manager.addOrderToBook(ethBuyOrder);

            // When: Removing order from specific book
            boolean removed = manager.removeOrderFromBook(btcBuyOrder, btcSymbol);

            // Then: Should remove from correct book only
            assertTrue(removed);

            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            OrderBook ethBook = manager.getOrderBook(ethSymbol);

            assertEquals(0, btcBook.getOrderCount());
            assertEquals(1, ethBook.getOrderCount());
            assertEquals("eth-buy-1", ethBook.getBestBuyOrder().get().getId());
        }

        @Test
        @DisplayName("Should return false when removing order from incorrect book")
        void should_return_false_when_removing_order_from_incorrect_book() {
            // Given: Order in BTC book only
            manager.addOrderToBook(btcBuyOrder);

            // When: Trying to remove from ETH book
            boolean removed = manager.removeOrderFromBook(btcBuyOrder, ethSymbol);

            // Then: Should return false
            assertFalse(removed);

            // And: Order should remain in BTC book
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            assertEquals(1, btcBook.getOrderCount());
        }

        @Test
        @DisplayName("Should return false when removing from non-existent book")
        void should_return_false_when_removing_from_non_existent_book() {
            // When: Removing order from non-existent book
            boolean removed = manager.removeOrderFromBook(btcBuyOrder, btcSymbol);

            // Then: Should return false
            assertFalse(removed);
            assertEquals(0, manager.getTotalOrderBooks());
        }
    }

    @Nested
    @DisplayName("Cross-Book Market Operations")
    class CrossBookMarketOperationsTests {

        @Test
        @DisplayName("Should find matches across all eligible books")
        void should_find_matches_across_all_eligible_books() {
            // Given: Multiple books with varying match eligibility
            // BTC: Can match (buy $50k >= sell $49.5k)
            manager.addOrderToBook(btcBuyOrder);  // $50,000
            manager.addOrderToBook(btcSellOrder); // $49,500

            // ETH: Cannot match (buy $3k < sell $3.1k)
            manager.addOrderToBook(ethBuyOrder);  // $3,000
            manager.addOrderToBook(ethSellOrder); // $3,100

            // AAPL: Can match (buy $180 >= sell $179.50)
            manager.addOrderToBook(aaplBuyOrder);  // $180.00
            manager.addOrderToBook(aaplSellOrder); // $179.50

            // When: Finding all matches
            List<OrderMatch> matches = manager.findAllMatches();

            // Then: Should find matches from eligible books only
            assertEquals(2, matches.size());

            // Verify BTC match exists
            boolean hasBtcMatch = matches.stream()
                    .anyMatch(m -> m.getBuyOrder().getId().equals("btc-buy-1") &&
                            m.getSellOrder().getId().equals("btc-sell-1"));
            assertTrue(hasBtcMatch);

            // Verify AAPL match exists
            boolean hasAaplMatch = matches.stream()
                    .anyMatch(m -> m.getBuyOrder().getId().equals("aapl-buy-1") &&
                            m.getSellOrder().getId().equals("aapl-sell-1"));
            assertTrue(hasAaplMatch);

            // Verify no ETH match (price spread prevents matching)
            boolean hasEthMatch = matches.stream()
                    .anyMatch(m -> m.getBuyOrder().getSymbol().equals(ethSymbol));
            assertFalse(hasEthMatch);
        }

        @Test
        @DisplayName("Should return empty list when no matches exist")
        void should_return_empty_list_when_no_matches_exist() {
            // Given: Books with non-matching orders
            manager.addOrderToBook(ethBuyOrder);  // $3,000
            manager.addOrderToBook(ethSellOrder); // $3,100 (spread prevents match)

            // When: Finding matches
            List<OrderMatch> matches = manager.findAllMatches();

            // Then: Should return empty list
            assertTrue(matches.isEmpty());
        }

        @Test
        @DisplayName("Should return empty list for empty manager")
        void should_return_empty_list_for_empty_manager() {
            // Given: Empty manager
            assertEquals(0, manager.getTotalOrderBooks());

            // When: Finding matches
            List<OrderMatch> matches = manager.findAllMatches();

            // Then: Should return empty list
            assertTrue(matches.isEmpty());
        }

        @Test
        @DisplayName("Should provide comprehensive market overview")
        void should_provide_comprehensive_market_overview() {
            // Given: Manager with multiple populated books
            setupManagerWithMultipleBooks();

            // When: Getting market overview
            MarketOverview overview = manager.getMarketOverview();

            // Then: Should aggregate all data correctly
            assertEquals(3, overview.getTotalOrderBooks());
            assertEquals(6, overview.getTotalOrders()); // 2 orders per symbol

            Set<Symbol> activeSymbols = overview.getActiveSymbols();
            assertEquals(3, activeSymbols.size());
            assertTrue(activeSymbols.contains(btcSymbol));
            assertTrue(activeSymbols.contains(ethSymbol));
            assertTrue(activeSymbols.contains(aaplSymbol));

            // Verify volume calculations per symbol
            Map<Symbol, BigDecimal> volumes = overview.getTotalVolume();
            assertEquals(new BigDecimal("2.3"), volumes.get(btcSymbol));  // 1.5 + 0.8
            assertEquals(new BigDecimal("8.0"), volumes.get(ethSymbol));  // 5.0 + 3.0
            assertEquals(new BigDecimal("250"), volumes.get(aaplSymbol)); // 100 + 150

            assertNotNull(overview.getTimestamp());
        }

        @Test
        @DisplayName("Should return correct volume for specific symbols")
        void should_return_correct_volume_for_specific_symbols() {
            // Given: Manager with orders
            setupManagerWithMultipleBooks();
            MarketOverview overview = manager.getMarketOverview();

            // When: Getting volume for specific symbols
            BigDecimal btcVolume = overview.getVolumeForSymbol(btcSymbol);
            BigDecimal ethVolume = overview.getVolumeForSymbol(ethSymbol);
            BigDecimal unknownVolume = overview.getVolumeForSymbol(createMockSymbol("UNKNOWN"));

            // Then: Should return correct volumes
            assertEquals(new BigDecimal("2.3"), btcVolume);
            assertEquals(new BigDecimal("8.0"), ethVolume);
            assertEquals(BigDecimal.ZERO, unknownVolume); // Unknown symbol
        }

        @Test
        @DisplayName("Should handle empty books in market overview")
        void should_handle_empty_books_in_market_overview() {
            // Given: Manager with empty books
            manager.getOrderBook(btcSymbol); // Creates empty book
            manager.getOrderBook(ethSymbol); // Creates empty book

            // When: Getting market overview
            MarketOverview overview = manager.getMarketOverview();

            // Then: Should handle empty books correctly
            assertEquals(2, overview.getTotalOrderBooks());
            assertEquals(0, overview.getTotalOrders());
            assertEquals(2, overview.getActiveSymbols().size());

            Map<Symbol, BigDecimal> volumes = overview.getTotalVolume();
            assertEquals(BigDecimal.ZERO, volumes.get(btcSymbol));
            assertEquals(BigDecimal.ZERO, volumes.get(ethSymbol));
        }

        @Test
        @DisplayName("Should return all managed order books")
        void should_return_all_managed_order_books() {
            // Given: Manager with multiple books
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            OrderBook ethBook = manager.getOrderBook(ethSymbol);
            OrderBook aaplBook = manager.getOrderBook(aaplSymbol);

            // When: Getting all order books
            Collection<OrderBook> allBooks = manager.getAllOrderBooks();

            // Then: Should return all books
            assertEquals(3, allBooks.size());
            assertTrue(allBooks.contains(btcBook));
            assertTrue(allBooks.contains(ethBook));
            assertTrue(allBooks.contains(aaplBook));
        }
    }

    // Helper methods
    private void setupManagerWithMultipleBooks() {
        manager.addOrderToBook(btcBuyOrder);
        manager.addOrderToBook(btcSellOrder);
        manager.addOrderToBook(ethBuyOrder);
        manager.addOrderToBook(ethSellOrder);
        manager.addOrderToBook(aaplBuyOrder);
        manager.addOrderToBook(aaplSellOrder);
    }

    private Symbol createMockSymbol(String code) {
        Symbol symbol = mock(Symbol.class);
        when(symbol.getCode()).thenReturn(code);
        when(symbol.toString()).thenReturn(code);
        return symbol;
    }

    private IBuyOrder createMockBuyOrder(String id, Symbol symbol, Money price,
                                         BigDecimal quantity, LocalDateTime time) {
        IBuyOrder order = mock(IBuyOrder.class);
        when(order.getId()).thenReturn(id);
        when(order.getSymbol()).thenReturn(symbol);
        when(order.getPrice()).thenReturn(price);
        when(order.getRemainingQuantity()).thenReturn(quantity);
        when(order.getCreatedAt()).thenReturn(time);
        when(order.isActive()).thenReturn(true);
        return order;
    }

    private ISellOrder createMockSellOrder(String id, Symbol symbol, Money price,
                                           BigDecimal quantity, LocalDateTime time) {
        ISellOrder order = mock(ISellOrder.class);
        when(order.getId()).thenReturn(id);
        when(order.getSymbol()).thenReturn(symbol);
        when(order.getPrice()).thenReturn(price);
        when(order.getRemainingQuantity()).thenReturn(quantity);
        when(order.getCreatedAt()).thenReturn(time);
        when(order.isActive()).thenReturn(true);
        return order;
    }
}=== ./order_book/BidPriceLevelTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order_book.domain.value_object.BidPriceLevel;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@DisplayName("Bid Price Level Tests")
class BidPriceLevelTest {

    private BidPriceLevel bidLevel;
    private Money testPrice;
    private IBuyOrder buyOrder1;
    private IBuyOrder buyOrder2;
    private LocalDateTime earlierTime;
    private LocalDateTime laterTime;

    @BeforeEach
    void setUp() {
        // Initialize test data
        testPrice = Money.of("100.00", Currency.USD);
        bidLevel = new BidPriceLevel(testPrice);
        earlierTime = LocalDateTime.of(2024, 1, 1, 10, 0);
        laterTime = LocalDateTime.of(2024, 1, 1, 10, 5);

        // Create mocks
        buyOrder1 = mock(IBuyOrder.class);
        buyOrder2 = mock(IBuyOrder.class);

        // Setup buyOrder1 mock behavior
        when(buyOrder1.getId()).thenReturn("order1");
        when(buyOrder1.getPrice()).thenReturn(testPrice);
        when(buyOrder1.getRemainingQuantity()).thenReturn(new BigDecimal("10"));
        when(buyOrder1.getCreatedAt()).thenReturn(earlierTime);
        when(buyOrder1.isActive()).thenReturn(true);

        // Setup buyOrder2 mock behavior
        when(buyOrder2.getId()).thenReturn("order2");
        when(buyOrder2.getPrice()).thenReturn(testPrice);
        when(buyOrder2.getRemainingQuantity()).thenReturn(new BigDecimal("5"));
        when(buyOrder2.getCreatedAt()).thenReturn(laterTime);
        when(buyOrder2.isActive()).thenReturn(true);
    }

    @Nested
    @DisplayName("Order Management Tests")
    class OrderManagementTests {

        @Test
        @DisplayName("Should add buy order successfully")
        void should_add_buy_order_successfully() {
            // Given: Empty bid level
            assertTrue(bidLevel.isEmpty());

            // When: Adding order
            bidLevel.addOrder(buyOrder1);

            // Then: Level should contain order and update metrics
            assertFalse(bidLevel.isEmpty());
            assertEquals(1, bidLevel.getOrderCount());
            assertEquals(new BigDecimal("10"), bidLevel.getTotalQuantity());
            assertEquals(testPrice, bidLevel.getPrice());
            assertTrue(bidLevel.getFirstOrder().isPresent());
            assertEquals("order1", bidLevel.getFirstOrder().get().getId());
        }

        @Test
        @DisplayName("Should maintain time priority within level")
        void should_maintain_time_priority_within_level() {
            // Given: Empty bid level

            // When: Adding orders in sequence
            bidLevel.addOrder(buyOrder1); // Earlier time
            bidLevel.addOrder(buyOrder2); // Later time

            // Then: First order should be at front of queue
            assertEquals("order1", bidLevel.getFirstOrder().get().getId());
            assertEquals(2, bidLevel.getOrderCount());
            assertEquals(new BigDecimal("15"), bidLevel.getTotalQuantity());

            // And: Orders should be in time order
            assertEquals("order1", bidLevel.getOrders().get(0).getId());
            assertEquals("order2", bidLevel.getOrders().get(1).getId());
        }

        @Test
        @DisplayName("Should aggregate quantities correctly")
        void should_aggregate_quantities_correctly() {
            // Given: Multiple orders

            // When: Adding orders
            bidLevel.addOrder(buyOrder1); // 10
            bidLevel.addOrder(buyOrder2); // 5

            // Then: Should aggregate total quantity
            assertEquals(new BigDecimal("15"), bidLevel.getTotalQuantity());
            assertEquals(2, bidLevel.getOrderCount());
        }

        @Test
        @DisplayName("Should reject order with wrong price")
        void should_reject_order_with_wrong_price() {
            // Given: Order with different price
            IBuyOrder wrongPriceOrder = mock(IBuyOrder.class);
            when(wrongPriceOrder.getPrice()).thenReturn(Money.of("99.00", Currency.USD));

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    bidLevel.addOrder(wrongPriceOrder));
        }

        @Test
        @DisplayName("Should reject null order")
        void should_reject_null_order() {
            // When/Then: Should throw exception
            assertThrows(NullPointerException.class, () ->
                    bidLevel.addOrder(null));
        }
    }

    @Nested
    @DisplayName("Order Removal Tests")
    class OrderRemovalTests {

        @Test
        @DisplayName("Should remove order and update metrics")
        void should_remove_order_and_update_metrics() {
            // Given: Level with order
            bidLevel.addOrder(buyOrder1);
            assertEquals(1, bidLevel.getOrderCount());
            assertEquals(new BigDecimal("10"), bidLevel.getTotalQuantity());

            // When: Removing order
            boolean removed = bidLevel.removeOrder(buyOrder1);

            // Then: Should remove successfully and update metrics
            assertTrue(removed);
            assertEquals(0, bidLevel.getOrderCount());
            assertEquals(BigDecimal.ZERO, bidLevel.getTotalQuantity());
            assertTrue(bidLevel.isEmpty());
            assertFalse(bidLevel.getFirstOrder().isPresent());
        }

        @Test
        @DisplayName("Should remove correct order from multiple orders")
        void should_remove_correct_order_from_multiple_orders() {
            // Given: Level with multiple orders
            bidLevel.addOrder(buyOrder1);
            bidLevel.addOrder(buyOrder2);

            // When: Removing second order
            boolean removed = bidLevel.removeOrder(buyOrder2);

            // Then: Should remove only the specified order
            assertTrue(removed);
            assertEquals(1, bidLevel.getOrderCount());
            assertEquals(new BigDecimal("10"), bidLevel.getTotalQuantity());
            assertEquals("order1", bidLevel.getFirstOrder().get().getId());
        }

        @Test
        @DisplayName("Should return false when removing non-existent order")
        void should_return_false_when_removing_non_existent_order() {
            // Given: Level with one order
            bidLevel.addOrder(buyOrder1);

            // When: Removing different order
            boolean removed = bidLevel.removeOrder(buyOrder2);

            // Then: Should return false and not affect level
            assertFalse(removed);
            assertEquals(1, bidLevel.getOrderCount());
            assertEquals(new BigDecimal("10"), bidLevel.getTotalQuantity());
        }

        @Test
        @DisplayName("Should handle removing order from empty level")
        void should_handle_removing_order_from_empty_level() {
            // Given: Empty level
            assertTrue(bidLevel.isEmpty());

            // When: Removing order
            boolean removed = bidLevel.removeOrder(buyOrder1);

            // Then: Should return false
            assertFalse(removed);
            assertTrue(bidLevel.isEmpty());
        }
    }

    @Nested
    @DisplayName("State Query Tests")
    class StateQueryTests {

        @Test
        @DisplayName("Should return empty state correctly")
        void should_return_empty_state_correctly() {
            // Given: Empty level

            // When/Then: Should be empty
            assertTrue(bidLevel.isEmpty());
            assertEquals(0, bidLevel.getOrderCount());
            assertEquals(BigDecimal.ZERO, bidLevel.getTotalQuantity());
            assertFalse(bidLevel.getFirstOrder().isPresent());
            assertTrue(bidLevel.getOrders().isEmpty());
        }

        @Test
        @DisplayName("Should return non-empty state correctly")
        void should_return_non_empty_state_correctly() {
            // Given: Level with order
            bidLevel.addOrder(buyOrder1);

            // When/Then: Should not be empty
            assertFalse(bidLevel.isEmpty());
            assertEquals(1, bidLevel.getOrderCount());
            assertEquals(new BigDecimal("10"), bidLevel.getTotalQuantity());
            assertTrue(bidLevel.getFirstOrder().isPresent());
            assertFalse(bidLevel.getOrders().isEmpty());
        }

        @Test
        @DisplayName("Should provide defensive copy of orders")
        void should_provide_defensive_copy_of_orders() {
            // Given: Level with orders
            bidLevel.addOrder(buyOrder1);
            bidLevel.addOrder(buyOrder2);

            // When: Getting orders list
            var orders = bidLevel.getOrders();

            // Then: Should be defensive copy
            assertEquals(2, orders.size());

            // And: Modifying returned list should not affect level
            orders.clear();
            assertEquals(2, bidLevel.getOrderCount()); // Should remain unchanged
        }
    }
}=== ./order_book/BuyOrderPriorityCalculatorTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order_book.domain.value_object.BuyOrderPriorityCalculator;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@DisplayName("Buy Order Priority Calculator Tests")
class BuyOrderPriorityCalculatorTest {

    private BuyOrderPriorityCalculator calculator;
    private IBuyOrder buyOrder1;
    private IBuyOrder buyOrder2;
    private LocalDateTime earlierTime;
    private LocalDateTime laterTime;

    @BeforeEach
    void setUp() {
        calculator = new BuyOrderPriorityCalculator();
        earlierTime = LocalDateTime.of(2024, 1, 1, 10, 0);
        laterTime = LocalDateTime.of(2024, 1, 1, 10, 5);

        buyOrder1 = mock(IBuyOrder.class);
        buyOrder2 = mock(IBuyOrder.class);
    }

    @Nested
    @DisplayName("Price Priority Tests")
    class PricePriorityTests {

        @Test
        @DisplayName("Should prioritize higher price over lower price")
        void should_prioritize_higher_price_over_lower_price() {
            // Given: Two different prices
            Money higherPrice = Money.of("100.50", Currency.USD);
            Money lowerPrice = Money.of("100.00", Currency.USD);

            // When: Comparing prices
            boolean result = calculator.isPriceBetter(higherPrice, lowerPrice);

            // Then: Higher price should be better
            assertTrue(result);
        }

        @Test
        @DisplayName("Should not prioritize lower price over higher price")
        void should_not_prioritize_lower_price_over_higher_price() {
            // Given: Two different prices
            Money higherPrice = Money.of("100.50", Currency.USD);
            Money lowerPrice = Money.of("100.00", Currency.USD);

            // When: Comparing prices (reversed)
            boolean result = calculator.isPriceBetter(lowerPrice, higherPrice);

            // Then: Lower price should not be better
            assertFalse(result);
        }

        @Test
        @DisplayName("Should return false for equal prices")
        void should_return_false_for_equal_prices() {
            // Given: Same price
            Money price1 = Money.of("100.00", Currency.USD);
            Money price2 = Money.of("100.00", Currency.USD);

            // When: Comparing equal prices
            boolean result = calculator.isPriceBetter(price1, price2);

            // Then: Neither should be better
            assertFalse(result);
        }

        @Test
        @DisplayName("Should handle null prices")
        void should_handle_null_prices() {
            // Given: Null prices
            Money validPrice = Money.of("100.00", Currency.USD);

            // When/Then: Should throw exception
            assertThrows(NullPointerException.class, () ->
                    calculator.isPriceBetter(null, validPrice));
            assertThrows(NullPointerException.class, () ->
                    calculator.isPriceBetter(validPrice, null));
        }
    }

    @Nested
    @DisplayName("Order Priority Tests")
    class OrderPriorityTests {

        @Test
        @DisplayName("Should prioritize higher price order over lower price order")
        void should_prioritize_higher_price_order_over_lower_price_order() {
            // Given: Two orders with different prices
            Money higherPrice = Money.of("100.50", Currency.USD);
            Money lowerPrice = Money.of("100.00", Currency.USD);

            when(buyOrder1.getPrice()).thenReturn(higherPrice);
            when(buyOrder1.getCreatedAt()).thenReturn(earlierTime);
            when(buyOrder2.getPrice()).thenReturn(lowerPrice);
            when(buyOrder2.getCreatedAt()).thenReturn(laterTime);

            // When: Comparing order priority
            boolean result = calculator.isHigherPriority(buyOrder1, buyOrder2);

            // Then: Higher price order should have priority
            assertTrue(result);
        }

        @Test
        @DisplayName("Should prioritize earlier time when same price")
        void should_prioritize_earlier_time_when_same_price() {
            // Given: Two orders at same price, different times
            Money samePrice = Money.of("100.00", Currency.USD);

            when(buyOrder1.getPrice()).thenReturn(samePrice);
            when(buyOrder1.getCreatedAt()).thenReturn(earlierTime);
            when(buyOrder2.getPrice()).thenReturn(samePrice);
            when(buyOrder2.getCreatedAt()).thenReturn(laterTime);

            // When: Comparing order priority
            boolean result = calculator.isHigherPriority(buyOrder1, buyOrder2);

            // Then: Earlier order should have priority
            assertTrue(result);
        }

        @Test
        @DisplayName("Should handle equal price and time")
        void should_handle_equal_price_and_time() {
            // Given: Identical orders
            Money samePrice = Money.of("100.00", Currency.USD);
            LocalDateTime sameTime = LocalDateTime.of(2024, 1, 1, 10, 0);

            when(buyOrder1.getPrice()).thenReturn(samePrice);
            when(buyOrder1.getCreatedAt()).thenReturn(sameTime);
            when(buyOrder2.getPrice()).thenReturn(samePrice);
            when(buyOrder2.getCreatedAt()).thenReturn(sameTime);

            // When: Comparing order priority
            boolean result = calculator.isHigherPriority(buyOrder1, buyOrder2);

            // Then: Should return false (no priority)
            assertFalse(result);
        }
    }

    @Nested
    @DisplayName("Utility Methods Tests")
    class UtilityMethodsTests {

        @Test
        @DisplayName("Should calculate price difference correctly")
        void should_calculate_price_difference_correctly() {
            // Given: Two prices
            Money price1 = Money.of("100.50", Currency.USD);
            Money price2 = Money.of("100.00", Currency.USD);

            // When: Calculating difference
            Money result = calculator.calculatePriceDifference(price1, price2);

            // Then: Should return absolute difference
            assertEquals(Money.of("0.50", Currency.USD), result);
        }

        @Test
        @DisplayName("Should handle negative difference")
        void should_handle_negative_difference() {
            // Given: Two prices (reversed)
            Money price1 = Money.of("100.00", Currency.USD);
            Money price2 = Money.of("100.50", Currency.USD);

            // When: Calculating difference
            Money result = calculator.calculatePriceDifference(price1, price2);

            // Then: Should return absolute difference
            assertEquals(Money.of("0.50", Currency.USD), result);
        }

        @Test
        @DisplayName("Should identify same price orders")
        void should_identify_same_price_orders() {
            // Given: Orders with same price
            Money samePrice = Money.of("100.00", Currency.USD);
            when(buyOrder1.getPrice()).thenReturn(samePrice);
            when(buyOrder2.getPrice()).thenReturn(samePrice);

            // When: Checking if same price
            boolean result = calculator.hasSamePrice(buyOrder1, buyOrder2);

            // Then: Should return true
            assertTrue(result);
        }

        @Test
        @DisplayName("Should identify different price orders")
        void should_identify_different_price_orders() {
            // Given: Orders with different prices
            when(buyOrder1.getPrice()).thenReturn(Money.of("100.50", Currency.USD));
            when(buyOrder2.getPrice()).thenReturn(Money.of("100.00", Currency.USD));

            // When: Checking if same price
            boolean result = calculator.hasSamePrice(buyOrder1, buyOrder2);

            // Then: Should return false
            assertFalse(result);
        }
    }
}=== ./order_book/AskPriceLevelTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.ISellOrder;
import core.ms.order_book.domain.value_object.AskPriceLevel;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

class AskPriceLevelTest {

    private AskPriceLevel askLevel;
    private Money testPrice;
    private ISellOrder sellOrder1;
    private ISellOrder sellOrder2;
    private LocalDateTime earlierTime;
    private LocalDateTime laterTime;

    @BeforeEach
    void setUp() {
        testPrice = Money.of("100.00", Currency.USD);
        askLevel = new AskPriceLevel(testPrice);
        earlierTime = LocalDateTime.of(2024, 1, 1, 10, 0);
        laterTime = LocalDateTime.of(2024, 1, 1, 10, 5);

        sellOrder1 = mock(ISellOrder.class);
        sellOrder2 = mock(ISellOrder.class);

        // Setup common mock behavior
        when(sellOrder1.getPrice()).thenReturn(testPrice);
        when(sellOrder1.getRemainingQuantity()).thenReturn(new BigDecimal("10"));
        when(sellOrder1.getCreatedAt()).thenReturn(earlierTime);
        when(sellOrder1.getId()).thenReturn("order1");

        when(sellOrder2.getPrice()).thenReturn(testPrice);
        when(sellOrder2.getRemainingQuantity()).thenReturn(new BigDecimal("5"));
        when(sellOrder2.getCreatedAt()).thenReturn(laterTime);
        when(sellOrder2.getId()).thenReturn("order2");
    }

    @Test
    @DisplayName("Should add sell order successfully")
    void should_add_sell_order_successfully() {
        // Given: Empty ask level
        assertTrue(askLevel.isEmpty());

        // When: Adding order
        askLevel.addOrder(sellOrder1);

        // Then: Level should contain order and update metrics
        assertFalse(askLevel.isEmpty());
        assertEquals(1, askLevel.getOrderCount());
        assertEquals(new BigDecimal("10"), askLevel.getTotalQuantity());
        assertEquals(testPrice, askLevel.getPrice());
        assertTrue(askLevel.getFirstOrder().isPresent());
        assertEquals("order1", askLevel.getFirstOrder().get().getId());
    }

    @Test
    @DisplayName("Should maintain time priority within level")
    void should_maintain_time_priority_within_level() {
        // Given: Empty ask level

        // When: Adding orders in sequence
        askLevel.addOrder(sellOrder1); // Earlier time
        askLevel.addOrder(sellOrder2); // Later time

        // Then: First order should be at front of queue
        assertEquals("order1", askLevel.getFirstOrder().get().getId());
        assertEquals(2, askLevel.getOrderCount());
        assertEquals(new BigDecimal("15"), askLevel.getTotalQuantity());

        // And: Orders should be in time order
        assertEquals("order1", askLevel.getOrders().get(0).getId());
        assertEquals("order2", askLevel.getOrders().get(1).getId());
    }

    @Test
    @DisplayName("Should reject order with wrong price")
    void should_reject_order_with_wrong_price() {
        // Given: Order with different price
        ISellOrder wrongPriceOrder = mock(ISellOrder.class);
        when(wrongPriceOrder.getPrice()).thenReturn(Money.of("101.00", Currency.USD));

        // When/Then: Should throw exception
        assertThrows(IllegalArgumentException.class, () ->
                askLevel.addOrder(wrongPriceOrder));
    }
}=== ./order_book/OrderMatchTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order.domain.entities.ISellOrder;
import core.ms.order_book.domain.value_object.OrderMatch;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@DisplayName("Order Match Tests")
class OrderMatchTest {

    private IBuyOrder buyOrder;
    private ISellOrder sellOrder;
    private Symbol symbol;
    private LocalDateTime earlierTime;
    private LocalDateTime laterTime;

    @BeforeEach
    void setUp() {
        symbol = Symbol.btcUsd();
        buyOrder = mock(IBuyOrder.class);
        sellOrder = mock(ISellOrder.class);
        earlierTime = LocalDateTime.of(2024, 1, 1, 10, 0);
        laterTime = LocalDateTime.of(2024, 1, 1, 10, 5);
    }

    @Nested
    @DisplayName("Order Match Creation Tests")
    class OrderMatchCreationTests {

        @Test
        @DisplayName("Should create valid order match with buy order having time priority")
        void should_create_valid_order_match_with_buy_order_time_priority() {
            // Given: Buy order arrives first (has time priority)
            setupCompatibleOrdersWithTime(
                    Money.of("100.00", Currency.USD),
                    Money.of("99.00", Currency.USD),
                    new BigDecimal("10"),
                    new BigDecimal("5"),
                    earlierTime,  // Buy order first
                    laterTime     // Sell order later
            );

            // When: Creating order match
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);

            // Then: Should create valid match with buy order price (time priority)
            assertNotNull(match);
            assertEquals(buyOrder, match.getBuyOrder());
            assertEquals(sellOrder, match.getSellOrder());
            assertEquals(new BigDecimal("5"), match.getMatchableQuantity());
            assertEquals(Money.of("100.00", Currency.USD), match.getSuggestedPrice()); // Buy order price
            assertTrue(match.isValid());
            assertNotNull(match.getTimestamp());
        }

        @Test
        @DisplayName("Should create valid order match with sell order having time priority")
        void should_create_valid_order_match_with_sell_order_time_priority() {
            // Given: Sell order arrives first (has time priority)
            setupCompatibleOrdersWithTime(
                    Money.of("100.00", Currency.USD),
                    Money.of("99.00", Currency.USD),
                    new BigDecimal("10"),
                    new BigDecimal("5"),
                    laterTime,    // Buy order later
                    earlierTime   // Sell order first
            );

            // When: Creating order match
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);

            // Then: Should create valid match with sell order price (time priority)
            assertNotNull(match);
            assertEquals(buyOrder, match.getBuyOrder());
            assertEquals(sellOrder, match.getSellOrder());
            assertEquals(new BigDecimal("5"), match.getMatchableQuantity());
            assertEquals(Money.of("99.00", Currency.USD), match.getSuggestedPrice()); // Sell order price
            assertTrue(match.isValid());
            assertNotNull(match.getTimestamp());
        }

        @Test
        @DisplayName("Should use midpoint pricing when orders have same timestamp")
        void should_use_midpoint_pricing_when_orders_have_same_timestamp() {
            // Given: Orders with same timestamp
            LocalDateTime sameTime = LocalDateTime.of(2024, 1, 1, 10, 0);
            setupCompatibleOrdersWithTime(
                    Money.of("100.00", Currency.USD),
                    Money.of("98.00", Currency.USD),
                    new BigDecimal("10"),
                    new BigDecimal("5"),
                    sameTime,  // Same time
                    sameTime   // Same time
            );

            // When: Creating order match
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);

            // Then: Should use midpoint pricing
            assertEquals(Money.of("99.00", Currency.USD), match.getSuggestedPrice()); // Midpoint
            assertTrue(match.isValid());
        }

        @Test
        @DisplayName("Should calculate total value correctly with time priority")
        void should_calculate_total_value_correctly_with_time_priority() {
            // Given: Sell order has time priority
            setupCompatibleOrdersWithTime(
                    Money.of("100.00", Currency.USD),
                    Money.of("98.00", Currency.USD),
                    new BigDecimal("10"),
                    new BigDecimal("5"),
                    laterTime,    // Buy order later
                    earlierTime   // Sell order first (time priority)
            );

            // When: Creating order match
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);

            // Then: Should calculate total value using sell order price
            Money expectedPrice = Money.of("98.00", Currency.USD); // Sell order price (time priority)
            BigDecimal expectedQuantity = new BigDecimal("5");
            Money expectedTotal = expectedPrice.multiply(expectedQuantity);

            assertEquals(expectedTotal, match.getTotalValue());
        }

        @Test
        @DisplayName("Should reject incompatible symbols")
        void should_reject_incompatible_symbols() {
            // Given: Orders with different symbols
            when(buyOrder.getSymbol()).thenReturn(Symbol.btcUsd());
            when(sellOrder.getSymbol()).thenReturn(Symbol.ethUsd());
            when(buyOrder.getPrice()).thenReturn(Money.of("100.00", Currency.USD));
            when(sellOrder.getPrice()).thenReturn(Money.of("99.00", Currency.USD));
            when(buyOrder.isActive()).thenReturn(true);
            when(sellOrder.isActive()).thenReturn(true);
            when(buyOrder.getCreatedAt()).thenReturn(earlierTime);
            when(sellOrder.getCreatedAt()).thenReturn(laterTime);

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    new OrderMatch(buyOrder, sellOrder));
        }

        @Test
        @DisplayName("Should reject invalid price combination")
        void should_reject_invalid_price_combination() {
            // Given: Buy price < sell price
            setupCompatibleOrdersWithTime(
                    Money.of("98.00", Currency.USD),  // Buy price lower
                    Money.of("100.00", Currency.USD), // Sell price higher
                    new BigDecimal("10"),
                    new BigDecimal("5"),
                    earlierTime,
                    laterTime
            );

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    new OrderMatch(buyOrder, sellOrder));
        }

        @Test
        @DisplayName("Should reject inactive orders")
        void should_reject_inactive_orders() {
            // Given: Inactive buy order
            setupCompatibleOrdersWithTime(
                    Money.of("100.00", Currency.USD),
                    Money.of("99.00", Currency.USD),
                    new BigDecimal("10"),
                    new BigDecimal("5"),
                    earlierTime,
                    laterTime
            );
            when(buyOrder.isActive()).thenReturn(false);

            // When/Then: Should throw exception
            assertThrows(IllegalArgumentException.class, () ->
                    new OrderMatch(buyOrder, sellOrder));
        }
    }

    @Nested
    @DisplayName("Price-Time Priority Logic Tests")
    class PriceTimePriorityTests {

        @Test
        @DisplayName("Should give time priority to buy order when it arrives first")
        void should_give_time_priority_to_buy_order_when_it_arrives_first() {
            // Given: Buy order arrives 1 hour before sell order
            LocalDateTime buyTime = LocalDateTime.of(2024, 1, 1, 9, 0);  // 9:00 AM
            LocalDateTime sellTime = LocalDateTime.of(2024, 1, 1, 10, 0); // 10:00 AM

            setupCompatibleOrdersWithTime(
                    Money.of("105.00", Currency.USD), // Buy price
                    Money.of("100.00", Currency.USD), // Sell price
                    new BigDecimal("8"),
                    new BigDecimal("12"),
                    buyTime,   // Buy order first
                    sellTime   // Sell order later
            );

            // When: Creating order match
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);

            // Then: Should execute at buy order price (resting order gets filled)
            assertEquals(Money.of("105.00", Currency.USD), match.getSuggestedPrice());
            assertEquals(new BigDecimal("8"), match.getMatchableQuantity()); // Min quantity
        }

        @Test
        @DisplayName("Should give time priority to sell order when it arrives first")
        void should_give_time_priority_to_sell_order_when_it_arrives_first() {
            // Given: Sell order arrives before buy order
            LocalDateTime sellTime = LocalDateTime.of(2024, 1, 1, 9, 30);  // 9:30 AM
            LocalDateTime buyTime = LocalDateTime.of(2024, 1, 1, 10, 15);  // 10:15 AM

            setupCompatibleOrdersWithTime(
                    Money.of("102.50", Currency.USD), // Buy price
                    Money.of("101.75", Currency.USD), // Sell price
                    new BigDecimal("15"),
                    new BigDecimal("7"),
                    buyTime,   // Buy order later
                    sellTime   // Sell order first
            );

            // When: Creating order match
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);

            // Then: Should execute at sell order price (resting order gets filled)
            assertEquals(Money.of("101.75", Currency.USD), match.getSuggestedPrice());
            assertEquals(new BigDecimal("7"), match.getMatchableQuantity()); // Min quantity
        }

        @Test
        @DisplayName("Should handle microsecond time differences")
        void should_handle_microsecond_time_differences() {
            // Given: Orders with very small time difference
            LocalDateTime firstTime = LocalDateTime.of(2024, 1, 1, 10, 0, 0, 100000);  // .1 second
            LocalDateTime secondTime = LocalDateTime.of(2024, 1, 1, 10, 0, 0, 200000); // .2 second

            setupCompatibleOrdersWithTime(
                    Money.of("100.00", Currency.USD),
                    Money.of("99.50", Currency.USD),
                    new BigDecimal("5"),
                    new BigDecimal("5"),
                    secondTime, // Buy order later
                    firstTime   // Sell order first (by 0.1 second)
            );

            // When: Creating order match
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);

            // Then: Should still respect time priority
            assertEquals(Money.of("99.50", Currency.USD), match.getSuggestedPrice()); // Sell order price
        }
    }

    @Nested
    @DisplayName("Aggressor-Based Pricing Tests")
    class AggressorBasedPricingTests {

        @Test
        @DisplayName("Should calculate price correctly when buy order is aggressor")
        void should_calculate_price_correctly_when_buy_order_is_aggressor() {
            // Given: Compatible orders
            setupCompatibleOrdersWithTime(
                    Money.of("103.00", Currency.USD),
                    Money.of("102.00", Currency.USD),
                    new BigDecimal("10"),
                    new BigDecimal("5"),
                    earlierTime,
                    laterTime
            );

            // When: Creating match and calculating with buy aggressor
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);
            Money aggressorPrice = match.calculatePriceWithAggressor(true); // Buy is aggressor

            // Then: Should use sell order price (aggressor pays)
            assertEquals(Money.of("102.00", Currency.USD), aggressorPrice);
        }

        @Test
        @DisplayName("Should calculate price correctly when sell order is aggressor")
        void should_calculate_price_correctly_when_sell_order_is_aggressor() {
            // Given: Compatible orders
            setupCompatibleOrdersWithTime(
                    Money.of("103.00", Currency.USD),
                    Money.of("102.00", Currency.USD),
                    new BigDecimal("10"),
                    new BigDecimal("5"),
                    earlierTime,
                    laterTime
            );

            // When: Creating match and calculating with sell aggressor
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);
            Money aggressorPrice = match.calculatePriceWithAggressor(false); // Sell is aggressor

            // Then: Should use buy order price (aggressor accepts)
            assertEquals(Money.of("103.00", Currency.USD), aggressorPrice);
        }
    }

    private void setupCompatibleOrdersWithTime(Money buyPrice, Money sellPrice,
                                               BigDecimal buyQuantity, BigDecimal sellQuantity,
                                               LocalDateTime buyTime, LocalDateTime sellTime) {
        when(buyOrder.getSymbol()).thenReturn(symbol);
        when(sellOrder.getSymbol()).thenReturn(symbol);
        when(buyOrder.getPrice()).thenReturn(buyPrice);
        when(sellOrder.getPrice()).thenReturn(sellPrice);
        when(buyOrder.isActive()).thenReturn(true);
        when(sellOrder.isActive()).thenReturn(true);
        when(buyOrder.getRemainingQuantity()).thenReturn(buyQuantity);
        when(sellOrder.getRemainingQuantity()).thenReturn(sellQuantity);
        when(buyOrder.getCreatedAt()).thenReturn(buyTime);
        when(sellOrder.getCreatedAt()).thenReturn(sellTime);
    }

    // Backward compatibility method
    private void setupCompatibleOrders(Money buyPrice, Money sellPrice,
                                       BigDecimal buyQuantity, BigDecimal sellQuantity) {
        setupCompatibleOrdersWithTime(buyPrice, sellPrice, buyQuantity, sellQuantity,
                earlierTime, laterTime);
    }
}=== ./order_book/OrderBookManagerTest.java ===
package core.ms.order_book;

import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order.domain.entities.ISellOrder;
import core.ms.order_book.domain.OrderBook;
import core.ms.order_book.domain.OrderBookManager;
import core.ms.order_book.domain.value_object.MarketOverview;
import core.ms.order_book.domain.value_object.OrderMatch;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@DisplayName("Order Book Manager Tests")
class OrderBookManagerTest {

    private OrderBookManager manager;
    private Symbol btcSymbol;
    private Symbol ethSymbol;
    private Symbol aaplSymbol;
    private IBuyOrder btcBuyOrder;
    private ISellOrder btcSellOrder;
    private IBuyOrder ethBuyOrder;
    private ISellOrder ethSellOrder;
    private IBuyOrder aaplBuyOrder;
    private ISellOrder aaplSellOrder;

    @BeforeEach
    void setUp() {
        manager = new OrderBookManager();
        btcSymbol = Symbol.btcUsd();
        ethSymbol = Symbol.ethUsd();
        aaplSymbol = createMockSymbol("AAPL");

        // Setup orders for different symbols
        btcBuyOrder = createMockBuyOrder("btc-buy-1", btcSymbol,
                Money.of("50000.00", Currency.USD), new BigDecimal("1.5"),
                LocalDateTime.of(2024, 1, 1, 10, 0));
        btcSellOrder = createMockSellOrder("btc-sell-1", btcSymbol,
                Money.of("49500.00", Currency.USD), new BigDecimal("0.8"),
                LocalDateTime.of(2024, 1, 1, 10, 1));

        ethBuyOrder = createMockBuyOrder("eth-buy-1", ethSymbol,
                Money.of("3000.00", Currency.USD), new BigDecimal("5.0"),
                LocalDateTime.of(2024, 1, 1, 10, 2));
        ethSellOrder = createMockSellOrder("eth-sell-1", ethSymbol,
                Money.of("3100.00", Currency.USD), new BigDecimal("3.0"),
                LocalDateTime.of(2024, 1, 1, 10, 3));

        aaplBuyOrder = createMockBuyOrder("aapl-buy-1", aaplSymbol,
                Money.of("180.00", Currency.USD), new BigDecimal("100"),
                LocalDateTime.of(2024, 1, 1, 10, 4));
        aaplSellOrder = createMockSellOrder("aapl-sell-1", aaplSymbol,
                Money.of("179.50", Currency.USD), new BigDecimal("150"),
                LocalDateTime.of(2024, 1, 1, 10, 5));
    }

    @Nested
    @DisplayName("Order Book Management Tests")
    class OrderBookManagementTests {

        @Test
        @DisplayName("Should create order book for new symbol")
        void should_create_order_book_for_new_symbol() {
            // Given: Empty manager
            assertEquals(0, manager.getTotalOrderBooks());

            // When: Getting order book for new symbol
            OrderBook orderBook = manager.getOrderBook(btcSymbol);

            // Then: Should create and return new book
            assertNotNull(orderBook);
            assertEquals(btcSymbol, orderBook.getSymbol());
            assertEquals(1, manager.getTotalOrderBooks());
            assertTrue(manager.getActiveSymbols().contains(btcSymbol));
            assertTrue(orderBook.isEmpty());
        }

        @Test
        @DisplayName("Should return existing order book")
        void should_return_existing_order_book() {
            // Given: Manager with existing book
            OrderBook firstCall = manager.getOrderBook(btcSymbol);

            // When: Getting same symbol again
            OrderBook secondCall = manager.getOrderBook(btcSymbol);

            // Then: Should return same instance
            assertSame(firstCall, secondCall);
            assertEquals(1, manager.getTotalOrderBooks());
        }

        @Test
        @DisplayName("Should create separate books for different symbols")
        void should_create_separate_books_for_different_symbols() {
            // Given: Manager

            // When: Getting books for different symbols
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            OrderBook ethBook = manager.getOrderBook(ethSymbol);
            OrderBook aaplBook = manager.getOrderBook(aaplSymbol);

            // Then: Should create separate books
            assertNotSame(btcBook, ethBook);
            assertNotSame(ethBook, aaplBook);
            assertEquals(3, manager.getTotalOrderBooks());

            Set<Symbol> activeSymbols = manager.getActiveSymbols();
            assertEquals(3, activeSymbols.size());
            assertTrue(activeSymbols.contains(btcSymbol));
            assertTrue(activeSymbols.contains(ethSymbol));
            assertTrue(activeSymbols.contains(aaplSymbol));
        }

        @Test
        @DisplayName("Should create order book explicitly")
        void should_create_order_book_explicitly() {
            // Given: Empty manager
            assertEquals(0, manager.getTotalOrderBooks());

            // When: Creating order book explicitly
            OrderBook orderBook = manager.createOrderBook(btcSymbol);

            // Then: Should create new book
            assertNotNull(orderBook);
            assertEquals(btcSymbol, orderBook.getSymbol());
            assertEquals(1, manager.getTotalOrderBooks());

            // And: Should be retrievable
            OrderBook retrieved = manager.getOrderBook(btcSymbol);
            assertSame(orderBook, retrieved);
        }

        @Test
        @DisplayName("Should reject creating duplicate order book")
        void should_reject_creating_duplicate_order_book() {
            // Given: Manager with existing book
            manager.createOrderBook(btcSymbol);

            // When/Then: Should throw exception for duplicate
            assertThrows(IllegalArgumentException.class, () ->
                    manager.createOrderBook(btcSymbol));
        }

        @Test
        @DisplayName("Should remove order book")
        void should_remove_order_book() {
            // Given: Manager with order books
            manager.getOrderBook(btcSymbol);
            manager.getOrderBook(ethSymbol);
            assertEquals(2, manager.getTotalOrderBooks());

            // When: Removing one book
            boolean removed = manager.removeOrderBook(btcSymbol);

            // Then: Should remove successfully
            assertTrue(removed);
            assertEquals(1, manager.getTotalOrderBooks());
            assertFalse(manager.getActiveSymbols().contains(btcSymbol));
            assertTrue(manager.getActiveSymbols().contains(ethSymbol));
        }

        @Test
        @DisplayName("Should return false when removing non-existent book")
        void should_return_false_when_removing_non_existent_book() {
            // Given: Empty manager
            assertEquals(0, manager.getTotalOrderBooks());

            // When: Removing non-existent book
            boolean removed = manager.removeOrderBook(btcSymbol);

            // Then: Should return false
            assertFalse(removed);
            assertEquals(0, manager.getTotalOrderBooks());
        }

        @Test
        @DisplayName("Should handle null symbol gracefully")
        void should_handle_null_symbol_gracefully() {
            // When/Then: Should throw exception for null symbol
            assertThrows(NullPointerException.class, () ->
                    manager.getOrderBook(null));
            assertThrows(NullPointerException.class, () ->
                    manager.createOrderBook(null));
            assertThrows(NullPointerException.class, () ->
                    manager.removeOrderBook(null));
        }
    }

    @Nested
    @DisplayName("Order Management Tests")
    class OrderManagementTests {

        @Test
        @DisplayName("Should add order to correct book")
        void should_add_order_to_correct_book() {
            // Given: Manager and order

            // When: Adding order
            manager.addOrderToBook(btcBuyOrder);

            // Then: Should be in correct book
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            assertEquals(1, btcBook.getOrderCount());
            assertEquals(btcBuyOrder.getId(), btcBook.getBestBuyOrder().get().getId());
            assertEquals(new BigDecimal("1.5"), btcBook.getTotalBidVolume());

            // And: Other books should remain empty
            OrderBook ethBook = manager.getOrderBook(ethSymbol);
            assertTrue(ethBook.isEmpty());
        }

        @Test
        @DisplayName("Should add multiple orders to different books")
        void should_add_multiple_orders_to_different_books() {
            // Given: Manager and orders for different symbols

            // When: Adding orders to different books
            manager.addOrderToBook(btcBuyOrder);
            manager.addOrderToBook(ethBuyOrder);
            manager.addOrderToBook(aaplBuyOrder);

            // Then: Each book should contain its order
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            OrderBook ethBook = manager.getOrderBook(ethSymbol);
            OrderBook aaplBook = manager.getOrderBook(aaplSymbol);

            assertEquals(1, btcBook.getOrderCount());
            assertEquals(1, ethBook.getOrderCount());
            assertEquals(1, aaplBook.getOrderCount());

            assertEquals("btc-buy-1", btcBook.getBestBuyOrder().get().getId());
            assertEquals("eth-buy-1", ethBook.getBestBuyOrder().get().getId());
            assertEquals("aapl-buy-1", aaplBook.getBestBuyOrder().get().getId());
        }

        @Test
        @DisplayName("Should remove order from correct book")
        void should_remove_order_from_correct_book() {
            // Given: Manager with orders in different books
            manager.addOrderToBook(btcBuyOrder);
            manager.addOrderToBook(ethBuyOrder);

            // When: Removing order from specific book
            boolean removed = manager.removeOrderFromBook(btcBuyOrder, btcSymbol);

            // Then: Should remove from correct book only
            assertTrue(removed);

            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            OrderBook ethBook = manager.getOrderBook(ethSymbol);

            assertEquals(0, btcBook.getOrderCount());
            assertEquals(1, ethBook.getOrderCount());
            assertEquals("eth-buy-1", ethBook.getBestBuyOrder().get().getId());
        }

        @Test
        @DisplayName("Should return false when removing order from wrong book")
        void should_return_false_when_removing_order_from_wrong_book() {
            // Given: Order in BTC book
            manager.addOrderToBook(btcBuyOrder);

            // When: Trying to remove from ETH book
            boolean removed = manager.removeOrderFromBook(btcBuyOrder, ethSymbol);

            // Then: Should return false
            assertFalse(removed);

            // And: Order should still be in BTC book
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            assertEquals(1, btcBook.getOrderCount());
        }

        @Test
        @DisplayName("Should return false when removing from non-existent book")
        void should_return_false_when_removing_from_non_existent_book() {
            // Given: Manager without the symbol's book

            // When: Removing order from non-existent book
            boolean removed = manager.removeOrderFromBook(btcBuyOrder, btcSymbol);

            // Then: Should return false
            assertFalse(removed);
            assertEquals(0, manager.getTotalOrderBooks());
        }
    }

    @Nested
    @DisplayName("Cross-Book Operations Tests")
    class CrossBookOperationsTests {

        @Test
        @DisplayName("Should find matches across all books")
        void should_find_matches_across_all_books() {
            // Given: Multiple books with some having matches
            // BTC: Can match (buy $50k >= sell $49.5k)
            manager.addOrderToBook(btcBuyOrder);  // $50,000
            manager.addOrderToBook(btcSellOrder); // $49,500

            // ETH: Cannot match (buy $3k < sell $3.1k)
            manager.addOrderToBook(ethBuyOrder);  // $3,000
            manager.addOrderToBook(ethSellOrder); // $3,100

            // AAPL: Can match (buy $180 >= sell $179.50)
            manager.addOrderToBook(aaplBuyOrder);  // $180.00
            manager.addOrderToBook(aaplSellOrder); // $179.50

            // When: Finding all matches
            List<OrderMatch> matches = manager.findAllMatches();

            // Then: Should find matches from matching books only
            assertEquals(2, matches.size());

            // Verify BTC match
            OrderMatch btcMatch = matches.stream()
                    .filter(m -> m.getBuyOrder().getSymbol().equals(btcSymbol))
                    .findFirst().orElse(null);
            assertNotNull(btcMatch);
            assertEquals("btc-buy-1", btcMatch.getBuyOrder().getId());
            assertEquals("btc-sell-1", btcMatch.getSellOrder().getId());

            // Verify AAPL match
            OrderMatch aaplMatch = matches.stream()
                    .filter(m -> m.getBuyOrder().getSymbol().equals(aaplSymbol))
                    .findFirst().orElse(null);
            assertNotNull(aaplMatch);
            assertEquals("aapl-buy-1", aaplMatch.getBuyOrder().getId());
            assertEquals("aapl-sell-1", aaplMatch.getSellOrder().getId());

            // Verify no ETH match (no match should exist)
            boolean hasEthMatch = matches.stream()
                    .anyMatch(m -> m.getBuyOrder().getSymbol().equals(ethSymbol));
            assertFalse(hasEthMatch);
        }

        @Test
        @DisplayName("Should return empty list when no matches exist")
        void should_return_empty_list_when_no_matches_exist() {
            // Given: Books with no matching orders
            manager.addOrderToBook(ethBuyOrder);  // $3,000
            manager.addOrderToBook(ethSellOrder); // $3,100 (no match)

            // When: Finding matches
            List<OrderMatch> matches = manager.findAllMatches();

            // Then: Should return empty list
            assertTrue(matches.isEmpty());
        }

        @Test
        @DisplayName("Should return empty list for empty manager")
        void should_return_empty_list_for_empty_manager() {
            // Given: Empty manager
            assertEquals(0, manager.getTotalOrderBooks());

            // When: Finding matches
            List<OrderMatch> matches = manager.findAllMatches();

            // Then: Should return empty list
            assertTrue(matches.isEmpty());
        }

        @Test
        @DisplayName("Should aggregate data correctly in market overview")
        void should_aggregate_data_correctly_in_market_overview() {
            // Given: Manager with multiple populated books
            setupManagerWithMultipleBooks();

            // When: Getting market overview
            MarketOverview overview = manager.getMarketOverview();

            // Then: Should aggregate all data correctly
            assertEquals(3, overview.getTotalOrderBooks());
            assertEquals(6, overview.getTotalOrders()); // 2 orders per symbol

            Set<Symbol> activeSymbols = overview.getActiveSymbols();
            assertEquals(3, activeSymbols.size());
            assertTrue(activeSymbols.contains(btcSymbol));
            assertTrue(activeSymbols.contains(ethSymbol));
            assertTrue(activeSymbols.contains(aaplSymbol));

            // Verify volume calculations
            Map<Symbol, BigDecimal> volumes = overview.getTotalVolume();

            // BTC: Buy 1.5 + Sell 0.8 = 2.3
            assertEquals(new BigDecimal("2.3"), volumes.get(btcSymbol));

            // ETH: Buy 5.0 + Sell 3.0 = 8.0
            assertEquals(new BigDecimal("8.0"), volumes.get(ethSymbol));

            // AAPL: Buy 100 + Sell 150 = 250
            assertEquals(new BigDecimal("250"), volumes.get(aaplSymbol));

            assertNotNull(overview.getTimestamp());
        }

        @Test
        @DisplayName("Should return correct volume for specific symbol")
        void should_return_correct_volume_for_specific_symbol() {
            // Given: Manager with orders
            setupManagerWithMultipleBooks();
            MarketOverview overview = manager.getMarketOverview();

            // When: Getting volume for specific symbols
            BigDecimal btcVolume = overview.getVolumeForSymbol(btcSymbol);
            BigDecimal ethVolume = overview.getVolumeForSymbol(ethSymbol);
            BigDecimal unknownVolume = overview.getVolumeForSymbol(createMockSymbol("UNKNOWN"));

            // Then: Should return correct volumes
            assertEquals(new BigDecimal("2.3"), btcVolume);
            assertEquals(new BigDecimal("8.0"), ethVolume);
            assertEquals(BigDecimal.ZERO, unknownVolume); // Unknown symbol
        }

        @Test
        @DisplayName("Should handle empty books in market overview")
        void should_handle_empty_books_in_market_overview() {
            // Given: Manager with empty books
            manager.getOrderBook(btcSymbol); // Creates empty book
            manager.getOrderBook(ethSymbol); // Creates empty book

            // When: Getting market overview
            MarketOverview overview = manager.getMarketOverview();

            // Then: Should handle empty books correctly
            assertEquals(2, overview.getTotalOrderBooks());
            assertEquals(0, overview.getTotalOrders());
            assertEquals(2, overview.getActiveSymbols().size());

            Map<Symbol, BigDecimal> volumes = overview.getTotalVolume();
            assertEquals(BigDecimal.ZERO, volumes.get(btcSymbol));
            assertEquals(BigDecimal.ZERO, volumes.get(ethSymbol));
        }

        @Test
        @DisplayName("Should return all order books")
        void should_return_all_order_books() {
            // Given: Manager with multiple books
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            OrderBook ethBook = manager.getOrderBook(ethSymbol);
            OrderBook aaplBook = manager.getOrderBook(aaplSymbol);

            // When: Getting all order books
            Collection<OrderBook> allBooks = manager.getAllOrderBooks();

            // Then: Should return all books
            assertEquals(3, allBooks.size());
            assertTrue(allBooks.contains(btcBook));
            assertTrue(allBooks.contains(ethBook));
            assertTrue(allBooks.contains(aaplBook));
        }
    }

    @Nested
    @DisplayName("Thread Safety Tests")
    class ThreadSafetyTests {

        @Test
        @DisplayName("Should handle concurrent order book creation")
        void should_handle_concurrent_order_book_creation() throws Exception {
            // Given: Multiple threads trying to create same book
            int threadCount = 10;
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch startLatch = new CountDownLatch(1);
            CountDownLatch finishLatch = new CountDownLatch(threadCount);

            List<Future<OrderBook>> futures = new ArrayList<>();

            // When: Multiple threads request same order book
            for (int i = 0; i < threadCount; i++) {
                Future<OrderBook> future = executor.submit(() -> {
                    try {
                        startLatch.await(); // Wait for all threads to be ready
                        return manager.getOrderBook(btcSymbol);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException(e);
                    } finally {
                        finishLatch.countDown();
                    }
                });
                futures.add(future);
            }

            startLatch.countDown(); // Start all threads
            finishLatch.await(); // Wait for completion

            // Then: All threads should get same instance
            OrderBook firstBook = futures.get(0).get();
            for (Future<OrderBook> future : futures) {
                assertSame(firstBook, future.get());
            }

            // And: Only one book should be created
            assertEquals(1, manager.getTotalOrderBooks());

            executor.shutdown();
        }



        @Test
        @DisplayName("Should handle concurrent order operations")
        void should_handle_concurrent_order_operations() throws Exception {
            // Given: Shared order book and multiple orders
            OrderBook btcBook = manager.getOrderBook(btcSymbol);
            int orderCount = 20;
            ExecutorService executor = Executors.newFixedThreadPool(5);
            CountDownLatch finishLatch = new CountDownLatch(orderCount);

            // When: Multiple threads add orders concurrently
            for (int i = 0; i < orderCount; i++) {
                final int orderId = i;
                executor.submit(() -> {
                    try {
                        if (orderId % 2 == 0) {
                            IBuyOrder order = createMockBuyOrder("buy-" + orderId, btcSymbol,
                                    Money.of("50000.00", Currency.USD), new BigDecimal("0.1"),
                                    LocalDateTime.now());
                            manager.addOrderToBook(order);
                        } else {
                            ISellOrder order = createMockSellOrder("sell-" + orderId, btcSymbol,
                                    Money.of("50000.00", Currency.USD), new BigDecimal("0.1"),
                                    LocalDateTime.now());
                            manager.addOrderToBook(order);
                        }
                    } finally {
                        finishLatch.countDown();
                    }
                });
            }

            finishLatch.await(); // Wait for completion

            // Then: All orders should be added successfully
            assertEquals(orderCount, btcBook.getOrderCount());

            executor.shutdown();
        }
    }

    // Helper methods
    private void setupManagerWithMultipleBooks() {
        // Add orders to create books with data
        manager.addOrderToBook(btcBuyOrder);
        manager.addOrderToBook(btcSellOrder);
        manager.addOrderToBook(ethBuyOrder);
        manager.addOrderToBook(ethSellOrder);
        manager.addOrderToBook(aaplBuyOrder);
        manager.addOrderToBook(aaplSellOrder);
    }

    private Symbol createMockSymbol(String code) {
        Symbol symbol = mock(Symbol.class);
        when(symbol.getCode()).thenReturn(code);
        when(symbol.toString()).thenReturn(code);

        // Remove these lines - can't mock equals() and hashCode()
        // when(symbol.equals(any(Object.class)))...
        // when(symbol.hashCode())...

        return symbol;
    }

    private IBuyOrder createMockBuyOrder(String id, Symbol symbol, Money price,
                                         BigDecimal quantity, LocalDateTime time) {
        IBuyOrder order = mock(IBuyOrder.class);
        when(order.getId()).thenReturn(id);
        when(order.getSymbol()).thenReturn(symbol);
        when(order.getPrice()).thenReturn(price);
        when(order.getRemainingQuantity()).thenReturn(quantity);
        when(order.getCreatedAt()).thenReturn(time);
        when(order.isActive()).thenReturn(true);
        return order;
    }

    private ISellOrder createMockSellOrder(String id, Symbol symbol, Money price,
                                           BigDecimal quantity, LocalDateTime time) {
        ISellOrder order = mock(ISellOrder.class);
        when(order.getId()).thenReturn(id);
        when(order.getSymbol()).thenReturn(symbol);
        when(order.getPrice()).thenReturn(price);
        when(order.getRemainingQuantity()).thenReturn(quantity);
        when(order.getCreatedAt()).thenReturn(time);
        when(order.isActive()).thenReturn(true);
        return order;
    }
}=== ./market_engine/MarketEngineTest.java ===
package core.ms.market_engine;

import core.ms.order.domain.entities.BuyOrder;
import core.ms.order.domain.entities.IBuyOrder;
import core.ms.order.domain.entities.ISellOrder;
import core.ms.order.domain.entities.SellOrder;
import core.ms.order.domain.value_objects.OrderStatusEnum;
import core.ms.order_book.domain.OrderBook;
import core.ms.order_book.domain.OrderBookManager;
import core.ms.order_book.domain.value_object.AskPriceLevel;
import core.ms.order_book.domain.value_object.BidPriceLevel;
import core.ms.order_book.domain.value_object.OrderMatch;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class MarketEngineTest {

    private MarketEngine marketEngine;
    private OrderBookManager orderBookManager;
    private Symbol testSymbol;
    private Money testPrice;

    @BeforeEach
    void setUp() {
        orderBookManager = new OrderBookManager();
        marketEngine = new MarketEngine("engine-1", orderBookManager);
        testSymbol = Symbol.eurUsd();
        testPrice = Money.of("1.2000", Currency.USD);
    }

    @Test
    @DisplayName("Should accept order when no matches found")
    void shouldAcceptOrderWhenNoMatchesFound() {
        // Given
        IBuyOrder buyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("100"));

        // When
        OrderResult result = marketEngine.processOrder(buyOrder);

        // Then
        assertTrue(result.isSuccess());
        assertEquals("buy-1", result.getOrderId());
        assertEquals("Order accepted", result.getMessage());
        assertTrue(result.getTransactionIds().isEmpty());
        assertNotNull(result.getTimestamp());
    }

    @Test
    @DisplayName("Should accept order and create transaction when match found")
    void shouldAcceptOrderAndCreateTransactionWhenMatchFound() {
        // Given - Add a sell order first
        ISellOrder sellOrder = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("50"));
        marketEngine.processOrder(sellOrder);

        // When - Add matching buy order
        IBuyOrder buyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("100"));
        OrderResult result = marketEngine.processOrder(buyOrder);

        // Then
        assertTrue(result.isSuccess());
        assertEquals("buy-1", result.getOrderId());
        assertEquals("Order accepted and executed", result.getMessage());
        assertEquals(1, result.getTransactionIds().size());

        // Verify orders are updated
        assertEquals(new BigDecimal("50"), buyOrder.getRemainingQuantity());
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(BigDecimal.ZERO, sellOrder.getRemainingQuantity());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
    }

    @Test
    @DisplayName("Should process multiple orders creating multiple transactions")
    void shouldProcessMultipleOrdersCreatingMultipleTransactions() {
        // Given - Add multiple sell orders
        ISellOrder sellOrder1 = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("30"));
        ISellOrder sellOrder2 = new SellOrder("sell-2", testSymbol, testPrice, new BigDecimal("20"));
        marketEngine.processOrder(sellOrder1);
        marketEngine.processOrder(sellOrder2);

        // When - Add buy order that can match both
        IBuyOrder buyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("100"));
        OrderResult result = marketEngine.processOrder(buyOrder);

        // Then
        assertTrue(result.isSuccess());
        assertEquals("buy-1", result.getOrderId());
        assertEquals("Order accepted and executed", result.getMessage());

        // Should create one transaction (matching logic finds best match first)
        assertEquals(1, result.getTransactionIds().size());
    }

    @Test
    @DisplayName("Should handle orders with different symbols independently")
    void shouldHandleOrdersWithDifferentSymbolsIndependently() {
        // Given
        Symbol btcSymbol = Symbol.btcUsd();
        Money btcPrice = Money.of("50000.00", Currency.USD);

        IBuyOrder eurBuyOrder = new BuyOrder("eur-buy-1", testSymbol, testPrice, new BigDecimal("100"));
        IBuyOrder btcBuyOrder = new BuyOrder("btc-buy-1", btcSymbol, btcPrice, new BigDecimal("1"));

        // When
        OrderResult eurResult = marketEngine.processOrder(eurBuyOrder);
        OrderResult btcResult = marketEngine.processOrder(btcBuyOrder);

        // Then
        assertTrue(eurResult.isSuccess());
        assertTrue(btcResult.isSuccess());
        assertTrue(eurResult.getTransactionIds().isEmpty());
        assertTrue(btcResult.getTransactionIds().isEmpty());

        // Verify orders are in separate order books
        assertEquals(2, orderBookManager.getActiveSymbols().size());
        assertTrue(orderBookManager.getActiveSymbols().contains(testSymbol));
        assertTrue(orderBookManager.getActiveSymbols().contains(btcSymbol));
    }

    @Test
    @DisplayName("Should reject order when exception occurs during processing")
    void shouldRejectOrderWhenExceptionOccursDuringProcessing() {
        // Given - Create order with null ID to cause exception
        try {
            IBuyOrder invalidOrder = new BuyOrder(null, testSymbol, testPrice, new BigDecimal("100"));
            fail("Should have thrown exception during order creation");
        } catch (Exception e) {
            // Expected - order creation should fail with null ID
            assertTrue(e.getMessage().contains("cannot be null"));
        }
    }

    @Test
    @DisplayName("Should handle partially filled orders correctly")
    void shouldHandlePartiallyFilledOrdersCorrectly() {
        // Given
        ISellOrder smallSellOrder = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("25"));
        marketEngine.processOrder(smallSellOrder);

        // When
        IBuyOrder largeBuyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("100"));
        OrderResult result = marketEngine.processOrder(largeBuyOrder);

        // Then
        assertTrue(result.isSuccess());
        assertEquals(1, result.getTransactionIds().size());

        // Buy order should be partially filled
        assertEquals(new BigDecimal("75"), largeBuyOrder.getRemainingQuantity());
        assertEquals(OrderStatusEnum.PARTIAL, largeBuyOrder.getStatus().getStatus());

        // Sell order should be fully filled
        assertEquals(BigDecimal.ZERO, smallSellOrder.getRemainingQuantity());
        assertEquals(OrderStatusEnum.FILLED, smallSellOrder.getStatus().getStatus());
    }

    @Test
    @DisplayName("Should throw exception when creating engine with null parameters")
    void shouldThrowExceptionWhenCreatingEngineWithNullParameters() {
        // When & Then
        assertThrows(
                NullPointerException.class,
                () -> new MarketEngine(null, orderBookManager)
        );

        assertThrows(
                NullPointerException.class,
                () -> new MarketEngine("engine-1", null)
        );
    }

    @Test
    @DisplayName("Should throw exception when processing null order")
    void shouldThrowExceptionWhenProcessingNullOrder() {
        // When & Then
        NullPointerException exception = assertThrows(
                NullPointerException.class,
                () -> marketEngine.processOrder(null)
        );
        assertEquals("Order cannot be null", exception.getMessage());
    }

    @Test
    @DisplayName("Should have valid engine properties")
    void shouldHaveValidEngineProperties() {
        // Then
        assertEquals("engine-1", marketEngine.getEngineId());
        assertNotNull(marketEngine.getCreatedAt());
    }

    @Test
    @DisplayName("Should handle sequential order processing correctly")
    void shouldHandleSequentialOrderProcessingCorrectly() {
        // Given - Create orders
        ISellOrder sellOrder1 = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("30"));
        ISellOrder sellOrder2 = new SellOrder("sell-2", testSymbol, testPrice, new BigDecimal("40"));
        IBuyOrder buyOrder1 = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("20"));
        IBuyOrder buyOrder2 = new BuyOrder("buy-2", testSymbol, testPrice, new BigDecimal("35"));

        // When - Process orders sequentially
        System.out.println("=== INITIAL STATE ===");
        OrderBook orderBook = orderBookManager.getOrderBook(testSymbol);
        System.out.println("Initial matches: " + orderBookManager.findAllMatches().size());

        // Add sell orders
        OrderResult sellResult1 = marketEngine.processOrder(sellOrder1);
        OrderResult sellResult2 = marketEngine.processOrder(sellOrder2);

        System.out.println("=== AFTER ADDING SELL ORDERS ===");
        System.out.println("Best ask: " + orderBook.getBestAsk());
        System.out.println("Ask levels count: " + orderBook.getAskLevels().size());
        for (AskPriceLevel askLevel : orderBook.getAskLevels()) {
            System.out.println("Ask level at " + askLevel.getPrice() + ": " + askLevel.getTotalQuantity() + " total");
            for (ISellOrder order : askLevel.getOrders()) {
                System.out.println("  Order " + order.getId() + ": " + order.getRemainingQuantity() + " remaining");
            }
        }

        // Add first buy order
        OrderResult buyResult1 = marketEngine.processOrder(buyOrder1);

        System.out.println("=== AFTER FIRST BUY ORDER ===");
        System.out.println("sellOrder1 remaining: " + sellOrder1.getRemainingQuantity());
        System.out.println("sellOrder1 active: " + sellOrder1.isActive());
        System.out.println("sellOrder2 remaining: " + sellOrder2.getRemainingQuantity());
        System.out.println("Best ask: " + orderBook.getBestAsk());
        System.out.println("Ask levels count: " + orderBook.getAskLevels().size());

        for (AskPriceLevel askLevel : orderBook.getAskLevels()) {
            System.out.println("Ask level at " + askLevel.getPrice() + ": " + askLevel.getTotalQuantity() + " total");
            for (ISellOrder order : askLevel.getOrders()) {
                System.out.println("  Order " + order.getId() + ": " + order.getRemainingQuantity() + " remaining");
            }
        }

        // Check object references
        if (!orderBook.getAskLevels().isEmpty()) {
            AskPriceLevel askLevel = orderBook.getAskLevels().iterator().next();
            if (!askLevel.getOrders().isEmpty()) {
                ISellOrder orderBookOrder = askLevel.getOrders().get(0);
                System.out.println("sellOrder1 object ID: " + System.identityHashCode(sellOrder1));
                System.out.println("OrderBook order ID: " + System.identityHashCode(orderBookOrder));
                System.out.println("OrderBook order remaining: " + orderBookOrder.getRemainingQuantity());
            }
        }

        System.out.println("=== BEFORE SECOND BUY ORDER ===");

        // Debug the MatchFinder logic
        System.out.println("OrderBook best bid: " + orderBook.getBestBid());
        System.out.println("OrderBook best ask: " + orderBook.getBestAsk());
        System.out.println("OrderBook best buy order: " + orderBook.getBestBuyOrder());
        System.out.println("OrderBook best sell order: " + orderBook.getBestSellOrder());

        // Check if there are any buy orders in the book at all
        System.out.println("Bid levels count: " + orderBook.getBidLevels().size());
        for (BidPriceLevel bidLevel : orderBook.getBidLevels()) {
            System.out.println("Bid level at " + bidLevel.getPrice() + ": " + bidLevel.getTotalQuantity() + " total");
            for (IBuyOrder order : bidLevel.getOrders()) {
                System.out.println("  Order " + order.getId() + ": " + order.getRemainingQuantity() + " remaining");
            }
        }

        List<OrderMatch> matchesBeforeBuy2 = orderBookManager.findAllMatches();
        System.out.println("Matches found for buyOrder2: " + matchesBeforeBuy2.size());

        // Add second buy order
        OrderResult buyResult2 = marketEngine.processOrder(buyOrder2);

        System.out.println("=== AFTER ADDING SECOND BUY ORDER ===");
        System.out.println("OrderBook best bid: " + orderBook.getBestBid());
        System.out.println("OrderBook best ask: " + orderBook.getBestAsk());
        System.out.println("OrderBook best buy order: " + orderBook.getBestBuyOrder());
        System.out.println("OrderBook best sell order: " + orderBook.getBestSellOrder());

        // Check bid levels after adding buyOrder2
        System.out.println("Bid levels count after buyOrder2: " + orderBook.getBidLevels().size());
        for (BidPriceLevel bidLevel : orderBook.getBidLevels()) {
            System.out.println("Bid level at " + bidLevel.getPrice() + ": " + bidLevel.getTotalQuantity() + " total");
            for (IBuyOrder order : bidLevel.getOrders()) {
                System.out.println("  Order " + order.getId() + ": " + order.getRemainingQuantity() + " remaining");
            }
        }

        // Check ask levels after buyOrder2
        System.out.println("Ask levels count after buyOrder2: " + orderBook.getAskLevels().size());
        for (AskPriceLevel askLevel : orderBook.getAskLevels()) {
            System.out.println("Ask level at " + askLevel.getPrice() + ": " + askLevel.getTotalQuantity() + " total");
            for (ISellOrder order : askLevel.getOrders()) {
                System.out.println("  Order " + order.getId() + ": " + order.getRemainingQuantity() + " remaining");
            }
        }

        System.out.println("=== FINAL STATE ===");
        System.out.println("buyResult2: " + buyResult2);

        // Then - Assertions
        assertTrue(sellResult1.isSuccess());
        assertTrue(sellResult2.isSuccess());
        assertTrue(buyResult1.isSuccess());
        assertTrue(buyResult2.isSuccess());

        assertTrue(sellResult1.getTransactionIds().isEmpty());  // No matches when added
        assertTrue(sellResult2.getTransactionIds().isEmpty());  // No matches when added
        assertEquals(1, buyResult1.getTransactionIds().size()); // Matches with sell-1
        assertEquals(1, buyResult2.getTransactionIds().size()); // Matches with best available
    }
}=== ./market_engine/TransactionProcessorTest.java ===
package core.ms.market_engine;

import core.ms.order.domain.entities.*;
import core.ms.order.domain.value_objects.OrderStatusEnum;
import core.ms.order_book.domain.value_object.OrderMatch;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class TransactionProcessorTest {

    private TransactionProcessor transactionProcessor;
    private Symbol testSymbol;
    private Money testPrice;

    @BeforeEach
    void setUp() {
        transactionProcessor = new TransactionProcessor();
        testSymbol = Symbol.eurUsd();
        testPrice = Money.of("1.2000", Currency.USD);
    }

    @Test
    @DisplayName("Should create transaction from valid order match")
    void shouldCreateTransactionFromValidOrderMatch() {
        // Given
        IBuyOrder buyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("100"));
        ISellOrder sellOrder = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("50"));
        OrderMatch match = new OrderMatch(buyOrder, sellOrder);

        // When
        ITransaction transaction = transactionProcessor.createTransaction(match);

        // Then
        assertNotNull(transaction);
        assertNotNull(transaction.getId());
        assertEquals(testSymbol, transaction.getSymbol());
        assertEquals(buyOrder, transaction.getBuyOrder());
        assertEquals(sellOrder, transaction.getSellOrder());
        assertEquals(testPrice, transaction.getPrice());
        assertEquals(new BigDecimal("50"), transaction.getQuantity()); // Min of buy/sell quantities
    }

    @Test
    @DisplayName("Should throw exception when creating transaction from null match")
    void shouldThrowExceptionWhenCreatingTransactionFromNullMatch() {
        // When & Then
        NullPointerException exception = assertThrows(
                NullPointerException.class,
                () -> transactionProcessor.createTransaction(null)
        );
        assertEquals("OrderMatch cannot be null", exception.getMessage());
    }

    @Test
    @DisplayName("Should throw exception when creating transaction from invalid match")
    void shouldThrowExceptionWhenCreatingTransactionFromInvalidMatch() {
        // Given - Create orders that won't match (buy price < sell price)
        IBuyOrder buyOrder = new BuyOrder("buy-1", testSymbol, Money.of("1.1000", Currency.USD), new BigDecimal("100"));
        ISellOrder sellOrder = new SellOrder("sell-1", testSymbol, Money.of("1.2000", Currency.USD), new BigDecimal("50"));

        // This should throw in OrderMatch constructor, but if it doesn't:
        try {
            OrderMatch match = new OrderMatch(buyOrder, sellOrder);
            // When & Then
            IllegalArgumentException exception = assertThrows(
                    IllegalArgumentException.class,
                    () -> transactionProcessor.createTransaction(match)
            );
            assertEquals("Cannot create transaction from invalid match", exception.getMessage());
        } catch (IllegalArgumentException e) {
            // Expected - OrderMatch constructor should reject invalid matches
            assertTrue(e.getMessage().contains("must be >="));
        }
    }

    @Test
    @DisplayName("Should automatically update order statuses when both orders are fully filled")
    void shouldAutomaticallyUpdateOrderStatusesWhenBothOrdersFullyFilled() {
        // Given
        IBuyOrder buyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("50"));
        ISellOrder sellOrder = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("50"));
        OrderMatch match = new OrderMatch(buyOrder, sellOrder);

        // When - Creating transaction automatically updates orders via Order domain
        ITransaction transaction = transactionProcessor.createTransaction(match);

        // Then - Order domain automatically handled status transitions
        assertNotNull(transaction);
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
        assertEquals(BigDecimal.ZERO, buyOrder.getRemainingQuantity());
        assertEquals(BigDecimal.ZERO, sellOrder.getRemainingQuantity());
    }

    @Test
    @DisplayName("Should automatically update order statuses when buy order is partially filled")
    void shouldAutomaticallyUpdateOrderStatusesWhenBuyOrderPartiallyFilled() {
        // Given
        IBuyOrder buyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("100"));
        ISellOrder sellOrder = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("30"));
        OrderMatch match = new OrderMatch(buyOrder, sellOrder);

        // When - Creating transaction automatically updates orders via Order domain
        ITransaction transaction = transactionProcessor.createTransaction(match);

        // Then - Order domain automatically handled status transitions
        assertNotNull(transaction);
        assertEquals(OrderStatusEnum.PARTIAL, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, sellOrder.getStatus().getStatus());
        assertEquals(new BigDecimal("70"), buyOrder.getRemainingQuantity());
        assertEquals(BigDecimal.ZERO, sellOrder.getRemainingQuantity());
    }

    @Test
    @DisplayName("Should automatically update order statuses when sell order is partially filled")
    void shouldAutomaticallyUpdateOrderStatusesWhenSellOrderPartiallyFilled() {
        // Given
        IBuyOrder buyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("30"));
        ISellOrder sellOrder = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("100"));
        OrderMatch match = new OrderMatch(buyOrder, sellOrder);

        // When - Creating transaction automatically updates orders via Order domain
        ITransaction transaction = transactionProcessor.createTransaction(match);

        // Then - Order domain automatically handled status transitions
        assertNotNull(transaction);
        assertEquals(OrderStatusEnum.FILLED, buyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.PARTIAL, sellOrder.getStatus().getStatus());
        assertEquals(BigDecimal.ZERO, buyOrder.getRemainingQuantity());
        assertEquals(new BigDecimal("70"), sellOrder.getRemainingQuantity());
    }

    @Test
    @DisplayName("Should process multiple matches into transactions")
    void shouldProcessMultipleMatchesIntoTransactions() {
        // Given
        IBuyOrder buyOrder1 = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("50"));
        ISellOrder sellOrder1 = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("50"));
        OrderMatch match1 = new OrderMatch(buyOrder1, sellOrder1);

        IBuyOrder buyOrder2 = new BuyOrder("buy-2", testSymbol, testPrice, new BigDecimal("75"));
        ISellOrder sellOrder2 = new SellOrder("sell-2", testSymbol, testPrice, new BigDecimal("25"));
        OrderMatch match2 = new OrderMatch(buyOrder2, sellOrder2);

        List<OrderMatch> matches = Arrays.asList(match1, match2);

        // When
        List<ITransaction> transactions = transactionProcessor.processMatches(matches);

        // Then
        assertEquals(2, transactions.size());

        // Verify first transaction
        ITransaction tx1 = transactions.get(0);
        assertEquals(buyOrder1, tx1.getBuyOrder());
        assertEquals(sellOrder1, tx1.getSellOrder());
        assertEquals(new BigDecimal("50"), tx1.getQuantity());

        // Verify second transaction
        ITransaction tx2 = transactions.get(1);
        assertEquals(buyOrder2, tx2.getBuyOrder());
        assertEquals(sellOrder2, tx2.getSellOrder());
        assertEquals(new BigDecimal("25"), tx2.getQuantity());
    }

    @Test
    @DisplayName("Should filter out invalid matches when processing multiple matches")
    void shouldFilterOutInvalidMatchesWhenProcessingMultipleMatches() {
        // Given
        IBuyOrder validBuyOrder = new BuyOrder("buy-1", testSymbol, testPrice, new BigDecimal("50"));
        ISellOrder validSellOrder = new SellOrder("sell-1", testSymbol, testPrice, new BigDecimal("50"));
        OrderMatch validMatch = new OrderMatch(validBuyOrder, validSellOrder);

        List<OrderMatch> matches = Arrays.asList(validMatch);

        // When
        List<ITransaction> transactions = transactionProcessor.processMatches(matches);

        // Then
        assertEquals(1, transactions.size());
        assertEquals(validBuyOrder, transactions.get(0).getBuyOrder());
        assertEquals(validSellOrder, transactions.get(0).getSellOrder());
    }

    @Test
    @DisplayName("Should handle empty matches list")
    void shouldHandleEmptyMatchesList() {
        // Given
        List<OrderMatch> emptyMatches = Arrays.asList();

        // When
        List<ITransaction> transactions = transactionProcessor.processMatches(emptyMatches);

        // Then
        assertTrue(transactions.isEmpty());
    }

    @Test
    @DisplayName("Should create transactions that automatically update order quantities and statuses")
    void shouldCreateTransactionsThatAutomaticallyUpdateOrderQuantitiesAndStatuses() {
        // Given - Mixed scenario with different fill levels
        IBuyOrder largeBuyOrder = new BuyOrder("large-buy", testSymbol, testPrice, new BigDecimal("200"));
        ISellOrder smallSellOrder = new SellOrder("small-sell", testSymbol, testPrice, new BigDecimal("75"));
        OrderMatch partialMatch = new OrderMatch(largeBuyOrder, smallSellOrder);

        IBuyOrder exactBuyOrder = new BuyOrder("exact-buy", testSymbol, testPrice, new BigDecimal("50"));
        ISellOrder exactSellOrder = new SellOrder("exact-sell", testSymbol, testPrice, new BigDecimal("50"));
        OrderMatch exactMatch = new OrderMatch(exactBuyOrder, exactSellOrder);

        // When - Processing both matches
        ITransaction partialTransaction = transactionProcessor.createTransaction(partialMatch);
        ITransaction exactTransaction = transactionProcessor.createTransaction(exactMatch);

        // Then - Verify partial fill scenario
        assertNotNull(partialTransaction);
        assertEquals(new BigDecimal("75"), partialTransaction.getQuantity());
        assertEquals(OrderStatusEnum.PARTIAL, largeBuyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, smallSellOrder.getStatus().getStatus());
        assertEquals(new BigDecimal("125"), largeBuyOrder.getRemainingQuantity());
        assertEquals(BigDecimal.ZERO, smallSellOrder.getRemainingQuantity());

        // And - Verify exact fill scenario
        assertNotNull(exactTransaction);
        assertEquals(new BigDecimal("50"), exactTransaction.getQuantity());
        assertEquals(OrderStatusEnum.FILLED, exactBuyOrder.getStatus().getStatus());
        assertEquals(OrderStatusEnum.FILLED, exactSellOrder.getStatus().getStatus());
        assertEquals(BigDecimal.ZERO, exactBuyOrder.getRemainingQuantity());
        assertEquals(BigDecimal.ZERO, exactSellOrder.getRemainingQuantity());
    }
}=== ./market_engine/EventPublisherTest.java ===
package core.ms.market_engine;

import core.ms.market_engine.event.OrderAcceptedEvent;
import core.ms.market_engine.event.OrderExecutedEvent;
import core.ms.market_engine.event.TransactionCreatedEvent;
import core.ms.order.domain.entities.*;
import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;

class EventPublisherTest {

    private EventPublisher eventPublisher;
    private ByteArrayOutputStream outputCapture;
    private PrintStream originalOut;

    @BeforeEach
    void setUp() {
        eventPublisher = new EventPublisher();

        // Capture System.out for testing console output
        outputCapture = new ByteArrayOutputStream();
        originalOut = System.out;
        System.setOut(new PrintStream(outputCapture));
    }

    @BeforeEach
    void tearDown() {
        // Restore original System.out
        if (originalOut != null) {
            System.setOut(originalOut);
        }
    }

    @Test
    @DisplayName("Should publish order accepted event")
    void shouldPublishOrderAcceptedEvent() {
        // Given
        Symbol symbol = Symbol.eurUsd();
        Money price = Money.of("1.2000", Currency.USD);
        IBuyOrder order = new BuyOrder("order-123", symbol, price, new BigDecimal("100"));
        OrderAcceptedEvent event = new OrderAcceptedEvent(order, "engine-1");

        // When
        eventPublisher.publishOrderAccepted(event);

        // Then
        String output = outputCapture.toString();
        assertTrue(output.contains("ORDER_ACCEPTED"));
        assertTrue(output.contains("Order order-123 accepted"));
        assertTrue(output.contains("symbol EURUSD"));
    }

    @Test
    @DisplayName("Should publish transaction created event")
    void shouldPublishTransactionCreatedEvent() {
        // Given
        Symbol symbol = Symbol.eurUsd();
        Money price = Money.of("1.2000", Currency.USD);
        IBuyOrder buyOrder = new BuyOrder("buy-1", symbol, price, new BigDecimal("50"));
        ISellOrder sellOrder = new SellOrder("sell-1", symbol, price, new BigDecimal("50"));

        ITransaction transaction = new Transaction("tx-123", symbol, buyOrder, sellOrder, price, new BigDecimal("50"));
        TransactionCreatedEvent event = new TransactionCreatedEvent(transaction, "engine-1");

        // When
        eventPublisher.publishTransactionCreated(event);

        // Then
        String output = outputCapture.toString();
        assertTrue(output.contains("TRANSACTION_CREATED"));
        assertTrue(output.contains("Transaction tx-123 created"));
        assertTrue(output.contains("50 EURUSD"));
        assertTrue(output.contains("1.2000"));
    }

    @Test
    @DisplayName("Should publish order executed event")
    void shouldPublishOrderExecutedEvent() {
        // Given
        Money executionPrice = Money.of("1.2000", Currency.USD);
        OrderExecutedEvent event = new OrderExecutedEvent(
                "order-456",
                new BigDecimal("30"),
                new BigDecimal("20"),
                executionPrice,
                "engine-1"
        );

        // When
        eventPublisher.publishOrderExecuted(event);

        // Then
        String output = outputCapture.toString();
        assertTrue(output.contains("ORDER_EXECUTED"));
        assertTrue(output.contains("Order order-456 executed"));
        assertTrue(output.contains("30"));
        assertTrue(output.contains("1.2000"));
        assertTrue(output.contains("remaining: 20"));
    }

    @Test
    @DisplayName("Should throw exception when publishing null order accepted event")
    void shouldThrowExceptionWhenPublishingNullOrderAcceptedEvent() {
        // When & Then
        NullPointerException exception = assertThrows(
                NullPointerException.class,
                () -> eventPublisher.publishOrderAccepted(null)
        );
        assertEquals("Event cannot be null", exception.getMessage());
    }

    @Test
    @DisplayName("Should throw exception when publishing null transaction created event")
    void shouldThrowExceptionWhenPublishingNullTransactionCreatedEvent() {
        // When & Then
        NullPointerException exception = assertThrows(
                NullPointerException.class,
                () -> eventPublisher.publishTransactionCreated(null)
        );
        assertEquals("Event cannot be null", exception.getMessage());
    }

    @Test
    @DisplayName("Should throw exception when publishing null order executed event")
    void shouldThrowExceptionWhenPublishingNullOrderExecutedEvent() {
        // When & Then
        NullPointerException exception = assertThrows(
                NullPointerException.class,
                () -> eventPublisher.publishOrderExecuted(null)
        );
        assertEquals("Event cannot be null", exception.getMessage());
    }

    /*@Test
    @DisplayName("Should log events with timestamp")
    void shouldLogEventsWithTimestamp() {
        // Given
        Symbol symbol = Symbol.eurUsd();
        Money price = Money.of("1.2000", Currency.USD);
        IBuyOrder order = new BuyOrder("order-time", symbol, price, new BigDecimal("100"));
        OrderAcceptedEvent event = new OrderAcceptedEvent(order, "engine-1");

        // When
        eventPublisher.publishOrderAccepted(event);

        // Then
        String output = outputCapture.toString();
        assertTrue(output.matches(".*\\[\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?\\].*"));
    }*/

    @Test
    @DisplayName("Should handle multiple event publications")
    void shouldHandleMultipleEventPublications() {
        // Given
        Symbol symbol = Symbol.eurUsd();
        Money price = Money.of("1.2000", Currency.USD);

        IBuyOrder order1 = new BuyOrder("order-1", symbol, price, new BigDecimal("100"));
        IBuyOrder order2 = new BuyOrder("order-2", symbol, price, new BigDecimal("200"));

        OrderAcceptedEvent event1 = new OrderAcceptedEvent(order1, "engine-1");
        OrderAcceptedEvent event2 = new OrderAcceptedEvent(order2, "engine-1");

        // When
        eventPublisher.publishOrderAccepted(event1);
        eventPublisher.publishOrderAccepted(event2);

        // Then
        String output = outputCapture.toString();
        assertTrue(output.contains("order-1"));
        assertTrue(output.contains("order-2"));

        // Count occurrences of ORDER_ACCEPTED
        long acceptedCount = output.lines()
                .filter(line -> line.contains("ORDER_ACCEPTED"))
                .count();
        assertEquals(2, acceptedCount);
    }

    @Test
    @DisplayName("Should handle order executed event with zero remaining quantity")
    void shouldHandleOrderExecutedEventWithZeroRemainingQuantity() {
        // Given
        Money executionPrice = Money.of("1.2000", Currency.USD);
        OrderExecutedEvent event = new OrderExecutedEvent(
                "fully-filled-order",
                new BigDecimal("100"),
                BigDecimal.ZERO,
                executionPrice,
                "engine-1"
        );

        // When
        eventPublisher.publishOrderExecuted(event);

        // Then
        String output = outputCapture.toString();
        assertTrue(output.contains("fully-filled-order"));
        assertTrue(output.contains("remaining: 0"));
    }

    @Test
    @DisplayName("Should handle transaction with different currencies")
    void shouldHandleTransactionWithDifferentCurrencies() {
        // Given
        Symbol btcSymbol = Symbol.btcUsd();
        Money btcPrice = Money.of("50000.00", Currency.USD);
        IBuyOrder buyOrder = new BuyOrder("btc-buy", btcSymbol, btcPrice, new BigDecimal("0.5"));
        ISellOrder sellOrder = new SellOrder("btc-sell", btcSymbol, btcPrice, new BigDecimal("0.5"));

        ITransaction transaction = new Transaction("btc-tx", btcSymbol, buyOrder, sellOrder, btcPrice, new BigDecimal("0.5"));
        TransactionCreatedEvent event = new TransactionCreatedEvent(transaction, "engine-1");

        // When
        eventPublisher.publishTransactionCreated(event);

        // Then
        String output = outputCapture.toString();
        assertTrue(output.contains("0.5 BTC"));
        assertTrue(output.contains("50000.00"));
    }
}=== ./market_engine/OrderResultTest.java ===
package core.ms.market_engine;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class OrderResultTest {

    @Test
    @DisplayName("Should create accepted order result")
    void shouldCreateAcceptedOrderResult() {
        // When
        OrderResult result = OrderResult.accepted("order-123");

        // Then
        assertEquals("order-123", result.getOrderId());
        assertTrue(result.isSuccess());
        assertEquals("Order accepted", result.getMessage());
        assertTrue(result.getTransactionIds().isEmpty());
        assertNotNull(result.getTimestamp());
    }

    @Test
    @DisplayName("Should create accepted order result with transactions")
    void shouldCreateAcceptedOrderResultWithTransactions() {
        // Given
        List<String> transactionIds = Arrays.asList("tx-1", "tx-2", "tx-3");

        // When
        OrderResult result = OrderResult.acceptedWithTransactions("order-456", transactionIds);

        // Then
        assertEquals("order-456", result.getOrderId());
        assertTrue(result.isSuccess());
        assertEquals("Order accepted and executed", result.getMessage());
        assertEquals(3, result.getTransactionIds().size());
        assertEquals("tx-1", result.getTransactionIds().get(0));
        assertEquals("tx-2", result.getTransactionIds().get(1));
        assertEquals("tx-3", result.getTransactionIds().get(2));
        assertNotNull(result.getTimestamp());
    }

    @Test
    @DisplayName("Should create rejected order result")
    void shouldCreateRejectedOrderResult() {
        // When
        OrderResult result = OrderResult.rejected("order-789", "Insufficient funds");

        // Then
        assertEquals("order-789", result.getOrderId());
        assertFalse(result.isSuccess());
        assertEquals("Insufficient funds", result.getMessage());
        assertTrue(result.getTransactionIds().isEmpty());
        assertNotNull(result.getTimestamp());
    }

    @Test
    @DisplayName("Should handle null transaction list in acceptedWithTransactions")
    void shouldHandleNullTransactionListInAcceptedWithTransactions() {
        // When
        OrderResult result = OrderResult.acceptedWithTransactions("order-null", null);

        // Then
        assertEquals("order-null", result.getOrderId());
        assertTrue(result.isSuccess());
        assertEquals("Order accepted and executed", result.getMessage());
        assertTrue(result.getTransactionIds().isEmpty());
        assertNotNull(result.getTimestamp());
    }

    @Test
    @DisplayName("Should return defensive copy of transaction IDs")
    void shouldReturnDefensiveCopyOfTransactionIds() {
        // Given
        List<String> originalIds = Arrays.asList("tx-1", "tx-2");
        OrderResult result = OrderResult.acceptedWithTransactions("order-copy", originalIds);

        // When
        List<String> returnedIds = result.getTransactionIds();
        returnedIds.add("tx-3"); // Try to modify returned list

        // Then
        assertEquals(2, result.getTransactionIds().size()); // Original should be unchanged
        assertNotSame(originalIds, result.getTransactionIds()); // Should be different instances
    }

    @Test
    @DisplayName("Should throw exception when creating result with null order ID")
    void shouldThrowExceptionWhenCreatingResultWithNullOrderId() {
        // When & Then
        assertThrows(
                NullPointerException.class,
                () -> new OrderResult(null, true, "Success", Arrays.asList())
        );
    }

    @Test
    @DisplayName("Should throw exception when creating result with null message")
    void shouldThrowExceptionWhenCreatingResultWithNullMessage() {
        // When & Then
        assertThrows(
                NullPointerException.class,
                () -> new OrderResult("order-1", true, null, Arrays.asList())
        );
    }

    @Test
    @DisplayName("Should throw exception in factory methods with null order ID")
    void shouldThrowExceptionInFactoryMethodsWithNullOrderId() {
        // When & Then
        assertThrows(
                NullPointerException.class,
                () -> OrderResult.accepted(null)
        );

        assertThrows(
                NullPointerException.class,
                () -> OrderResult.acceptedWithTransactions(null, Arrays.asList("tx-1"))
        );

        assertThrows(
                NullPointerException.class,
                () -> OrderResult.rejected(null, "Some reason")
        );
    }

    @Test
    @DisplayName("Should have proper toString representation")
    void shouldHaveProperToStringRepresentation() {
        // Given
        List<String> transactionIds = Arrays.asList("tx-1", "tx-2");
        OrderResult result = OrderResult.acceptedWithTransactions("order-display", transactionIds);

        // When
        String toString = result.toString();

        // Then
        assertTrue(toString.contains("order-display"));
        assertTrue(toString.contains("success=true"));
        assertTrue(toString.contains("Order accepted and executed"));
        assertTrue(toString.contains("transactionIds=2"));
    }

    @Test
    @DisplayName("Should handle empty transaction list")
    void shouldHandleEmptyTransactionList() {
        // Given
        List<String> emptyList = Arrays.asList();

        // When
        OrderResult result = OrderResult.acceptedWithTransactions("order-empty", emptyList);

        // Then
        assertEquals("order-empty", result.getOrderId());
        assertTrue(result.isSuccess());
        assertTrue(result.getTransactionIds().isEmpty());
    }

    @Test
    @DisplayName("Should create result with custom constructor")
    void shouldCreateResultWithCustomConstructor() {
        // Given
        List<String> customTransactions = Arrays.asList("custom-tx-1");

        // When
        OrderResult result = new OrderResult("custom-order", false, "Custom failure reason", customTransactions);

        // Then
        assertEquals("custom-order", result.getOrderId());
        assertFalse(result.isSuccess());
        assertEquals("Custom failure reason", result.getMessage());
        assertEquals(1, result.getTransactionIds().size());
        assertEquals("custom-tx-1", result.getTransactionIds().get(0));
        assertNotNull(result.getTimestamp());
    }
}=== ./shared/domain/CurrencyTest.java ===
package core.ms.shared.domain;

public class CurrencyTest {
}
=== ./shared/domain/AssetTypeTest.java ===
package core.ms.shared.domain;

public class AssetTypeTest {
}
=== ./shared/domain/SymbolTest.java ===
package core.ms.shared.domain;

public class SymbolTest {
}
=== ./shared/domain/MoneyTest.java ===
package core.ms.shared.domain;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Money Value Object Tests")
class MoneyTest {

    @Nested
    @DisplayName("Construction Tests")
    class ConstructionTests {

        @Test
        @DisplayName("Should create money with BigDecimal amount")
        void shouldCreateMoneyWithBigDecimal() {
            // Given
            BigDecimal amount = new BigDecimal("100.50");
            Currency currency = Currency.USD;

            // When
            Money money = new Money(amount, currency);

            // Then
            assertEquals(amount, money.getAmount());
            assertEquals(currency, money.getCurrency());
        }

        @Test
        @DisplayName("Should create money with String amount")
        void shouldCreateMoneyWithString() {
            // Given
            String amount = "100.50";
            Currency currency = Currency.USD;

            // When
            Money money = new Money(amount, currency);

            // Then
            assertEquals(new BigDecimal("100.50"), money.getAmount());
            assertEquals(currency, money.getCurrency());
        }

        @Test
        @DisplayName("Should preserve full precision without rounding")
        void shouldPreserveFullPrecision() {
            // Given
            String highPrecisionAmount = "123.123456789012345";
            Currency currency = Currency.USD;

            // When
            Money money = new Money(highPrecisionAmount, currency);

            // Then
            assertEquals(new BigDecimal("123.123456789012345"), money.getAmount());
        }

        @Test
        @DisplayName("Should throw exception for null amount")
        void shouldThrowExceptionForNullAmount() {
            // Given
            BigDecimal amount = null;
            Currency currency = Currency.USD;

            // When & Then
            IllegalArgumentException exception = assertThrows(
                    IllegalArgumentException.class,
                    () -> new Money(amount, currency)
            );
            assertEquals("Amount cannot be null", exception.getMessage());
        }

        @Test
        @DisplayName("Should throw exception for null currency")
        void shouldThrowExceptionForNullCurrency() {
            // Given
            BigDecimal amount = new BigDecimal("100");
            Currency currency = null;

            // When & Then
            IllegalArgumentException exception = assertThrows(
                    IllegalArgumentException.class,
                    () -> new Money(amount, currency)
            );
            assertEquals("Currency cannot be null", exception.getMessage());
        }
    }

    @Nested
    @DisplayName("Arithmetic Operations Tests")
    class ArithmeticOperationsTests {

        @Test
        @DisplayName("Should add money with same currency")
        void shouldAddMoneyWithSameCurrency() {
            // Given
            Money money1 = new Money("100.50", Currency.USD);
            Money money2 = new Money("50.25", Currency.USD);

            // When
            Money result = money1.add(money2);

            // Then
            assertEquals(new BigDecimal("150.75"), result.getAmount());
            assertEquals(Currency.USD, result.getCurrency());
        }

        @Test
        @DisplayName("Should subtract money with same currency")
        void shouldSubtractMoneyWithSameCurrency() {
            // Given
            Money money1 = new Money("100.50", Currency.USD);
            Money money2 = new Money("50.25", Currency.USD);

            // When
            Money result = money1.subtract(money2);

            // Then
            assertEquals(new BigDecimal("50.25"), result.getAmount());
            assertEquals(Currency.USD, result.getCurrency());
        }

        @Test
        @DisplayName("Should multiply money by BigDecimal scalar")
        void shouldMultiplyByBigDecimalScalar() {
            // Given
            Money money = new Money("100.00", Currency.USD);
            BigDecimal scalar = new BigDecimal("2.5");

            // When
            Money result = money.multiply(scalar);

            // Then
            assertEquals(new BigDecimal("250.00"), result.getAmount());
            assertEquals(Currency.USD, result.getCurrency());
        }

        @Test
        @DisplayName("Should multiply money by double scalar")
        void shouldMultiplyByDoubleScalar() {
            // Given
            Money money = new Money("100.00", Currency.USD);
            double scalar = 2.5;

            // When
            Money result = money.multiply(scalar);

            // Then
            assertEquals(new BigDecimal("250.00"), result.getAmount());
            assertEquals(Currency.USD, result.getCurrency());
        }

        @Test
        @DisplayName("Should divide money by BigDecimal")
        void shouldDivideByBigDecimal() {
            // Given
            Money money = new Money("100.00", Currency.USD);
            BigDecimal divisor = new BigDecimal("4");

            // When
            Money result = money.divide(divisor);

            // Then
            assertEquals(new BigDecimal("25.00"), result.getAmount());
            assertEquals(Currency.USD, result.getCurrency());
        }

        @Test
        @DisplayName("Should negate money amount")
        void shouldNegateMoneyAmount() {
            // Given
            Money money = new Money("100.50", Currency.USD);

            // When
            Money result = money.negate();

            // Then
            assertEquals(new BigDecimal("-100.50"), result.getAmount());
            assertEquals(Currency.USD, result.getCurrency());
        }

        @Test
        @DisplayName("Should throw exception when adding different currencies")
        void shouldThrowExceptionWhenAddingDifferentCurrencies() {
            // Given
            Money usdMoney = new Money("100.00", Currency.USD);
            Money eurMoney = new Money("100.00", Currency.EUR);

            // When & Then
            IllegalArgumentException exception = assertThrows(
                    IllegalArgumentException.class,
                    () -> usdMoney.add(eurMoney)
            );
            assertTrue(exception.getMessage().contains("Cannot operate on different currencies"));
        }

        @Test
        @DisplayName("Should throw exception when dividing by zero")
        void shouldThrowExceptionWhenDividingByZero() {
            // Given
            Money money = new Money("100.00", Currency.USD);
            BigDecimal zero = BigDecimal.ZERO;

            // When & Then
            IllegalArgumentException exception = assertThrows(
                    IllegalArgumentException.class,
                    () -> money.divide(zero)
            );
            assertEquals("Cannot divide by zero", exception.getMessage());
        }
    }

    @Nested
    @DisplayName("Comparison Operations Tests")
    class ComparisonOperationsTests {

        @Test
        @DisplayName("Should correctly compare greater than")
        void shouldCorrectlyCompareGreaterThan() {
            // Given
            Money money1 = new Money("100.00", Currency.USD);
            Money money2 = new Money("50.00", Currency.USD);

            // When & Then
            assertTrue(money1.isGreaterThan(money2));
            assertFalse(money2.isGreaterThan(money1));
        }

        @Test
        @DisplayName("Should correctly compare less than")
        void shouldCorrectlyCompareLessThan() {
            // Given
            Money money1 = new Money("50.00", Currency.USD);
            Money money2 = new Money("100.00", Currency.USD);

            // When & Then
            assertTrue(money1.isLessThan(money2));
            assertFalse(money2.isLessThan(money1));
        }

        @Test
        @DisplayName("Should correctly identify zero amount")
        void shouldCorrectlyIdentifyZeroAmount() {
            // Given
            Money zeroMoney = new Money("0.00", Currency.USD);
            Money nonZeroMoney = new Money("1.00", Currency.USD);

            // When & Then
            assertTrue(zeroMoney.isZero());
            assertFalse(nonZeroMoney.isZero());
        }

        @Test
        @DisplayName("Should correctly identify positive amount")
        void shouldCorrectlyIdentifyPositiveAmount() {
            // Given
            Money positiveMoney = new Money("100.00", Currency.USD);
            Money negativeMoney = new Money("-100.00", Currency.USD);
            Money zeroMoney = new Money("0.00", Currency.USD);

            // When & Then
            assertTrue(positiveMoney.isPositive());
            assertFalse(negativeMoney.isPositive());
            assertFalse(zeroMoney.isPositive());
        }

        @Test
        @DisplayName("Should correctly identify negative amount")
        void shouldCorrectlyIdentifyNegativeAmount() {
            // Given
            Money positiveMoney = new Money("100.00", Currency.USD);
            Money negativeMoney = new Money("-100.00", Currency.USD);
            Money zeroMoney = new Money("0.00", Currency.USD);

            // When & Then
            assertFalse(positiveMoney.isNegative());
            assertTrue(negativeMoney.isNegative());
            assertFalse(zeroMoney.isNegative());
        }
    }

    @Nested
    @DisplayName("Factory Methods Tests")
    class FactoryMethodsTests {

        @Test
        @DisplayName("Should create zero money")
        void shouldCreateZeroMoney() {
            // When
            Money zeroUsd = Money.zero(Currency.USD);

            // Then
            assertTrue(zeroUsd.isZero());
            assertEquals(Currency.USD, zeroUsd.getCurrency());
        }

        @Test
        @DisplayName("Should create money using of() factory with string")
        void shouldCreateMoneyUsingOfFactoryWithString() {
            // When
            Money money = Money.of("123.45", Currency.EUR);

            // Then
            assertEquals(new BigDecimal("123.45"), money.getAmount());
            assertEquals(Currency.EUR, money.getCurrency());
        }

        @Test
        @DisplayName("Should create USD money using convenience method")
        void shouldCreateUsdMoneyUsingConvenienceMethod() {
            // When
            Money money = Money.usd("100.50");

            // Then
            assertEquals(new BigDecimal("100.50"), money.getAmount());
            assertEquals(Currency.USD, money.getCurrency());
        }

        @Test
        @DisplayName("Should create EUR money using convenience method")
        void shouldCreateEurMoneyUsingConvenienceMethod() {
            // When
            Money money = Money.eur("200.75");

            // Then
            assertEquals(new BigDecimal("200.75"), money.getAmount());
            assertEquals(Currency.EUR, money.getCurrency());
        }
    }

    @Nested
    @DisplayName("Formatting Tests")
    class FormattingTests {

        @Test
        @DisplayName("Should format USD for display with 2 decimal places")
        void shouldFormatUsdForDisplay() {
            // Given
            Money money = new Money("123.456789", Currency.USD);

            // When
            String displayString = money.toDisplayString();

            // Then
            assertEquals("$123.46", displayString);
        }

        @Test
        @DisplayName("Should format JPY for display with 0 decimal places")
        void shouldFormatJpyForDisplay() {
            // Given
            Money money = new Money("123.456789", Currency.JPY);

            // When
            String displayString = money.toDisplayString();

            // Then
            assertEquals("¥123", displayString);
        }

        @Test
        @DisplayName("Should format BTC for display with 8 decimal places")
        void shouldFormatBtcForDisplay() {
            // Given
            Money money = new Money("1.123456789012345", Currency.BTC);

            // When
            String displayString = money.toDisplayString();

            // Then
            assertEquals("₿1.12345679", displayString);
        }

        @Test
        @DisplayName("Should create plain string representation")
        void shouldCreatePlainStringRepresentation() {
            // Given
            Money money = new Money("123.456789", Currency.USD);

            // When
            String plainString = money.toPlainString();

            // Then
            assertEquals("123.456789 USD", plainString);
        }
    }

    @Nested
    @DisplayName("Equals and HashCode Tests")
    class EqualsAndHashCodeTests {

        @Test
        @DisplayName("Should be equal when amount and currency are same")
        void shouldBeEqualWhenAmountAndCurrencyAreSame() {
            // Given
            Money money1 = new Money("100.00", Currency.USD);
            Money money2 = new Money("100.00", Currency.USD);

            // When & Then
            assertEquals(money1, money2);
            assertEquals(money1.hashCode(), money2.hashCode());
        }

        @Test
        @DisplayName("Should not be equal when amounts differ")
        void shouldNotBeEqualWhenAmountsDiffer() {
            // Given
            Money money1 = new Money("100.00", Currency.USD);
            Money money2 = new Money("200.00", Currency.USD);

            // When & Then
            assertNotEquals(money1, money2);
        }

        @Test
        @DisplayName("Should not be equal when currencies differ")
        void shouldNotBeEqualWhenCurrenciesDiffer() {
            // Given
            Money money1 = new Money("100.00", Currency.USD);
            Money money2 = new Money("100.00", Currency.EUR);

            // When & Then
            assertNotEquals(money1, money2);
        }

        @Test
        @DisplayName("Should not be equal to null")
        void shouldNotBeEqualToNull() {
            // Given
            Money money = new Money("100.00", Currency.USD);

            // When & Then
            assertNotEquals(money, null);
        }

        @Test
        @DisplayName("Should not be equal to different type")
        void shouldNotBeEqualToDifferentType() {
            // Given
            Money money = new Money("100.00", Currency.USD);
            String notMoney = "100.00 USD";

            // When & Then
            assertNotEquals(money, notMoney);
        }
        @Test
        @DisplayName("Should handle BigDecimal scale differences in Money equals")
        void shouldHandleBigDecimalScaleDifferencesInMoneyEquals() {
            Money money1 = Money.of("45000", Currency.USD);     // scale 0
            Money money2 = Money.of("45000.0", Currency.USD);   // scale 1
            Money money3 = Money.of("45000.00", Currency.USD);  // scale 2

            // All should be equal despite different scales
            assertEquals(money1, money2);
            assertEquals(money2, money3);
            assertEquals(money1, money3);

            // Hash codes should also be equal
            assertEquals(money1.hashCode(), money2.hashCode());
            assertEquals(money2.hashCode(), money3.hashCode());
        }
    }
}=== ./TestcontainersConfiguration.java ===
package core.ms;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.springframework.context.annotation.Bean;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.kafka.KafkaContainer;
import org.testcontainers.utility.DockerImageName;

@TestConfiguration(proxyBeanMethods = false)
class TestcontainersConfiguration {

    @Bean
    @ServiceConnection
    KafkaContainer kafkaContainer() {
        return new KafkaContainer(DockerImageName.parse("apache/kafka-native:latest"));
    }

    @Bean
    @ServiceConnection
    PostgreSQLContainer<?> postgresContainer() {
        return new PostgreSQLContainer<>(DockerImageName.parse("postgres:latest"));
    }

    @Bean
    @ServiceConnection(name = "redis")
    GenericContainer<?> redisContainer() {
        return new GenericContainer<>(DockerImageName.parse("redis:latest")).withExposedPorts(6379);
    }

}
=== ./TestMsApplication.java ===
package core.ms;

import org.springframework.boot.SpringApplication;

public class TestMsApplication {

    public static void main(String[] args) {
        SpringApplication.from(MsApplication::main).with(TestcontainersConfiguration.class).run(args);
    }

}
=== ./MsApplicationTests.java ===
package core.ms;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

@Import(TestcontainersConfiguration.class)
@SpringBootTest
class MsApplicationTests {

    @Test
    void contextLoads() {
    }

}
=== ./OHLC/domain/OHLCDataAndFactoryTest.java ===
package core.ms.OHLC.domain;

import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("OHLCData and Factory Tests")
class OHLCDataAndFactoryTest {

    private Symbol btcUsd;
    private TimeInterval oneMinute;
    private Instant baseTimestamp;
    private OHLCData ohlcData;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
        oneMinute = TimeInterval.ONE_MINUTE;
        baseTimestamp = Instant.parse("2024-01-01T12:00:00Z");
        ohlcData = new OHLCData("ohlc-1", btcUsd, oneMinute);
    }

    @Nested
    @DisplayName("OHLCData Aggregate Tests")
    class OHLCDataAggregateTests {

        @Test
        @DisplayName("Should create OHLCData from transactions in single interval")
        void shouldCreateOHLCDataFromTransactionsInSingleInterval() {
            // All transactions within the same 1-minute interval
            List<TransactionData> transactions = Arrays.asList(
                    new TransactionData(baseTimestamp, Money.of("50000.00", Currency.USD), new BigDecimal("0.5"), btcUsd),
                    new TransactionData(baseTimestamp.plus(15, ChronoUnit.SECONDS), Money.of("51000.00", Currency.USD), new BigDecimal("0.3"), btcUsd),
                    new TransactionData(baseTimestamp.plus(45, ChronoUnit.SECONDS), Money.of("50500.00", Currency.USD), new BigDecimal("0.7"), btcUsd)
            );

            OHLCData result = OHLCDataFactory.createFromTransactions(btcUsd, oneMinute, transactions);

            assertNotNull(result);
            assertEquals(btcUsd, result.getSymbol());
            assertEquals(oneMinute, result.getInterval());
            assertEquals(1, result.size()); // All transactions in same interval

            Candlestick candle = result.getAllCandles().get(0);
            assertEquals(Money.of("50000.00", Currency.USD), candle.getOpen()); // First transaction price
            assertEquals(Money.of("50500.00", Currency.USD), candle.getClose()); // Last transaction price
            assertEquals(Money.of("51000.00", Currency.USD), candle.getHigh()); // Highest price
            assertEquals(Money.of("50000.00", Currency.USD), candle.getLow()); // Lowest price
            assertEquals(0, new BigDecimal("1.5").compareTo(candle.getVolume())); // Sum of volumes
        }

        @Test
        @DisplayName("Should create OHLCData successfully")
        void shouldCreateOHLCDataSuccessfully() {
            assertEquals("ohlc-1", ohlcData.getId());
            assertEquals(btcUsd, ohlcData.getSymbol());
            assertEquals(oneMinute, ohlcData.getInterval());
            assertTrue(ohlcData.isEmpty());
            assertEquals(0, ohlcData.size());
            assertNotNull(ohlcData.getLastUpdated());
        }

        @Test
        @DisplayName("Should throw exception for null required fields")
        void shouldThrowExceptionForNullRequiredFields() {
            assertThrows(NullPointerException.class, () ->
                    new OHLCData(null, btcUsd, oneMinute));

            assertThrows(NullPointerException.class, () ->
                    new OHLCData("ohlc-1", null, oneMinute));

            assertThrows(NullPointerException.class, () ->
                    new OHLCData("ohlc-1", btcUsd, null));
        }

        @Test
        @DisplayName("Should add candlesticks successfully")
        void shouldAddCandlesticksSuccessfully() {
            Candlestick candle1 = createTestCandlestick("candle-1", baseTimestamp);
            Candlestick candle2 = createTestCandlestick("candle-2", baseTimestamp.plus(1, ChronoUnit.MINUTES));

            ohlcData.addCandle(candle1);
            ohlcData.addCandle(candle2);

            assertFalse(ohlcData.isEmpty());
            assertEquals(2, ohlcData.size());

            List<Candlestick> candles = ohlcData.getAllCandles();
            assertEquals(2, candles.size());
            // Should be sorted by timestamp
            assertEquals(candle1.getId(), candles.get(0).getId());
            assertEquals(candle2.getId(), candles.get(1).getId());
        }

        @Test
        @DisplayName("Should validate candlestick constraints")
        void shouldValidateCandlestickConstraints() {
            Symbol ethUsd = Symbol.ethUsd();
            Candlestick wrongSymbol = new Candlestick(
                    "candle-1", ethUsd, baseTimestamp, oneMinute,
                    Money.of("3000.00", Currency.USD), Money.of("3100.00", Currency.USD),
                    Money.of("2950.00", Currency.USD), Money.of("3050.00", Currency.USD),
                    new BigDecimal("2.0")
            );

            assertThrows(IllegalArgumentException.class, () ->
                    ohlcData.addCandle(wrongSymbol));

            TimeInterval fiveMinutes = TimeInterval.FIVE_MINUTES;
            Candlestick wrongInterval = new Candlestick(
                    "candle-2", btcUsd, baseTimestamp, fiveMinutes,
                    Money.of("50000.00", Currency.USD), Money.of("51000.00", Currency.USD),
                    Money.of("49500.00", Currency.USD), Money.of("50500.00", Currency.USD),
                    new BigDecimal("1.0")
            );

            assertThrows(IllegalArgumentException.class, () ->
                    ohlcData.addCandle(wrongInterval));
        }

        @Test
        @DisplayName("Should get candlesticks by time range")
        void shouldGetCandlesticksByTimeRange() {
            Candlestick candle1 = createTestCandlestick("candle-1", baseTimestamp);
            Candlestick candle2 = createTestCandlestick("candle-2", baseTimestamp.plus(5, ChronoUnit.MINUTES));
            Candlestick candle3 = createTestCandlestick("candle-3", baseTimestamp.plus(10, ChronoUnit.MINUTES));

            ohlcData.addCandle(candle1);
            ohlcData.addCandle(candle2);
            ohlcData.addCandle(candle3);

            Instant startTime = baseTimestamp.plus(2, ChronoUnit.MINUTES);
            Instant endTime = baseTimestamp.plus(8, ChronoUnit.MINUTES);

            List<Candlestick> filteredCandles = ohlcData.getCandlesByTimeRange(startTime, endTime);

            assertEquals(1, filteredCandles.size());
            assertEquals("candle-2", filteredCandles.get(0).getId());
        }

        @Test
        @DisplayName("Should validate time range parameters")
        void shouldValidateTimeRangeParameters() {
            Instant startTime = baseTimestamp.plus(1, ChronoUnit.HOURS);
            Instant endTime = baseTimestamp;

            assertThrows(IllegalArgumentException.class, () ->
                    ohlcData.getCandlesByTimeRange(startTime, endTime));
        }

        @Test
        @DisplayName("Should get latest candlestick")
        void shouldGetLatestCandlestick() {
            assertTrue(ohlcData.getLatestCandle().isEmpty());

            Candlestick candle1 = createTestCandlestick("candle-1", baseTimestamp);
            Candlestick candle2 = createTestCandlestick("candle-2", baseTimestamp.plus(5, ChronoUnit.MINUTES));

            ohlcData.addCandle(candle1);
            ohlcData.addCandle(candle2);

            Optional<Candlestick> latest = ohlcData.getLatestCandle();
            assertTrue(latest.isPresent());
            assertEquals("candle-2", latest.get().getId());
        }

        @Test
        @DisplayName("Should calculate price statistics")
        void shouldCalculatePriceStatistics() {
            Candlestick candle1 = createCandlestickWithPrices("candle-1", baseTimestamp,
                    "50000", "52000", "49000", "51000");
            Candlestick candle2 = createCandlestickWithPrices("candle-2", baseTimestamp.plus(1, ChronoUnit.MINUTES),
                    "51000", "53000", "50500", "52500");

            ohlcData.addCandle(candle1);
            ohlcData.addCandle(candle2);

            Optional<Money> highest = ohlcData.getHighestPrice();
            Optional<Money> lowest = ohlcData.getLowestPrice();

            assertTrue(highest.isPresent());
            assertTrue(lowest.isPresent());
            assertEquals(Money.of("53000.00", Currency.USD), highest.get());
            assertEquals(Money.of("49000.00", Currency.USD), lowest.get());
        }

        @Test
        @DisplayName("Should calculate average volume")
        void shouldCalculateAverageVolume() {
            assertTrue(ohlcData.getAverageVolume().compareTo(BigDecimal.ZERO) == 0);

            Candlestick candle1 = createCandlestickWithVolume("candle-1", baseTimestamp, "2.0");
            Candlestick candle2 = createCandlestickWithVolume("candle-2", baseTimestamp.plus(1, ChronoUnit.MINUTES), "4.0");

            ohlcData.addCandle(candle1);
            ohlcData.addCandle(candle2);

            BigDecimal averageVolume = ohlcData.getAverageVolume();
            assertEquals(0, new BigDecimal("3.00").compareTo(averageVolume));
        }

        @Test
        @DisplayName("Should get date range")
        void shouldGetDateRange() {
            assertTrue(ohlcData.getDateRange().isEmpty());

            Candlestick candle1 = createTestCandlestick("candle-1", baseTimestamp);
            Candlestick candle2 = createTestCandlestick("candle-2", baseTimestamp.plus(10, ChronoUnit.MINUTES));

            ohlcData.addCandle(candle1);
            ohlcData.addCandle(candle2);

            Optional<DateRange> dateRange = ohlcData.getDateRange();
            assertTrue(dateRange.isPresent());
            assertEquals(baseTimestamp, dateRange.get().getStart());
            assertEquals(baseTimestamp.plus(10, ChronoUnit.MINUTES), dateRange.get().getEnd());
        }

        @Test
        @DisplayName("Should convert to chart series")
        void shouldConvertToChartSeries() {
            Candlestick candle1 = createTestCandlestick("candle-1", baseTimestamp);
            Candlestick candle2 = createTestCandlestick("candle-2", baseTimestamp.plus(1, ChronoUnit.MINUTES));

            ohlcData.addCandle(candle1);
            ohlcData.addCandle(candle2);

            ChartSeries series = ohlcData.toChartSeries();

            assertEquals("ohlc-1", series.getId());
            assertEquals("BTC 1m", series.getName());
            assertEquals("BTC", series.getSymbol());
            assertEquals("1m", series.getInterval());
            assertEquals(2, series.getData().size());
            assertFalse(series.isEmpty());
        }

        @Test
        @DisplayName("Should have proper string representation")
        void shouldHaveProperStringRepresentation() {
            String result = ohlcData.toString();
            assertTrue(result.contains("ohlc-1"));
            assertTrue(result.contains("BTC"));
            assertTrue(result.contains("1m"));
            assertTrue(result.contains("0 candlesticks"));
        }
    }

    @Nested
    @DisplayName("OHLCDataFactory Tests")
    class OHLCDataFactoryTests {

        @Test
        @DisplayName("Should create OHLCData from transactions")
        void shouldCreateOHLCDataFromTransactions() {
            List<TransactionData> transactions = Arrays.asList(
                    new TransactionData(baseTimestamp, Money.of("50000.00", Currency.USD), new BigDecimal("0.5"), btcUsd),
                    new TransactionData(baseTimestamp.plus(30, ChronoUnit.SECONDS), Money.of("51000.00", Currency.USD), new BigDecimal("0.3"), btcUsd),
                    new TransactionData(baseTimestamp.plus(90, ChronoUnit.SECONDS), Money.of("50500.00", Currency.USD), new BigDecimal("0.7"), btcUsd)
            );

            OHLCData result = OHLCDataFactory.createFromTransactions(btcUsd, oneMinute, transactions);

            assertNotNull(result);
            assertEquals(btcUsd, result.getSymbol());
            assertEquals(oneMinute, result.getInterval());
            assertEquals(2, result.size()); // Transactions span 2 intervals: 12:00:00 and 12:01:00

            List<Candlestick> candles = result.getAllCandles();

            // First candlestick (12:00:00 interval) - 2 transactions
            Candlestick candle1 = candles.get(0);
            assertEquals(Money.of("50000.00", Currency.USD), candle1.getOpen()); // First transaction
            assertEquals(Money.of("51000.00", Currency.USD), candle1.getClose()); // Last transaction in interval
            assertEquals(Money.of("51000.00", Currency.USD), candle1.getHigh()); // Highest in interval
            assertEquals(Money.of("50000.00", Currency.USD), candle1.getLow()); // Lowest in interval
            assertEquals(0, new BigDecimal("0.8").compareTo(candle1.getVolume())); // 0.5 + 0.3

            // Second candlestick (12:01:00 interval) - 1 transaction
            Candlestick candle2 = candles.get(1);
            assertEquals(Money.of("50500.00", Currency.USD), candle2.getOpen()); // Only transaction
            assertEquals(Money.of("50500.00", Currency.USD), candle2.getClose()); // Same transaction
            assertEquals(Money.of("50500.00", Currency.USD), candle2.getHigh()); // Same transaction
            assertEquals(Money.of("50500.00", Currency.USD), candle2.getLow()); // Same transaction
            assertEquals(0, new BigDecimal("0.7").compareTo(candle2.getVolume())); // Only volume
        }

        @Test
        @DisplayName("Should create candlestick from transactions")
        void shouldCreateCandlestickFromTransactions() {
            List<TransactionData> transactions = Arrays.asList(
                    new TransactionData(baseTimestamp, Money.of("50000.00", Currency.USD), new BigDecimal("0.5"), btcUsd),
                    new TransactionData(baseTimestamp.plus(15, ChronoUnit.SECONDS), Money.of("51500.00", Currency.USD), new BigDecimal("0.3"), btcUsd),
                    new TransactionData(baseTimestamp.plus(45, ChronoUnit.SECONDS), Money.of("49500.00", Currency.USD), new BigDecimal("0.2"), btcUsd),
                    new TransactionData(baseTimestamp.plus(50, ChronoUnit.SECONDS), Money.of("50500.00", Currency.USD), new BigDecimal("0.4"), btcUsd)
            );

            Candlestick candle = OHLCDataFactory.createCandlestick(btcUsd, oneMinute, baseTimestamp, transactions);

            assertEquals(btcUsd, candle.getSymbol());
            assertEquals(oneMinute, candle.getInterval());
            assertEquals(oneMinute.alignTimestamp(baseTimestamp), candle.getTimestamp());

            // OHLC should be calculated correctly
            assertEquals(Money.of("50000.00", Currency.USD), candle.getOpen()); // First transaction
            assertEquals(Money.of("51500.00", Currency.USD), candle.getHigh()); // Highest price
            assertEquals(Money.of("49500.00", Currency.USD), candle.getLow()); // Lowest price
            assertEquals(Money.of("50500.00", Currency.USD), candle.getClose()); // Last transaction

            // Volume should be sum of all transaction volumes
            assertEquals(0, new BigDecimal("1.4").compareTo(candle.getVolume()));
        }

        @Test
        @DisplayName("Should aggregate transactions into OHLC")
        void shouldAggregateTransactionsIntoOHLC() {
            List<TransactionData> transactions = Arrays.asList(
                    new TransactionData(baseTimestamp, Money.of("100.00", Currency.USD), new BigDecimal("1.0"), btcUsd),
                    new TransactionData(baseTimestamp.plus(10, ChronoUnit.SECONDS), Money.of("105.00", Currency.USD), new BigDecimal("1.0"), btcUsd),
                    new TransactionData(baseTimestamp.plus(20, ChronoUnit.SECONDS), Money.of("95.00", Currency.USD), new BigDecimal("1.0"), btcUsd),
                    new TransactionData(baseTimestamp.plus(30, ChronoUnit.SECONDS), Money.of("102.00", Currency.USD), new BigDecimal("1.0"), btcUsd)
            );

            OHLC ohlc = OHLCDataFactory.aggregateTransactions(transactions);

            assertEquals(Money.of("100.00", Currency.USD), ohlc.getOpen());
            assertEquals(Money.of("105.00", Currency.USD), ohlc.getHigh());
            assertEquals(Money.of("95.00", Currency.USD), ohlc.getLow());
            assertEquals(Money.of("102.00", Currency.USD), ohlc.getClose());
            assertTrue(ohlc.isValid());
        }

        @Test
        @DisplayName("Should create price range from candlesticks")
        void shouldCreatePriceRangeFromCandlesticks() {
            List<Candlestick> candles = Arrays.asList(
                    createCandlestickWithPrices("candle-1", baseTimestamp, "50000", "52000", "49000", "51000"),
                    createCandlestickWithPrices("candle-2", baseTimestamp.plus(1, ChronoUnit.MINUTES), "51000", "53000", "50500", "52500")
            );

            PriceRange priceRange = OHLCDataFactory.createPriceRange(candles);

            assertEquals(Money.of("49000.00", Currency.USD), priceRange.getMin());
            assertEquals(Money.of("53000.00", Currency.USD), priceRange.getMax());
            assertEquals(Money.of("4000.00", Currency.USD), priceRange.getRange());
        }

        @Test
        @DisplayName("Should validate factory inputs")
        void shouldValidateFactoryInputs() {
            // Null parameters should throw
            assertThrows(NullPointerException.class, () ->
                    OHLCDataFactory.createFromTransactions(null, oneMinute, Arrays.asList()));

            assertThrows(NullPointerException.class, () ->
                    OHLCDataFactory.createCandlestick(btcUsd, null, baseTimestamp, Arrays.asList()));

            // Empty transactions should throw for candlestick creation
            assertThrows(IllegalArgumentException.class, () ->
                    OHLCDataFactory.createCandlestick(btcUsd, oneMinute, baseTimestamp, Arrays.asList()));

            // Empty candles should throw for price range
            assertThrows(IllegalArgumentException.class, () ->
                    OHLCDataFactory.createPriceRange(Arrays.asList()));
        }

        @Test
        @DisplayName("Should validate transaction symbol consistency")
        void shouldValidateTransactionSymbolConsistency() {
            Symbol ethUsd = Symbol.ethUsd();
            List<TransactionData> mixedSymbols = Arrays.asList(
                    new TransactionData(baseTimestamp, Money.of("50000.00", Currency.USD), new BigDecimal("0.5"), btcUsd),
                    new TransactionData(baseTimestamp, Money.of("3000.00", Currency.USD), new BigDecimal("1.0"), ethUsd)
            );

            assertThrows(IllegalArgumentException.class, () ->
                    OHLCDataFactory.createCandlestick(btcUsd, oneMinute, baseTimestamp, mixedSymbols));
        }

        @Test
        @DisplayName("Should handle empty transactions for OHLCData creation")
        void shouldHandleEmptyTransactionsForOHLCDataCreation() {
            OHLCData result = OHLCDataFactory.createFromTransactions(btcUsd, oneMinute, Arrays.asList());

            assertNotNull(result);
            assertEquals(btcUsd, result.getSymbol());
            assertEquals(oneMinute, result.getInterval());
            assertTrue(result.isEmpty());
        }
    }

    @Nested
    @DisplayName("TransactionData Tests")
    class TransactionDataTests {

        @Test
        @DisplayName("Should create transaction data successfully")
        void shouldCreateTransactionDataSuccessfully() {
            Money price = Money.of("50000.00", Currency.USD);
            BigDecimal quantity = new BigDecimal("0.5");

            TransactionData data = new TransactionData(baseTimestamp, price, quantity, btcUsd);

            assertEquals(baseTimestamp, data.getTimestamp());
            assertEquals(price, data.getPrice());
            assertEquals(0, quantity.compareTo(data.getQuantity()));
            assertEquals(btcUsd, data.getSymbol());
            assertEquals(Money.of("25000.00", Currency.USD), data.getTotalValue());
        }

        @Test
        @DisplayName("Should validate transaction data constraints")
        void shouldValidateTransactionDataConstraints() {
            Money price = Money.of("50000.00", Currency.USD);

            // Null parameters should throw
            assertThrows(NullPointerException.class, () ->
                    new TransactionData(null, price, new BigDecimal("0.5"), btcUsd));

            // Zero or negative quantity should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new TransactionData(baseTimestamp, price, BigDecimal.ZERO, btcUsd));

            assertThrows(IllegalArgumentException.class, () ->
                    new TransactionData(baseTimestamp, price, new BigDecimal("-0.5"), btcUsd));
        }
    }

    @Nested
    @DisplayName("Additional Business Rule Tests")
    class AdditionalBusinessRuleTests {

        @Test
        @DisplayName("Should handle edge case: identical OHLC prices")
        void shouldHandleIdenticalOHLCPrices() {
            Money samePrice = Money.of("50000.00", Currency.USD);
            BigDecimal volume = new BigDecimal("1.0");

            // All prices identical - should be valid
            Candlestick flatCandle = new Candlestick(
                    "flat-candle", btcUsd, baseTimestamp, oneMinute,
                    samePrice, samePrice, samePrice, samePrice, volume
            );

            assertTrue(flatCandle.isDoji());
            assertEquals(Money.zero(Currency.USD), flatCandle.getBodySize());
            assertEquals(Money.zero(Currency.USD), flatCandle.getRange());
            assertEquals(Money.zero(Currency.USD), flatCandle.getUpperShadow());
            assertEquals(Money.zero(Currency.USD), flatCandle.getLowerShadow());
        }

        @Test
        @DisplayName("Should handle zero volume transactions")
        void shouldHandleZeroVolumeTransactions() {
            Money openPrice = Money.of("50000.00", Currency.USD);
            Money highPrice = Money.of("52000.00", Currency.USD);
            Money lowPrice = Money.of("49500.00", Currency.USD);
            Money closePrice = Money.of("51500.00", Currency.USD);

            // Zero volume should be allowed but handled correctly
            Candlestick zeroVolumeCandle = new Candlestick(
                    "zero-vol", btcUsd, baseTimestamp, oneMinute,
                    openPrice, highPrice, lowPrice, closePrice, BigDecimal.ZERO
            );

            assertEquals(BigDecimal.ZERO, zeroVolumeCandle.getVolume());
            // Weighted price should fall back to typical price when volume is zero
            assertEquals(zeroVolumeCandle.getTypicalPrice(), zeroVolumeCandle.getWeightedPrice());
        }

        @Test
        @DisplayName("Should handle concurrent candlestick additions to OHLCData")
        void shouldHandleConcurrentCandlestickAdditions() {
            // Test that OHLCData maintains consistency during concurrent operations
            OHLCData testOhlcData = new OHLCData("test-ohlc", btcUsd, oneMinute);

            // Add multiple candlesticks in different order
            Candlestick candle3 = createTestCandlestick("candle-3", baseTimestamp.plus(2, ChronoUnit.MINUTES));
            Candlestick candle1 = createTestCandlestick("candle-1", baseTimestamp);
            Candlestick candle2 = createTestCandlestick("candle-2", baseTimestamp.plus(1, ChronoUnit.MINUTES));

            testOhlcData.addCandle(candle3); // Add out of order
            testOhlcData.addCandle(candle1);
            testOhlcData.addCandle(candle2);

            List<Candlestick> sortedCandles = testOhlcData.getAllCandles();
            // Should be automatically sorted by timestamp
            assertEquals("candle-1", sortedCandles.get(0).getId());
            assertEquals("candle-2", sortedCandles.get(1).getId());
            assertEquals("candle-3", sortedCandles.get(2).getId());
        }

        @Test
        @DisplayName("Should validate interval boundary alignment")
        void shouldValidateIntervalBoundaryAlignment() {
            // Test that timestamps are properly aligned to interval boundaries
            Instant unalignedTime = Instant.parse("2024-01-01T12:34:45Z");
            Money price = Money.of("50000.00", Currency.USD);
            BigDecimal volume = new BigDecimal("1.0");

            // Factory should align timestamps automatically
            List<TransactionData> transactions = Arrays.asList(
                    new TransactionData(unalignedTime, price, volume, btcUsd)
            );

            Candlestick candle = OHLCDataFactory.createCandlestick(
                    btcUsd, TimeInterval.ONE_MINUTE, unalignedTime, transactions
            );

            // Should be aligned to minute boundary
            Instant expectedAligned = Instant.parse("2024-01-01T12:34:00Z");
            assertEquals(expectedAligned, candle.getTimestamp());
        }

        @Test
        @DisplayName("Should handle very large volume aggregations")
        void shouldHandleVeryLargeVolumeAggregations() {
            // Test handling of large volume numbers (institutional trades)
            BigDecimal largeVolume1 = new BigDecimal("1000000.123456789");
            BigDecimal largeVolume2 = new BigDecimal("2000000.987654321");
            Money openPrice = Money.of("50000.00", Currency.USD);
            Money closePrice = Money.of("51500.00", Currency.USD);

            List<TransactionData> largeVolumeTransactions = Arrays.asList(
                    new TransactionData(baseTimestamp, openPrice, largeVolume1, btcUsd),
                    new TransactionData(baseTimestamp.plus(30, ChronoUnit.SECONDS), closePrice, largeVolume2, btcUsd)
            );

            Candlestick candle = OHLCDataFactory.createCandlestick(
                    btcUsd, oneMinute, baseTimestamp, largeVolumeTransactions
            );

            BigDecimal expectedTotal = largeVolume1.add(largeVolume2);
            assertEquals(0, expectedTotal.compareTo(candle.getVolume()));
        }

        @Test
        @DisplayName("Should validate chart data conversion precision")
        void shouldValidateChartDataConversionPrecision() {
            // Test that converting to ChartData doesn't lose significant precision
            Money precisePrice = Money.of("50000.123456", Currency.USD);
            BigDecimal volume = new BigDecimal("1.5");

            Candlestick preciseCandle = new Candlestick(
                    "precise", btcUsd, baseTimestamp, oneMinute,
                    precisePrice, precisePrice, precisePrice, precisePrice, volume
            );

            ChartData chartData = preciseCandle.toChartData();

            // Should maintain reasonable precision (within double limits)
            assertEquals(50000.123456, chartData.getOpen(), 0.000001);
            assertEquals(50000.123456, chartData.getHigh(), 0.000001);
            assertEquals(50000.123456, chartData.getLow(), 0.000001);
            assertEquals(50000.123456, chartData.getClose(), 0.000001);
        }

        @Test
        @DisplayName("Should handle market gap scenarios")
        void shouldHandleMarketGapScenarios() {
            // Test gap up/down scenarios where open != previous close
            Money previousClose = Money.of("50000.00", Currency.USD);
            Money gapUpOpen = Money.of("52000.00", Currency.USD); // Gap up
            Money gapUpHigh = Money.of("53000.00", Currency.USD);
            Money gapUpLow = Money.of("51500.00", Currency.USD);
            Money gapUpClose = Money.of("52500.00", Currency.USD);
            BigDecimal volume = new BigDecimal("1.0");

            // Gap should be allowed - no validation between consecutive candles
            Candlestick gapCandle = new Candlestick(
                    "gap-candle", btcUsd, baseTimestamp, oneMinute,
                    gapUpOpen, gapUpHigh, gapUpLow, gapUpClose, volume
            );

            assertTrue(gapCandle.isBullish());
            // Open should be allowed to be different from any previous close
            assertNotEquals(previousClose, gapCandle.getOpen());
        }

        @Test
        @DisplayName("Should validate metadata calculation consistency")
        void shouldValidateMetadataCalculationConsistency() {
            // Test that metadata calculations are consistent with raw data
            OHLCData testOhlcData = new OHLCData("meta-test", btcUsd, oneMinute);

            Candlestick candle1 = createCandlestickWithPrices("c1", baseTimestamp, "50000", "52000", "49000", "51000");
            Candlestick candle2 = createCandlestickWithPrices("c2", baseTimestamp.plus(1, ChronoUnit.MINUTES), "51000", "53000", "50500", "52500");

            testOhlcData.addCandle(candle1);
            testOhlcData.addCandle(candle2);

            ChartMetadata metadata = OHLCDataFactory.createMetadata(testOhlcData);

            // Metadata should match direct calculations
            assertEquals(testOhlcData.getSymbol(), metadata.getSymbol());
            assertEquals(testOhlcData.getInterval(), metadata.getInterval());
            assertEquals(testOhlcData.size(), metadata.getTotalCandles());

            // Price range should match highest/lowest from candles
            assertEquals(testOhlcData.getHighestPrice().get(), metadata.getPriceRange().getMax());
            assertEquals(testOhlcData.getLowestPrice().get(), metadata.getPriceRange().getMin());
        }
    }

    // Helper methods
    private Candlestick createTestCandlestick(String id, Instant timestamp) {
        return new Candlestick(
                id, btcUsd, timestamp, oneMinute,
                Money.of("50000.00", Currency.USD),
                Money.of("51000.00", Currency.USD),
                Money.of("49500.00", Currency.USD),
                Money.of("50500.00", Currency.USD),
                new BigDecimal("1.0")
        );
    }

    private Candlestick createCandlestickWithPrices(String id, Instant timestamp,
                                                    String open, String high, String low, String close) {
        return new Candlestick(
                id, btcUsd, timestamp, oneMinute,
                Money.of(open, Currency.USD),
                Money.of(high, Currency.USD),
                Money.of(low, Currency.USD),
                Money.of(close, Currency.USD),
                new BigDecimal("1.0")
        );
    }

    private Candlestick createCandlestickWithVolume(String id, Instant timestamp, String volume) {
        return new Candlestick(
                id, btcUsd, timestamp, oneMinute,
                Money.of("50000.00", Currency.USD),
                Money.of("51000.00", Currency.USD),
                Money.of("49500.00", Currency.USD),
                Money.of("50500.00", Currency.USD),
                new BigDecimal(volume)
        );
    }
    @Nested
    @DisplayName("Advanced Business Rule Tests")
    class AdvancedBusinessRuleTests {

        @Test
        @DisplayName("Should enforce proper chronological order in transactions")
        void shouldEnforceProperChronologicalOrderInTransactions() {
            // Test that out-of-order transactions within same interval are handled correctly
            List<TransactionData> outOfOrderTransactions = Arrays.asList(
                    new TransactionData(baseTimestamp.plus(45, ChronoUnit.SECONDS), Money.of("51000.00", Currency.USD), new BigDecimal("0.3"), btcUsd), // Last
                    new TransactionData(baseTimestamp, Money.of("50000.00", Currency.USD), new BigDecimal("0.5"), btcUsd), // First
                    new TransactionData(baseTimestamp.plus(30, ChronoUnit.SECONDS), Money.of("52000.00", Currency.USD), new BigDecimal("0.2"), btcUsd)  // Middle
            );

            Candlestick candle = OHLCDataFactory.createCandlestick(btcUsd, oneMinute, baseTimestamp, outOfOrderTransactions);

            // Should use chronological order for OHLC: first transaction = open, last = close
            assertEquals(Money.of("50000.00", Currency.USD), candle.getOpen()); // Earliest timestamp
            assertEquals(Money.of("51000.00", Currency.USD), candle.getClose()); // Latest timestamp
            assertEquals(Money.of("52000.00", Currency.USD), candle.getHigh()); // Highest price
            assertEquals(Money.of("50000.00", Currency.USD), candle.getLow()); // Lowest price
        }

        @Test
        @DisplayName("Should validate cross-interval transaction boundaries")
        void shouldValidateCrossIntervalTransactionBoundaries() {
            // Test transactions exactly at interval boundaries
            Instant intervalBoundary = TimeInterval.ONE_MINUTE.alignTimestamp(baseTimestamp);
            Instant nextBoundary = intervalBoundary.plus(1, ChronoUnit.MINUTES);

            List<TransactionData> boundaryTransactions = Arrays.asList(
                    new TransactionData(intervalBoundary, Money.of("50000.00", Currency.USD), new BigDecimal("0.5"), btcUsd),
                    new TransactionData(nextBoundary, Money.of("51000.00", Currency.USD), new BigDecimal("0.3"), btcUsd)
            );

            OHLCData result = OHLCDataFactory.createFromTransactions(btcUsd, oneMinute, boundaryTransactions);

            // Should create separate candles for each interval
            assertEquals(2, result.size());

            List<Candlestick> candles = result.getAllCandles();
            assertEquals(intervalBoundary, candles.get(0).getTimestamp());
            assertEquals(nextBoundary, candles.get(1).getTimestamp());
        }

        @Test
        @DisplayName("Should handle weekend and holiday gaps")
        void shouldHandleWeekendAndHolidayGaps() {
            // Test large time gaps between candles (weekend, holidays)
            Instant friday = Instant.parse("2024-01-05T16:00:00Z"); // Friday 4 PM
            Instant monday = Instant.parse("2024-01-08T09:00:00Z"); // Monday 9 AM

            OHLCData testOhlcData = new OHLCData("weekend-test", btcUsd, oneMinute);

            Candlestick fridayCandle = createTestCandlestick("friday", friday);
            Candlestick mondayCandle = createTestCandlestick("monday", monday);

            testOhlcData.addCandle(fridayCandle);
            testOhlcData.addCandle(mondayCandle);

            // Should handle large gaps without issues
            assertEquals(2, testOhlcData.size());

            Optional<DateRange> dateRange = testOhlcData.getDateRange();
            assertTrue(dateRange.isPresent());
            assertTrue(dateRange.get().getDuration().toDays() >= 2); // Multi-day gap
        }

        @Test
        @DisplayName("Should validate extreme market conditions")
        void shouldValidateExtremeMarketConditions() {
            // Test market crash scenario (90% drop)
            Money precrashPrice = Money.of("50000.00", Currency.USD);
            Money crashPrice = Money.of("5000.00", Currency.USD); // 90% drop

            // Should allow extreme but valid price movements
            assertDoesNotThrow(() -> new Candlestick(
                    "crash-candle", btcUsd, baseTimestamp, oneMinute,
                    precrashPrice, precrashPrice, crashPrice, crashPrice, new BigDecimal("100000.0") // High volume during crash
            ));

            // Test market pump scenario (1000% increase)
            Money pumpPrice = Money.of("500000.00", Currency.USD); // 10x increase

            assertDoesNotThrow(() -> new Candlestick(
                    "pump-candle", btcUsd, baseTimestamp, oneMinute,
                    precrashPrice, pumpPrice, precrashPrice, pumpPrice, new BigDecimal("50000.0")
            ));
        }

        @Test
        @DisplayName("Should handle empty intervals in continuous data")
        void shouldHandleEmptyIntervalsInContinuousData() {
            // Test scenario where some intervals have no transactions
            List<TransactionData> sparseTransactions = Arrays.asList(
                    new TransactionData(baseTimestamp, Money.of("50000.00", Currency.USD), new BigDecimal("0.5"), btcUsd),
                    // No transactions at baseTimestamp + 1 minute
                    new TransactionData(baseTimestamp.plus(2, ChronoUnit.MINUTES), Money.of("51000.00", Currency.USD), new BigDecimal("0.3"), btcUsd),
                    // No transactions at baseTimestamp + 3 minutes
                    new TransactionData(baseTimestamp.plus(4, ChronoUnit.MINUTES), Money.of("52000.00", Currency.USD), new BigDecimal("0.7"), btcUsd)
            );

            OHLCData result = OHLCDataFactory.createFromTransactions(btcUsd, oneMinute, sparseTransactions);

            // Should only create candles for intervals with transactions
            assertEquals(3, result.size()); // Only intervals with actual transactions

            List<Candlestick> candles = result.getAllCandles();
            assertEquals(baseTimestamp, candles.get(0).getTimestamp());
            assertEquals(baseTimestamp.plus(2, ChronoUnit.MINUTES), candles.get(1).getTimestamp());
            assertEquals(baseTimestamp.plus(4, ChronoUnit.MINUTES), candles.get(2).getTimestamp());
        }

        @Test
        @DisplayName("Should validate different currency pairs consistency")
        void shouldValidateDifferentCurrencyPairsConsistency() {
            // Test EUR-based symbol
            Symbol btcEur = Symbol.btcEur();
            Money eurPrice = Money.of("45000.00", Currency.EUR);

            OHLCData eurOhlcData = new OHLCData("btc-eur-ohlc", btcEur, oneMinute);

            Candlestick eurCandle = new Candlestick(
                    "eur-candle", btcEur, baseTimestamp, oneMinute,
                    eurPrice, eurPrice.add(Money.of("1000", Currency.EUR)),
                    eurPrice.subtract(Money.of("500", Currency.EUR)), eurPrice,
                    new BigDecimal("1.0")
            );

            // Should work with different quote currencies
            assertDoesNotThrow(() -> eurOhlcData.addCandle(eurCandle));

            // But mixing currencies should fail
            Money usdPrice = Money.of("50000.00", Currency.USD);

            assertThrows(IllegalArgumentException.class, () -> new Candlestick(
                    "mixed-currency", btcEur, baseTimestamp, oneMinute,
                    usdPrice, usdPrice, usdPrice, usdPrice, new BigDecimal("1.0")
            ));
        }

        @Test
        @DisplayName("Should handle microsecond-level transaction timing")
        void shouldHandleMicrosecondLevelTransactionTiming() {
            // Test very close transaction times (microseconds apart)
            List<TransactionData> microTransactions = Arrays.asList(
                    new TransactionData(baseTimestamp, Money.of("50000.00", Currency.USD), new BigDecimal("0.1"), btcUsd),
                    new TransactionData(baseTimestamp.plusNanos(1000), Money.of("50001.00", Currency.USD), new BigDecimal("0.2"), btcUsd), // 1 microsecond later
                    new TransactionData(baseTimestamp.plusNanos(2000), Money.of("49999.00", Currency.USD), new BigDecimal("0.3"), btcUsd)  // 2 microseconds later
            );

            Candlestick candle = OHLCDataFactory.createCandlestick(btcUsd, oneMinute, baseTimestamp, microTransactions);

            // Should handle nanosecond precision correctly
            assertEquals(Money.of("50000.00", Currency.USD), candle.getOpen()); // First
            assertEquals(Money.of("49999.00", Currency.USD), candle.getClose()); // Last
            assertEquals(Money.of("50001.00", Currency.USD), candle.getHigh()); // Highest
            assertEquals(Money.of("49999.00", Currency.USD), candle.getLow()); // Lowest
        }

        @Test
        @DisplayName("Should validate reasonable interval progression")
        void shouldValidateReasonableIntervalProgression() {
            // Test that all interval types work correctly
            for (TimeInterval interval : TimeInterval.values()) {
                Instant aligned = interval.alignTimestamp(baseTimestamp);
                Instant next = interval.getNextTimestamp(aligned);
                Instant previous = interval.getPreviousTimestamp(aligned);

                // Next should be exactly one interval later
                assertEquals(interval.getDuration(), Duration.between(aligned, next));

                // Previous should be exactly one interval earlier
                assertEquals(interval.getDuration(), Duration.between(previous, aligned));

                // Alignment should be idempotent
                assertEquals(aligned, interval.alignTimestamp(aligned));
            }
        }

        @Test
        @DisplayName("Should enforce business rule: no future timestamps")
        void shouldEnforceNoFutureTimestamps() {
            // Test that future timestamps are handled appropriately
            Instant futureTime = Instant.now().plus(1, ChronoUnit.DAYS);

            // Should allow future timestamps (for testing, simulations, etc.)
            // But document that in production, validation might be needed
            assertDoesNotThrow(() -> new TransactionData(
                    futureTime, Money.of("50000.00", Currency.USD), new BigDecimal("1.0"), btcUsd
            ));

            assertDoesNotThrow(() -> createTestCandlestick("future-candle", futureTime));
        }

        @Test
        @DisplayName("Should validate aggregation consistency across different intervals")
        void shouldValidateAggregationConsistencyAcrossDifferentIntervals() {
            // Test that 1-minute data aggregates correctly into 5-minute data
            List<TransactionData> transactions = Arrays.asList(
                    // Minute 1
                    new TransactionData(baseTimestamp, Money.of("50000.00", Currency.USD), new BigDecimal("1.0"), btcUsd),
                    new TransactionData(baseTimestamp.plus(30, ChronoUnit.SECONDS), Money.of("50500.00", Currency.USD), new BigDecimal("0.5"), btcUsd),
                    // Minute 2
                    new TransactionData(baseTimestamp.plus(60, ChronoUnit.SECONDS), Money.of("51000.00", Currency.USD), new BigDecimal("2.0"), btcUsd),
                    // Minute 3
                    new TransactionData(baseTimestamp.plus(120, ChronoUnit.SECONDS), Money.of("51500.00", Currency.USD), new BigDecimal("1.5"), btcUsd),
                    // Minute 4
                    new TransactionData(baseTimestamp.plus(180, ChronoUnit.SECONDS), Money.of("52000.00", Currency.USD), new BigDecimal("0.8"), btcUsd),
                    // Minute 5
                    new TransactionData(baseTimestamp.plus(240, ChronoUnit.SECONDS), Money.of("51800.00", Currency.USD), new BigDecimal("1.2"), btcUsd)
            );

            // Create 1-minute candles
            OHLCData oneMinuteData = OHLCDataFactory.createFromTransactions(btcUsd, TimeInterval.ONE_MINUTE, transactions);

            // Create 5-minute candles from same data
            OHLCData fiveMinuteData = OHLCDataFactory.createFromTransactions(btcUsd, TimeInterval.FIVE_MINUTES, transactions);

            // 1-minute should have multiple candles
            assertTrue(oneMinuteData.size() > 1);

            // 5-minute should aggregate all into one candle (within 5-minute window)
            assertEquals(1, fiveMinuteData.size());

            Candlestick fiveMinCandle = fiveMinuteData.getAllCandles().get(0);

            // 5-minute candle should have:
            // - Open: first transaction price
            // - Close: last transaction price
            // - High: highest across all transactions
            // - Low: lowest across all transactions
            // - Volume: sum of all volumes
            assertEquals(Money.of("50000.00", Currency.USD), fiveMinCandle.getOpen());
            assertEquals(Money.of("51800.00", Currency.USD), fiveMinCandle.getClose());
            assertEquals(Money.of("52000.00", Currency.USD), fiveMinCandle.getHigh());
            assertEquals(Money.of("50000.00", Currency.USD), fiveMinCandle.getLow());
            assertEquals(0, new BigDecimal("7.0").compareTo(fiveMinCandle.getVolume())); // Sum of all volumes
        }

    }

}=== ./OHLC/domain/OHLCDomainTest.java ===
package core.ms.OHLC.domain;


import core.ms.shared.domain.Currency;
import core.ms.shared.domain.Money;
import core.ms.shared.domain.Symbol;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("OHLC Domain Tests")
class OHLCDomainTest {

    private Symbol btcUsd;
    private TimeInterval oneMinute;
    private Instant baseTimestamp;
    private Money openPrice;
    private Money highPrice;
    private Money lowPrice;
    private Money closePrice;
    private BigDecimal volume;

    @BeforeEach
    void setUp() {
        btcUsd = Symbol.btcUsd();
        oneMinute = TimeInterval.ONE_MINUTE;
        baseTimestamp = Instant.parse("2024-01-01T12:00:00Z");
        openPrice = Money.of("50000.00", Currency.USD);
        highPrice = Money.of("52000.00", Currency.USD);
        lowPrice = Money.of("49500.00", Currency.USD);
        closePrice = Money.of("51500.00", Currency.USD);
        volume = new BigDecimal("1.5");
    }

    @Nested
    @DisplayName("TimeInterval Tests")
    class TimeIntervalTests {

        @Test
        @DisplayName("Should have correct codes and durations")
        void shouldHaveCorrectCodesAndDurations() {
            assertEquals("1m", TimeInterval.ONE_MINUTE.getCode());
            assertEquals("5m", TimeInterval.FIVE_MINUTES.getCode());
            assertEquals("1h", TimeInterval.ONE_HOUR.getCode());
            assertEquals("1d", TimeInterval.ONE_DAY.getCode());

            assertEquals(60_000L, TimeInterval.ONE_MINUTE.getMilliseconds());
            assertEquals(300_000L, TimeInterval.FIVE_MINUTES.getMilliseconds());
            assertEquals(3_600_000L, TimeInterval.ONE_HOUR.getMilliseconds());
        }

        @Test
        @DisplayName("Should compare intervals correctly")
        void shouldCompareIntervalsCorrectly() {
            assertTrue(TimeInterval.ONE_HOUR.isHigherThan(TimeInterval.ONE_MINUTE));
            assertTrue(TimeInterval.ONE_MINUTE.isLowerThan(TimeInterval.ONE_HOUR));
            assertFalse(TimeInterval.ONE_MINUTE.isHigherThan(TimeInterval.ONE_HOUR));
        }

        @Test
        @DisplayName("Should align timestamps correctly")
        void shouldAlignTimestampsCorrectly() {
            // Test 1-minute alignment
            Instant unaligned = Instant.parse("2024-01-01T12:34:45Z");
            Instant aligned = TimeInterval.ONE_MINUTE.alignTimestamp(unaligned);
            assertEquals(Instant.parse("2024-01-01T12:34:00Z"), aligned);

            // Test 1-hour alignment
            Instant hourAligned = TimeInterval.ONE_HOUR.alignTimestamp(unaligned);
            assertEquals(Instant.parse("2024-01-01T12:00:00Z"), hourAligned);
        }

        @Test
        @DisplayName("Should calculate next and previous timestamps")
        void shouldCalculateNextAndPreviousTimestamps() {
            Instant current = Instant.parse("2024-01-01T12:00:00Z");

            Instant next = TimeInterval.ONE_MINUTE.getNextTimestamp(current);
            assertEquals(Instant.parse("2024-01-01T12:01:00Z"), next);

            Instant previous = TimeInterval.ONE_MINUTE.getPreviousTimestamp(current);
            assertEquals(Instant.parse("2024-01-01T11:59:00Z"), previous);
        }
    }

    @Nested
    @DisplayName("Candlestick Tests")
    class CandlestickTests {

        @Test
        @DisplayName("Should create candlestick successfully")
        void shouldCreateCandlestickSuccessfully() {
            Candlestick candle = new Candlestick(
                    "candle-1", btcUsd, baseTimestamp, oneMinute,
                    openPrice, highPrice, lowPrice, closePrice, volume
            );

            assertEquals("candle-1", candle.getId());
            assertEquals(btcUsd, candle.getSymbol());
            assertEquals(baseTimestamp, candle.getTimestamp());
            assertEquals(oneMinute, candle.getInterval());
            assertEquals(openPrice, candle.getOpen());
            assertEquals(highPrice, candle.getHigh());
            assertEquals(lowPrice, candle.getLow());
            assertEquals(closePrice, candle.getClose());
            assertEquals(0, volume.compareTo(candle.getVolume()));
        }

        @Test
        @DisplayName("Should validate OHLC constraints")
        void shouldValidateOHLCConstraints() {
            // High < Low should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new Candlestick("candle-1", btcUsd, baseTimestamp, oneMinute,
                            openPrice, Money.of("48000.00", Currency.USD), lowPrice, closePrice, volume)
            );

            // Open > High should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new Candlestick("candle-1", btcUsd, baseTimestamp, oneMinute,
                            Money.of("53000.00", Currency.USD), highPrice, lowPrice, closePrice, volume)
            );

            // Close < Low should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new Candlestick("candle-1", btcUsd, baseTimestamp, oneMinute,
                            openPrice, highPrice, lowPrice, Money.of("49000.00", Currency.USD), volume)
            );
        }

        @Test
        @DisplayName("Should validate currency consistency")
        void shouldValidateCurrencyConsistency() {
            Money eurPrice = Money.of("45000.00", Currency.EUR);

            assertThrows(IllegalArgumentException.class, () ->
                    new Candlestick("candle-1", btcUsd, baseTimestamp, oneMinute,
                            eurPrice, highPrice, lowPrice, closePrice, volume)
            );
        }

        @Test
        @DisplayName("Should validate volume constraints")
        void shouldValidateVolumeConstraints() {
            assertThrows(IllegalArgumentException.class, () ->
                    new Candlestick("candle-1", btcUsd, baseTimestamp, oneMinute,
                            openPrice, highPrice, lowPrice, closePrice, new BigDecimal("-1.0"))
            );
        }

        @Test
        @DisplayName("Should calculate business logic correctly")
        void shouldCalculateBusinessLogicCorrectly() {
            // Bullish candle (close > open)
            Candlestick bullishCandle = new Candlestick(
                    "candle-1", btcUsd, baseTimestamp, oneMinute,
                    openPrice, highPrice, lowPrice, closePrice, volume
            );

            assertTrue(bullishCandle.isBullish());
            assertFalse(bullishCandle.isBearish());
            assertFalse(bullishCandle.isDoji());

            // Bearish candle (close < open)
            Candlestick bearishCandle = new Candlestick(
                    "candle-2", btcUsd, baseTimestamp, oneMinute,
                    closePrice, highPrice, lowPrice, openPrice, volume
            );

            assertFalse(bearishCandle.isBullish());
            assertTrue(bearishCandle.isBearish());
            assertFalse(bearishCandle.isDoji());

            // Doji candle (close = open)
            Candlestick dojiCandle = new Candlestick(
                    "candle-3", btcUsd, baseTimestamp, oneMinute,
                    openPrice, highPrice, lowPrice, openPrice, volume
            );

            assertFalse(dojiCandle.isBullish());
            assertFalse(dojiCandle.isBearish());
            assertTrue(dojiCandle.isDoji());
        }

        @Test
        @DisplayName("Should calculate price metrics correctly")
        void shouldCalculatePriceMetricsCorrectly() {
            Candlestick candle = new Candlestick(
                    "candle-1", btcUsd, baseTimestamp, oneMinute,
                    openPrice, highPrice, lowPrice, closePrice, volume
            );

            // Body size = |close - open| = |51500 - 50000| = 1500
            Money expectedBodySize = Money.of("1500.00", Currency.USD);
            assertEquals(expectedBodySize, candle.getBodySize());

            // Range = high - low = 52000 - 49500 = 2500
            Money expectedRange = Money.of("2500.00", Currency.USD);
            assertEquals(expectedRange, candle.getRange());

            // Upper shadow = high - max(open, close) = 52000 - 51500 = 500
            Money expectedUpperShadow = Money.of("500.00", Currency.USD);
            assertEquals(expectedUpperShadow, candle.getUpperShadow());

            // Lower shadow = min(open, close) - low = 50000 - 49500 = 500
            Money expectedLowerShadow = Money.of("500.00", Currency.USD);
            assertEquals(expectedLowerShadow, candle.getLowerShadow());
        }

        @Test
        @DisplayName("Should calculate typical and weighted prices")
        void shouldCalculateTypicalAndWeightedPrices() {
            Candlestick candle = new Candlestick(
                    "candle-1", btcUsd, baseTimestamp, oneMinute,
                    openPrice, highPrice, lowPrice, closePrice, volume
            );

            // Typical price = (high + low + close) / 3 = (52000 + 49500 + 51500) / 3 = 51000
            Money expectedTypicalPrice = Money.of("51000.00", Currency.USD);
            assertEquals(expectedTypicalPrice, candle.getTypicalPrice());

            // Weighted price should be the same as typical price when volume > 0
            assertEquals(expectedTypicalPrice, candle.getWeightedPrice());
        }

        @Test
        @DisplayName("Should convert to chart data correctly")
        void shouldConvertToChartDataCorrectly() {
            Candlestick candle = new Candlestick(
                    "candle-1", btcUsd, baseTimestamp, oneMinute,
                    openPrice, highPrice, lowPrice, closePrice, volume
            );

            ChartData chartData = candle.toChartData();

            assertEquals(baseTimestamp.getEpochSecond(), chartData.getTime());
            assertEquals(50000.0, chartData.getOpen(), 0.01);
            assertEquals(52000.0, chartData.getHigh(), 0.01);
            assertEquals(49500.0, chartData.getLow(), 0.01);
            assertEquals(51500.0, chartData.getClose(), 0.01);
            assertEquals(1.5, chartData.getVolume(), 0.01);
        }

        @Test
        @DisplayName("Should have proper string representation")
        void shouldHaveProperStringRepresentation() {
            Candlestick candle = new Candlestick(
                    "candle-1", btcUsd, baseTimestamp, oneMinute,
                    openPrice, highPrice, lowPrice, closePrice, volume
            );

            String result = candle.toString();
            assertTrue(result.contains("candle-1"));
            assertTrue(result.contains("BTC"));
            assertTrue(result.contains("1m"));
            assertTrue(result.contains("📈")); // Bullish emoji
        }
    }

    @Nested
    @DisplayName("OHLC Value Object Tests")
    class OHLCTests {

        @Test
        @DisplayName("Should create OHLC successfully")
        void shouldCreateOHLCSuccessfully() {
            OHLC ohlc = new OHLC(openPrice, highPrice, lowPrice, closePrice);

            assertEquals(openPrice, ohlc.getOpen());
            assertEquals(highPrice, ohlc.getHigh());
            assertEquals(lowPrice, ohlc.getLow());
            assertEquals(closePrice, ohlc.getClose());
            assertTrue(ohlc.isValid());
        }

        @Test
        @DisplayName("Should validate OHLC constraints")
        void shouldValidateOHLCConstraints() {
            // High < Low should be invalid
            assertThrows(IllegalArgumentException.class, () ->
                    new OHLC(openPrice, Money.of("48000.00", Currency.USD), lowPrice, closePrice)
            );

            // Create invalid OHLC and check isValid()
            assertThrows(IllegalArgumentException.class, () ->
                    new OHLC(Money.of("53000.00", Currency.USD), highPrice, lowPrice, closePrice)
            );
        }
    }

    @Nested
    @DisplayName("DateRange Tests")
    class DateRangeTests {

        @Test
        @DisplayName("Should create date range successfully")
        void shouldCreateDateRangeSuccessfully() {
            Instant start = baseTimestamp;
            Instant end = baseTimestamp.plus(1, ChronoUnit.HOURS);

            DateRange range = new DateRange(start, end);

            assertEquals(start, range.getStart());
            assertEquals(end, range.getEnd());
            assertEquals(3600, range.getDuration().getSeconds());
        }

        @Test
        @DisplayName("Should validate date range constraints")
        void shouldValidateDateRangeConstraints() {
            Instant start = baseTimestamp;
            Instant end = baseTimestamp.minus(1, ChronoUnit.HOURS);

            assertThrows(IllegalArgumentException.class, () ->
                    new DateRange(start, end)
            );
        }

        @Test
        @DisplayName("Should check if contains timestamp")
        void shouldCheckIfContainsTimestamp() {
            Instant start = baseTimestamp;
            Instant end = baseTimestamp.plus(1, ChronoUnit.HOURS);
            DateRange range = new DateRange(start, end);

            assertTrue(range.contains(baseTimestamp));
            assertTrue(range.contains(baseTimestamp.plus(30, ChronoUnit.MINUTES)));
            assertTrue(range.contains(end));
            assertFalse(range.contains(baseTimestamp.minus(1, ChronoUnit.MINUTES)));
            assertFalse(range.contains(end.plus(1, ChronoUnit.MINUTES)));
        }

        @Test
        @DisplayName("Should check overlaps correctly")
        void shouldCheckOverlapsCorrectly() {
            DateRange range1 = new DateRange(
                    baseTimestamp,
                    baseTimestamp.plus(1, ChronoUnit.HOURS)
            );

            DateRange range2 = new DateRange(
                    baseTimestamp.plus(30, ChronoUnit.MINUTES),
                    baseTimestamp.plus(90, ChronoUnit.MINUTES)
            );

            DateRange range3 = new DateRange(
                    baseTimestamp.plus(2, ChronoUnit.HOURS),
                    baseTimestamp.plus(3, ChronoUnit.HOURS)
            );

            assertTrue(range1.overlaps(range2));
            assertTrue(range2.overlaps(range1));
            assertFalse(range1.overlaps(range3));
            assertFalse(range3.overlaps(range1));
        }
    }

    @Nested
    @DisplayName("PriceRange Tests")
    class PriceRangeTests {

        @Test
        @DisplayName("Should create price range successfully")
        void shouldCreatePriceRangeSuccessfully() {
            PriceRange range = new PriceRange(lowPrice, highPrice);

            assertEquals(lowPrice, range.getMin());
            assertEquals(highPrice, range.getMax());
            assertEquals(Money.of("2500.00", Currency.USD), range.getRange());
        }

        @Test
        @DisplayName("Should validate price range constraints")
        void shouldValidatePriceRangeConstraints() {
            // Min > Max should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new PriceRange(highPrice, lowPrice)
            );

            // Different currencies should throw
            Money eurPrice = Money.of("45000.00", Currency.EUR);
            assertThrows(IllegalArgumentException.class, () ->
                    new PriceRange(eurPrice, highPrice)
            );
        }

        @Test
        @DisplayName("Should check if contains price")
        void shouldCheckIfContainsPrice() {
            PriceRange range = new PriceRange(lowPrice, highPrice);

            assertTrue(range.contains(lowPrice));
            assertTrue(range.contains(highPrice));
            assertTrue(range.contains(Money.of("51000.00", Currency.USD)));
            assertFalse(range.contains(Money.of("49000.00", Currency.USD)));
            assertFalse(range.contains(Money.of("53000.00", Currency.USD)));
        }

        @Test
        @DisplayName("Should calculate percentage position")
        void shouldCalculatePercentagePosition() {
            PriceRange range = new PriceRange(lowPrice, highPrice);

            // At minimum: 0%
            assertEquals(0, range.getPercentagePosition(lowPrice).compareTo(BigDecimal.ZERO));

            // At maximum: 100%
            assertEquals(0, range.getPercentagePosition(highPrice).compareTo(BigDecimal.ONE));

            // At midpoint: 50%
            Money midPrice = Money.of("51000.00", Currency.USD);
            BigDecimal percentage = range.getPercentagePosition(midPrice);
            assertEquals(0, percentage.compareTo(new BigDecimal("0.6000"))); // (51000-49500)/(52000-49500) = 0.6
        }
    }

    @Nested
    @DisplayName("VolumeRange Tests")
    class VolumeRangeTests {

        @Test
        @DisplayName("Should create volume range successfully")
        void shouldCreateVolumeRangeSuccessfully() {
            BigDecimal min = new BigDecimal("1.0");
            BigDecimal max = new BigDecimal("5.0");
            BigDecimal avg = new BigDecimal("3.0");

            VolumeRange range = new VolumeRange(min, max, avg);

            assertEquals(0, min.compareTo(range.getMin()));
            assertEquals(0, max.compareTo(range.getMax()));
            assertEquals(0, avg.compareTo(range.getAverage()));
            assertEquals(0, new BigDecimal("4.0").compareTo(range.getRange()));
        }

        @Test
        @DisplayName("Should validate volume range constraints")
        void shouldValidateVolumeRangeConstraints() {
            BigDecimal min = new BigDecimal("5.0");
            BigDecimal max = new BigDecimal("1.0");
            BigDecimal avg = new BigDecimal("3.0");

            // Min > Max should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new VolumeRange(min, max, avg)
            );

            // Negative values should throw
            assertThrows(IllegalArgumentException.class, () ->
                    new VolumeRange(new BigDecimal("-1.0"), max, avg)
            );
        }
    }

    @Nested
    @DisplayName("Chart Data Tests")
    class ChartDataTests {

        @Test
        @DisplayName("Should create OHLC chart data successfully")
        void shouldCreateOHLCChartDataSuccessfully() {
            long time = baseTimestamp.getEpochSecond();
            OHLCChartData chartData = new OHLCChartData(time, 50000.0, 52000.0, 49500.0, 51500.0, 1.5);

            assertEquals(time, chartData.getTime());
            assertEquals(50000.0, chartData.getOpen(), 0.01);
            assertEquals(52000.0, chartData.getHigh(), 0.01);
            assertEquals(49500.0, chartData.getLow(), 0.01);
            assertEquals(51500.0, chartData.getClose(), 0.01);
            assertEquals(1.5, chartData.getVolume(), 0.01);
        }

        @Test
        @DisplayName("Should have proper string representation")
        void shouldHaveProperStringRepresentation() {
            long time = baseTimestamp.getEpochSecond();
            OHLCChartData chartData = new OHLCChartData(time, 50000.0, 52000.0, 49500.0, 51500.0, 1.5);

            String result = chartData.toString();
            assertTrue(result.contains("ChartData"));
            assertTrue(result.contains("50000"));
            assertTrue(result.contains("52000"));
        }
    }
}